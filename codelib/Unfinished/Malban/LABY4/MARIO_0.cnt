BANK 0
EQU $00 
LABEL $C800 Vec_Snd_Shadow
COMMENT_LABEL $C800 Shadow of sound chip registers (15 bytes)
LABEL $C80F Vec_Btn_State
COMMENT_LABEL $C80F Current state of all joystick buttons
LABEL $C810 Vec_Prev_Btns
COMMENT_LABEL $C810 Previous state of all joystick buttons
LABEL $C811 Vec_Buttons
COMMENT_LABEL $C811 Current toggle state of all buttons
LABEL $C812 Vec_Button_1_1
COMMENT_LABEL $C812 Current toggle state of stick 1 button 1
LABEL $C813 Vec_Button_1_2
COMMENT_LABEL $C813 Current toggle state of stick 1 button 2
LABEL $C814 Vec_Button_1_3
COMMENT_LABEL $C814 Current toggle state of stick 1 button 3
LABEL $C815 Vec_Button_1_4
COMMENT_LABEL $C815 Current toggle state of stick 1 button 4
LABEL $C816 Vec_Button_2_1
COMMENT_LABEL $C816 Current toggle state of stick 2 button 1
LABEL $C817 Vec_Button_2_2
COMMENT_LABEL $C817 Current toggle state of stick 2 button 2
LABEL $C818 Vec_Button_2_3
COMMENT_LABEL $C818 Current toggle state of stick 2 button 3
LABEL $C819 Vec_Button_2_4
COMMENT_LABEL $C819 Current toggle state of stick 2 button 4
LABEL $C81A Vec_Joy_Resltn
COMMENT_LABEL $C81A Joystick A/D resolution ($80=min $00=max)
LABEL $C81B Vec_Joy_1_X
COMMENT_LABEL $C81B Joystick 1 left/right
LABEL $C81C Vec_Joy_1_Y
COMMENT_LABEL $C81C Joystick 1 up/down
LABEL $C81D Vec_Joy_2_X
COMMENT_LABEL $C81D Joystick 2 left/right
LABEL $C81E Vec_Joy_2_Y
COMMENT_LABEL $C81E Joystick 2 up/down
LABEL $C81F Vec_Joy_Mux
COMMENT_LABEL $C81F Joystick enable/mux flags (4 bytes)
LABEL $C81F Vec_Joy_Mux_1_X
COMMENT_LABEL $C81F Joystick 1 X enable/mux flag (=1)
LABEL $C820 Vec_Joy_Mux_1_Y
COMMENT_LABEL $C820 Joystick 1 Y enable/mux flag (=3)
LABEL $C821 Vec_Joy_Mux_2_X
COMMENT_LABEL $C821 Joystick 2 X enable/mux flag (=5)
LABEL $C822 Vec_Joy_Mux_2_Y
COMMENT_LABEL $C822 Joystick 2 Y enable/mux flag (=7)
LABEL $C823 Vec_Misc_Count
COMMENT_LABEL $C823 Misc counter/flag byte, zero when not in use
LABEL $C824 Vec_0Ref_Enable
COMMENT_LABEL $C824 Check0Ref enable flag
LABEL $C825 Vec_Loop_Count
COMMENT_LABEL $C825 Loop counter word (incremented in Wait_Recal)
LABEL $C827 Vec_Brightness
COMMENT_LABEL $C827 Default brightness
LABEL $C828 Vec_Dot_Dwell
COMMENT_LABEL $C828 Dot dwell time?
LABEL $C829 Vec_Pattern
COMMENT_LABEL $C829 Dot pattern (bits)
LABEL $C82A Vec_Text_HW
COMMENT_LABEL $C82A Default text height and width
LABEL $C82A Vec_Text_Height
COMMENT_LABEL $C82A Default text height
LABEL $C82B Vec_Text_Width
COMMENT_LABEL $C82B Default text width
LABEL $C82C Vec_Str_Ptr
COMMENT_LABEL $C82C Temporary string pointer for Print_Str
LABEL $C82E Vec_Counters
COMMENT_LABEL $C82E Six bytes of counters
LABEL $C82E Vec_Counter_1
COMMENT_LABEL $C82E First  counter byte
LABEL $C82F Vec_Counter_2
COMMENT_LABEL $C82F Second counter byte
LABEL $C830 Vec_Counter_3
COMMENT_LABEL $C830 Third  counter byte
LABEL $C831 Vec_Counter_4
COMMENT_LABEL $C831 Fourth counter byte
LABEL $C832 Vec_Counter_5
COMMENT_LABEL $C832 Fifth  counter byte
LABEL $C833 Vec_Counter_6
COMMENT_LABEL $C833 Sixth  counter byte
LABEL $C834 Vec_RiseRun_Tmp
COMMENT_LABEL $C834 Temp storage word for rise/run
LABEL $C836 Vec_Angle
COMMENT_LABEL $C836 Angle for rise/run and rotation calculations
LABEL $C837 Vec_Run_Index
COMMENT_LABEL $C837 Index pair for run
LABEL $C839 Vec_Rise_Index
COMMENT_LABEL $C839 Index pair for rise
LABEL $C83B Vec_RiseRun_Len
COMMENT_LABEL $C83B length for rise/run
LABEL $C83D Vec_Rfrsh
COMMENT_LABEL $C83D Refresh time (divided by 1.5MHz)
LABEL $C83D Vec_Rfrsh_lo
COMMENT_LABEL $C83D Refresh time low byte
LABEL $C83E Vec_Rfrsh_hi
COMMENT_LABEL $C83E Refresh time high byte
LABEL $C83F Vec_Music_Work
COMMENT_LABEL $C83F Music work buffer (14 bytes, backwards?)
LABEL $C842 Vec_Music_Wk_A
COMMENT_LABEL $C842 register 10
LABEL $C845 Vec_Music_Wk_7
COMMENT_LABEL $C845 register 7
LABEL $C846 Vec_Music_Wk_6
COMMENT_LABEL $C846 register 6
LABEL $C847 Vec_Music_Wk_5
COMMENT_LABEL $C847 register 5
LABEL $C84B Vec_Music_Wk_1
COMMENT_LABEL $C84B register 1
LABEL $C84D Vec_Freq_Table
COMMENT_LABEL $C84D Pointer to note-to-frequency table (normally $FC8D)
LABEL $C84F Vec_Max_Players
COMMENT_LABEL $C84F Maximum number of players for Select_Game
LABEL $C850 Vec_Max_Games
COMMENT_LABEL $C850 Maximum number of games for Select_Game
LABEL $C84F Vec_ADSR_Table
COMMENT_LABEL $C84F Storage for first music header word (ADSR table)
LABEL $C851 Vec_Twang_Table
COMMENT_LABEL $C851 Storage for second music header word ('twang' table)
LABEL $C853 Vec_Music_Ptr
COMMENT_LABEL $C853 Music data pointer
LABEL $C853 Vec_Expl_ChanA
COMMENT_LABEL $C853 Used by Explosion_Snd - bit for first channel used?
LABEL $C854 Vec_Expl_Chans
COMMENT_LABEL $C854 Used by Explosion_Snd - bits for all channels used?
LABEL $C855 Vec_Music_Chan
COMMENT_LABEL $C855 Current sound channel number for Init_Music
LABEL $C856 Vec_Music_Flag
COMMENT_LABEL $C856 Music active flag ($00=off $01=start $80=on)
LABEL $C857 Vec_Duration
COMMENT_LABEL $C857 Duration counter for Init_Music
LABEL $C858 Vec_Music_Twang
COMMENT_LABEL $C858 3 word 'twang' table used by Init_Music
LABEL $C858 Vec_Expl_1
COMMENT_LABEL $C858 Four bytes copied from Explosion_Snd's U-reg parameters
LABEL $C859 Vec_Expl_2
LABEL $C85A Vec_Expl_3
LABEL $C85B Vec_Expl_4
LABEL $C85C Vec_Expl_Chan
COMMENT_LABEL $C85C Used by Explosion_Snd - channel number in use?
LABEL $C85D Vec_Expl_ChanB
COMMENT_LABEL $C85D Used by Explosion_Snd - bit for second channel used?
LABEL $C85E Vec_ADSR_Timers
COMMENT_LABEL $C85E ADSR timers for each sound channel (3 bytes)
LABEL $C861 Vec_Music_Freq
COMMENT_LABEL $C861 Storage for base frequency of each channel (3 words)
LABEL $C867 Vec_Expl_Flag
COMMENT_LABEL $C867 Explosion_Snd initialization flag?
LABEL $C877 Vec_Expl_Timer
COMMENT_LABEL $C877 Used by Explosion_Snd
LABEL $C879 Vec_Num_Players
COMMENT_LABEL $C879 Number of players selected in Select_Game
LABEL $C87A Vec_Num_Game
COMMENT_LABEL $C87A Game number selected in Select_Game
LABEL $C87B Vec_Seed_Ptr
COMMENT_LABEL $C87B Pointer to 3-byte random number seed (=$C87D)
LABEL $C87D Vec_Random_Seed
COMMENT_LABEL $C87D Default 3-byte random number seed
LABEL $CBEA Vec_Default_Stk
COMMENT_LABEL $CBEA Default top-of-stack
LABEL $CBEB Vec_High_Score
COMMENT_LABEL $CBEB High score storage (7 bytes)
LABEL $CBF2 Vec_SWI3_Vector
COMMENT_LABEL $CBF2 SWI2/SWI3 interrupt vector (3 bytes)
LABEL $CBF2 Vec_SWI2_Vector
COMMENT_LABEL $CBF2 SWI2/SWI3 interrupt vector (3 bytes)
LABEL $CBF5 Vec_FIRQ_Vector
COMMENT_LABEL $CBF5 FIRQ interrupt vector (3 bytes)
LABEL $CBF8 Vec_IRQ_Vector
COMMENT_LABEL $CBF8 IRQ interrupt vector (3 bytes)
LABEL $CBFB Vec_SWI_Vector
COMMENT_LABEL $CBFB SWI/NMI interrupt vector (3 bytes)
LABEL $CBFB Vec_NMI_Vector
COMMENT_LABEL $CBFB SWI/NMI interrupt vector (3 bytes)
LABEL $CBFE Vec_Cold_Flag
COMMENT_LABEL $CBFE Cold start flag (warm start if = $7321)
LABEL $D000 VIA_port_b
COMMENT_LABEL $D000 VIA port B data I/O register
LABEL $D001 VIA_port_a
COMMENT_LABEL $D001 VIA port A data I/O register (handshaking)
LABEL $D002 VIA_DDR_b
COMMENT_LABEL $D002 VIA port B data direction register (0=input 1=output)
LABEL $D003 VIA_DDR_a
COMMENT_LABEL $D003 VIA port A data direction register (0=input 1=output)
LABEL $D004 VIA_t1_cnt_lo
COMMENT_LABEL $D004 VIA timer 1 count register lo (scale factor)
LABEL $D005 VIA_t1_cnt_hi
COMMENT_LABEL $D005 VIA timer 1 count register hi
LABEL $D006 VIA_t1_lch_lo
COMMENT_LABEL $D006 VIA timer 1 latch register lo
LABEL $D007 VIA_t1_lch_hi
COMMENT_LABEL $D007 VIA timer 1 latch register hi
LABEL $D008 VIA_t2_lo
COMMENT_LABEL $D008 VIA timer 2 count/latch register lo (refresh)
LABEL $D009 VIA_t2_hi
COMMENT_LABEL $D009 VIA timer 2 count/latch register hi
LABEL $D00A VIA_shift_reg
COMMENT_LABEL $D00A VIA shift register
LABEL $D00B VIA_aux_cntl
COMMENT_LABEL $D00B VIA auxiliary control register
LABEL $D00C VIA_cntl
COMMENT_LABEL $D00C VIA control register
LABEL $D00D VIA_int_flags
COMMENT_LABEL $D00D VIA interrupt flags register
LABEL $D00E VIA_int_enable
COMMENT_LABEL $D00E VIA interrupt enable register
LABEL $D00F VIA_port_a_nohs
COMMENT_LABEL $D00F VIA port A data I/O register (no handshaking)
LABEL $F000 Cold_Start
LABEL $F06C Warm_Start
LABEL $F14C Init_VIA
LABEL $F164 Init_OS_RAM
LABEL $F18B Init_OS
LABEL $F192 Wait_Recal
LABEL $F1A2 Set_Refresh
LABEL $F1AA DP_to_D0
LABEL $F1AF DP_to_C8
LABEL $F1B4 Read_Btns_Mask
LABEL $F1BA Read_Btns
LABEL $F1F5 Joy_Analog
LABEL $F1F8 Joy_Digital
LABEL $F256 Sound_Byte
LABEL $F259 Sound_Byte_x
LABEL $F25B Sound_Byte_raw
LABEL $F272 Clear_Sound
LABEL $F27D Sound_Bytes
LABEL $F284 Sound_Bytes_x
LABEL $F289 Do_Sound
LABEL $F28C Do_Sound_x
LABEL $F29D Intensity_1F
LABEL $F2A1 Intensity_3F
LABEL $F2A5 Intensity_5F
LABEL $F2A9 Intensity_7F
LABEL $F2AB Intensity_a
LABEL $F2BE Dot_ix_b
LABEL $F2C1 Dot_ix
LABEL $F2C3 Dot_d
LABEL $F2C5 Dot_here
LABEL $F2D5 Dot_List
LABEL $F2DE Dot_List_Reset
LABEL $F2E6 Recalibrate
LABEL $F2F2 Moveto_x_7F
LABEL $F2FC Moveto_d_7F
LABEL $F308 Moveto_ix_FF
LABEL $F30C Moveto_ix_7F
LABEL $F30E Moveto_ix_a
LABEL $F310 Moveto_ix
LABEL $F312 Moveto_d
LABEL $F34A Reset0Ref_D0
LABEL $F34F Check0Ref
LABEL $F354 Reset0Ref
LABEL $F35B Reset_Pen
LABEL $F36B Reset0Int
LABEL $F373 Print_Str_hwyx
LABEL $F378 Print_Str_yx
LABEL $F37A Print_Str_d
LABEL $F385 Print_List_hw
LABEL $F38A Print_List
LABEL $F38C Print_List_chk
LABEL $F391 Print_Ships_x
LABEL $F393 Print_Ships
LABEL $F3AD Mov_Draw_VLc_a
COMMENT_LABEL $F3AD count y x y x ...
LABEL $F3B1 Mov_Draw_VL_b
COMMENT_LABEL $F3B1 y x y x ...
LABEL $F3B5 Mov_Draw_VLcs
COMMENT_LABEL $F3B5 count scale y x y x ...
LABEL $F3B7 Mov_Draw_VL_ab
COMMENT_LABEL $F3B7 y x y x ...
LABEL $F3B9 Mov_Draw_VL_a
COMMENT_LABEL $F3B9 y x y x ...
LABEL $F3BC Mov_Draw_VL
COMMENT_LABEL $F3BC y x y x ...
LABEL $F3BE Mov_Draw_VL_d
COMMENT_LABEL $F3BE y x y x ...
LABEL $F3CE Draw_VLc
COMMENT_LABEL $F3CE count y x y x ...
LABEL $F3D2 Draw_VL_b
COMMENT_LABEL $F3D2 y x y x ...
LABEL $F3D6 Draw_VLcs
COMMENT_LABEL $F3D6 count scale y x y x ...
LABEL $F3D8 Draw_VL_ab
COMMENT_LABEL $F3D8 y x y x ...
LABEL $F3DA Draw_VL_a
COMMENT_LABEL $F3DA y x y x ...
LABEL $F3DD Draw_VL
COMMENT_LABEL $F3DD y x y x ...
LABEL $F3DF Draw_Line_d
COMMENT_LABEL $F3DF y x y x ...
LABEL $F404 Draw_VLp_FF
COMMENT_LABEL $F404 pattern y x pattern y x ... $01
LABEL $F408 Draw_VLp_7F
COMMENT_LABEL $F408 pattern y x pattern y x ... $01
LABEL $F40C Draw_VLp_scale
COMMENT_LABEL $F40C scale pattern y x pattern y x ... $01
LABEL $F40E Draw_VLp_b
COMMENT_LABEL $F40E pattern y x pattern y x ... $01
LABEL $F410 Draw_VLp
COMMENT_LABEL $F410 pattern y x pattern y x ... $01
LABEL $F434 Draw_Pat_VL_a
COMMENT_LABEL $F434 y x y x ...
LABEL $F437 Draw_Pat_VL
COMMENT_LABEL $F437 y x y x ...
LABEL $F439 Draw_Pat_VL_d
COMMENT_LABEL $F439 y x y x ...
LABEL $F46E Draw_VL_mode
COMMENT_LABEL $F46E mode y x mode y x ... $01
LABEL $F495 Print_Str
LABEL $F511 Random_3
LABEL $F517 Random
LABEL $F533 Init_Music_Buf
LABEL $F53F Clear_x_b
LABEL $F542 Clear_C8_RAM
COMMENT_LABEL $F542 never used by GCE carts?
LABEL $F545 Clear_x_256
LABEL $F548 Clear_x_d
LABEL $F550 Clear_x_b_80
LABEL $F552 Clear_x_b_a
LABEL $F55A Dec_3_Counters
LABEL $F55E Dec_6_Counters
LABEL $F563 Dec_Counters
LABEL $F56D Delay_3
COMMENT_LABEL $F56D 30 cycles
LABEL $F571 Delay_2
COMMENT_LABEL $F571 25 cycles
LABEL $F575 Delay_1
COMMENT_LABEL $F575 20 cycles
LABEL $F579 Delay_0
COMMENT_LABEL $F579 12 cycles
LABEL $F57A Delay_b
COMMENT_LABEL $F57A 5*B + 10 cycles
LABEL $F57D Delay_RTS
COMMENT_LABEL $F57D 5 cycles
LABEL $F57E Bitmask_a
LABEL $F584 Abs_a_b
LABEL $F58B Abs_b
LABEL $F593 Rise_Run_Angle
LABEL $F5D9 Get_Rise_Idx
LABEL $F5DB Get_Run_Idx
LABEL $F5EF Get_Rise_Run
LABEL $F5FF Rise_Run_X
LABEL $F601 Rise_Run_Y
LABEL $F603 Rise_Run_Len
LABEL $F610 Rot_VL_ab
LABEL $F616 Rot_VL
LABEL $F61F Rot_VL_Mode_a
LABEL $F62B Rot_VL_Mode
LABEL $F637 Rot_VL_dft
LABEL $F65B Xform_Run_a
LABEL $F65D Xform_Run
LABEL $F661 Xform_Rise_a
LABEL $F663 Xform_Rise
LABEL $F67F Move_Mem_a_1
LABEL $F683 Move_Mem_a
LABEL $F687 Init_Music_chk
LABEL $F68D Init_Music
LABEL $F692 Init_Music_x
LABEL $F7A9 Select_Game
LABEL $F84F Clear_Score
LABEL $F85E Add_Score_a
LABEL $F87C Add_Score_d
LABEL $F8B7 Strip_Zeros
LABEL $F8C7 Compare_Score
LABEL $F8D8 New_High_Score
LABEL $F8E5 Obj_Will_Hit_u
LABEL $F8F3 Obj_Will_Hit
LABEL $F8FF Obj_Hit
LABEL $F92E Explosion_Snd
LABEL $FF9F Draw_Grid_VL
LABEL $FD0D music1
LABEL $FD1D music2
LABEL $FD81 music3
LABEL $FDD3 music4
LABEL $FE38 music5
LABEL $FE76 music6
LABEL $FEC6 music7
LABEL $FEF8 music8
LABEL $FF26 music9
LABEL $FF44 musica
LABEL $FF62 musicb
LABEL $FF7A musicc
LABEL $FF8F musicd
EQU $01 BEAM_I
EQU -$01 NO_MONSTER
COMMENT_LABEL -$01 default value for no monster displayed
EQU $32 FAR_AWAY
COMMENT_LABEL $32 a 'max' value for distance of monsters
LABEL $0100 MAZE_SIZE_ALL
COMMENT_LABEL $0100 now, since 16 times 16, but will be bits 2*16
EQU $02 MAX_MONSTER
COMMENT_LABEL $02 number of monters active per maze
EQU $00 ANIMATION
EQU $01 MORPHING
COMMENT_LABEL $01 not done yet
EQU $00 NOT_MOVING
EQU $01 PATROLING_X
EQU $02 PATROLING_Y
COMMENT_LABEL $02 following not done yet
EQU $03 PATROLING_LEFT
EQU $04 PATROLING_RIGHT
EQU $05 INTELLIGENT_SEEKING
EQU $06 INTELLIGENT_FLEEING
EQU $0C C_MONSTER_SIZE
COMMENT_LABEL $0C size of monster struct in bytes
EQU $00 C_MONSTER_X
EQU $01 C_MONSTER_Y
EQU $00 C_MONSTER_POSITION
EQU $02 C_MONSTER_OFFSET
EQU $02 C_MONSTER_X_OFFSET
EQU $03 C_MONSTER_Y_OFFSET
EQU $04 C_MONSTER_MOVEMENT_TYPE
EQU $05 C_MONSTER_DEFINITION
EQU $07 C_MONSTER_ANIM_COUNTER
EQU $08 C_MONSTER_GRAPHIC
EQU $0A C_MONSTER_GRAPHIC_COUNTER
EQU $0B C_MONSTER_HEADING
EQU $00 M_MONSTER_POSITION
EQU $02 M_MONSTER_OFFSET
EQU $04 M_MONSTER_MOVEMENT_TYPE
EQU $05 M_MONSTER_MOVEMENT_SPEED
EQU $06 M_MONSTER_FROM_X
EQU $07 M_MONSTER_FROM_Y
EQU $08 M_MONSTER_TO_X
EQU $09 M_MONSTER_TO_Y
EQU $0A M_MONSTER_STRUCT
EQU $00 ANIMATION_DELAY
EQU $01 ANIMATION_TYPE
EQU $02 ANIMATION_GRAPHIC_START
EQU $00 MONSTER_TYPE
EQU $01 MONSTER_ANIM_STRUCT
EQU $01 DIVIDE_I
EQU $01 M6809_I
EQU $01 CARRY
LABEL $00FE NOT_CARRY
EQU $01 UTIL_I
LABEL $C880 v0
LABEL $C880 y0
LABEL $C881 x0
LABEL $C882 v1
LABEL $C882 y1
LABEL $C883 x1
LABEL $C884 v2
LABEL $C884 y2
LABEL $C885 x2
LABEL $C886 neggi
LABEL $C887 clip_test
LABEL $C889 clip_line_counter
LABEL $C88A clip_counter
LABEL $C88C clip_pattern
LABEL $C88E clipped_vector_list
EQU $06 DIGIT_VLP_RELOAD
COMMENT_LABEL $06 due to try and error
EQU $00 INFO_START
EQU $00 BYTE_POSITION
EQU $02 BIT_POSITION
EQU $03 CURRENT_BYTE
EQU $04 CURRENT_UNPACKED_BYTE
EQU $05 CURRENT_RLE_COUNTER
EQU $07 CURRENT_RLE_MAPPER
EQU $09 CURRENT_IS_PHRASE
EQU $0B CURRENT_PHRASE_BYTE
EQU $0C CURRENT_PHRASE_START
EQU $0E INFO_END
EQU $0E STRUCTURE_LENGTH
EQU $04 MAZE_X_RAM
LABEL $C906 current_register
LABEL $C907 temp
LABEL $C908 temp2
LABEL $C909 temp3
LABEL $C90A calc_coder
LABEL $C90B calc_bits
LABEL $C90C ym_data_len
LABEL $C90E ym_data_current
LABEL $C910 ym_name
LABEL $C912 ym_data_start
EQU $03 T2_TIMER_PEROID_REAL
COMMENT_LABEL $03 again a multiple of 256, nice for only hi byte testing! 740 ; 2K samples about that many cycles between update of samples
EQU $03 T2_TIMER_PEROID_LO
EQU $00 T2_TIMER_PEROID_HI
LABEL $0300 T2_TIMER_PEROID
LABEL $C9AC via_b_start
LABEL $C9AD digit_is_playing
LABEL $C9AE digit_next_digit_cycle
LABEL $C9B0 digit_structure_pos
LABEL $C9B2 digit_structure_pos_current
LABEL $C9B4 digit_end_pos
LABEL $C9B6 digit_start_pos
LABEL $C9B8 digit_timer_saver
EQU $09 SPEED
COMMENT_LABEL $09 speed of 'walker'
EQU $20 LIGHT
COMMENT_LABEL $20 7f - light + current_z_pos ï¿½er round - LIGHT
LABEL $0080 LAB_SCALE
COMMENT_LABEL $0080 size of maze
EQU $00 SOUTH
EQU $02 WEST
EQU $04 NORTH
EQU $06 EAST
EQU $04 UP
EQU $05 DOWN
EQU $10 MAZE_SIZE
EQU $10 MAZE_X
EQU $10 MAZE_Y
EQU $30 WALL_SIZE
COMMENT_LABEL $30 some maximum, depending one other values!
EQU $60 SQUARE_SIZE
EQU $40 LAB_REDUCT_1
EQU $60 STEPS
LABEL $00C0 DOUBLE_STEP
LABEL $C000 DOUBLE_STEP_INVERSE
LABEL $C9BA scale_step
LABEL $C9BB maze_intensity
LABEL $C9BC view_pos_y
LABEL $C9BD helper_first
LABEL $C9BE tmp0
LABEL $C9C0 scale_shadow
LABEL $C9C1 maze_ram
LABEL $CA01 maze_draw_y
LABEL $CA02 last_x_pressed
LABEL $C880 _x
LABEL $C881 _y
LABEL $C882 _xo
LABEL $C883 _yo
LABEL $C885 mx
LABEL $C884 my
LABEL $CA03 map_offset
LABEL $CA04 map_worker
LABEL $CA06 map_address
LABEL $CA08 map_helper
LABEL $CA0A map_bits
LABEL $CA2A look_direction
LABEL $CA2B move_offset_y_big
LABEL $CA2B move_offset_y_hi
LABEL $CA2C move_offset_y
LABEL $CA2D pos
LABEL $CA2D pos_y
LABEL $CA2E pos_x
LABEL $CA2F pos_offset
LABEL $CA2F pos_offset_y
LABEL $CA30 pos_offset_x
LABEL $CA31 current_maze
LABEL $CA33 current_monster_list
LABEL $CA4B view_monster
LABEL $CA4B V_MONSTER_X
LABEL $CA4C V_MONSTER_Y
LABEL $CA4B V_MONSTER_POSITION
LABEL $CA4D V_MONSTER_OFFSET
LABEL $CA4D V_MONSTER_OFFSET_X
LABEL $CA4E V_MONSTER_OFFSET_Y
LABEL $CA50 V_MONSTER_POINTER
LABEL $CA52 V_MONSTER_NEARNESS
LABEL $CA53 V_MONSTER_MOVEMENT_AXIS
LABEL $CA54 V_MONSTER_MOVEMENT_AXIS_TEMP
LABEL $CA55 view_item
EQU $11 game_name
EQU $2B entry_point
LABEL $002E new_game
LABEL $0558 init_vars
LABEL $057F init_screen
LABEL $2189 SONG_DATA
LABEL $0BAE init_ym_sound
LABEL $17A5 maze1
LABEL $0580 init_level
LABEL $0040 main_loop_1
EQU $46 digit_is_not_playing
LABEL $1677 handle_input
LABEL $0078 digi_is_playing
LABEL $0292 draw_map
LABEL $050F translate_position
LABEL $047B update_map
LABEL $00A7 update_monsters
LABEL $0E28 draw_maze
LABEL $0A77 do_ym_sound
EQU $6A main_loop_2
LABEL $0C17 wait_recal_digit
LABEL $1703 handle_input_digit
LABEL $112A draw_maze_digit
LABEL $008F my_move_to_d
LABEL $00A2 LF33D1
LABEL $00B5 next_monster
LABEL $025F monster_update_all_done
LABEL $0119 not_moving_monster
LABEL $0117 not_x_patroling
LABEL $00CE in_x_axis
LABEL $00D5 not_in_x_axis
LABEL $00D8 x_axis_done
LABEL $00FC xpatrol_positive
LABEL $00F8 no_negative_overflow
LABEL $00F6 no_negative_position_overflow
COMMENT_LABEL $00F6 save new x position to monster position
LABEL $00FA negative_turning
LABEL $0119 moving_done
LABEL $0113 no_positive_overflow
LABEL $0111 no_positive_position_overflow
COMMENT_LABEL $0111 save new x position to monster position
LABEL $0115 positive_turning
LABEL $0173 test_east1
LABEL $025A this_monster_done
LABEL $01C8 test_south1
LABEL $0213 test_north1
LABEL $0291 update_all_done
LABEL $0291 no_animation
LABEL $0291 no_animation_change
LABEL $028D not_last
LABEL $0291 animation_done
LABEL $02B0 y_should_be_zero
LABEL $02B3 y_calc_done
LABEL $02C7 x_should_be_zero
LABEL $02CA x_calc_done
LABEL $02CA map_main_loop
LABEL $02F1 y_done
LABEL $02E9 negative_change
LABEL $030C x_done
LABEL $0304 negative_change_x
LABEL $0345 no_adjust
LABEL $0336 adjust_further
LABEL $0363 LF33D3
LABEL $037F draw_next_line
LABEL $0388 draw_next_tile
LABEL $039E map_unkown
LABEL $039E tile0
LABEL $03A8 tile1
LABEL $18D1 tile0v
LABEL $03D7 draw_tile
LABEL $03D4 no_player
LABEL $03BD test_dir_north
LABEL $18E5 player_south_tile
LABEL $03C6 test_dir_east
LABEL $18F8 player_north_tile
LABEL $03CF test_dir_west
LABEL $190E player_east_tile
LABEL $1921 player_west_tile
LABEL $18E1 tile11v
LABEL $03D7 dvlp16
LABEL $03F8 dvlpEnd6
LABEL $03F0 dvlp26
LABEL $03FB dvlp36
LABEL $0401 end_DRAW_VLP6
LABEL $046F maze_done
LABEL $0440 LF33D8
LABEL $046C no_adjust_2
LABEL $045D adjust_further_2
LABEL $048D sub_u
LABEL $0499 shift_done
LABEL $0497 no_carry10
LABEL $04B4 display_turn
LABEL $04B4 display_turn_left
LABEL $04B5 display_turn_right
LABEL $04B6 init_turn
LABEL $04B6 init_turn_left
LABEL $04CA init_turn_finished_left
LABEL $04CA play_samples_for_turn
LABEL $04D6 test_next1
LABEL $14C7 init_looking_west
LABEL $3557 west_sample_struct
LABEL $04F4 play_it
LABEL $04E2 test_next2
LABEL $1534 init_looking_east
LABEL $354C east_sample_struct
LABEL $04EE test_next3
LABEL $1567 init_looking_south
LABEL $3536 south_sample_struct
LABEL $14FF init_looking_north
LABEL $3541 north_sample_struct
LABEL $0BDF init_digit_sound
LABEL $04F8 init_turn_right
LABEL $050D init_turn_finished_right
LABEL $053E translate_south
LABEL $054B translate_east
LABEL $052E translate_north
LABEL $051E translate_west
LABEL $056E clear_loop
LABEL $057F exit_init_screen
COMMENT_LABEL $057F otherwise proceed
LABEL $0100 MAZE_PLAYER_START
LABEL $0102 MAZE_PLAYER_DIRECTION
LABEL $059D check_north
LABEL $05B2 direct_check_end
LABEL $05A6 check_east
LABEL $05AF check_west
LABEL $0103 MAZE_MONSTER_START
LABEL $05BC next_monster_init
LABEL $05E6 all_monsters_inserted
LABEL $000C MAZE_MONSTER_LEN
LABEL $05ED clip_vlp_p2_left
LABEL $0607 was_not_visible_vlp
LABEL $05FE do_next_vector_vlp
LABEL $063D was_visible_vlp
LABEL $061F str_pat_and_scale_vlp
LABEL $0637 str_pat_and_scale_vlp_nv
LABEL $062B end_of_computing_vlp
LABEL $065F make_two_pieces_invisible_vlp
LABEL $0623 str_pat_and_scale_vlp_nt
LABEL $065D make_two_pieces_visible_vlp
LABEL $0672 is_pl114
LABEL $06AC div_d_3214
LABEL $069B div_d_1614
LABEL $067A div_d_6414
LABEL $0681 is_pl214
LABEL $0688 is_pl314
LABEL $0692 no_neggi114
LABEL $06D1 end_macro14
LABEL $06A2 is_pl414
LABEL $06A9 is_pl514
LABEL $06BD enter_div3214
LABEL $06B3 is_pl614
LABEL $06BA is_pl714
LABEL $06CA no_neggi14
LABEL $06E5 clip_vlp_p2_left_digit
LABEL $0703 was_not_visible_vlpd
LABEL $06FA do_next_vector_vlpd
LABEL $075C was_visible_vlpd
LABEL $0724 no_digit_1
LABEL $073C str_pat_and_scale_vlpd
LABEL $0756 str_pat_and_scale_vlpd_nv
LABEL $074A end_of_computing_vlpd
LABEL $07A1 make_two_pieces_invisible_vlpd
LABEL $0740 str_pat_and_scale_vlpd_nt
LABEL $077D no_digit_2
LABEL $079F make_two_pieces_visible_vlpd
LABEL $07B4 is_pl126
LABEL $07EE div_d_3226
LABEL $07DD div_d_1626
LABEL $07BC div_d_6426
LABEL $07C3 is_pl226
LABEL $07CA is_pl326
LABEL $07D4 no_neggi126
LABEL $0813 end_macro26
LABEL $07E4 is_pl426
LABEL $07EB is_pl526
LABEL $07FF enter_div3226
LABEL $07F5 is_pl626
LABEL $07FC is_pl726
LABEL $080C no_neggi26
LABEL $082D clip_vlp_p2_right
LABEL $0847 was_not_visible_vlpr
LABEL $083E do_next_vector_vlpr
LABEL $0882 was_visible_vlpr
LABEL $085F str_pat_and_scale_vlpr
LABEL $087C str_pat_and_scale_vlpr_nv
LABEL $086B end_of_computing_vlpr
LABEL $08A4 make_two_pieces_invisible_vlpr
LABEL $0863 str_pat_and_scale_vlpr_nt
LABEL $0877 str_pat_and_scale_vlpr_nt_ft
LABEL $08A2 make_two_pieces_visible_vlpr
LABEL $08B7 is_pl134
LABEL $08F1 div_d_3234
LABEL $08E0 div_d_1634
LABEL $08BF div_d_6434
LABEL $08C6 is_pl234
LABEL $08CD is_pl334
LABEL $08D7 no_neggi134
LABEL $0916 end_macro34
LABEL $08E7 is_pl434
LABEL $08EE is_pl534
LABEL $0902 enter_div3234
LABEL $08F8 is_pl634
LABEL $08FF is_pl734
LABEL $090F no_neggi34
LABEL $092A clip_vlp_p2_right_digit
LABEL $0948 was_not_visible_vlprd
LABEL $093F do_next_vector_vlprd
LABEL $09A6 was_visible_vlprd
LABEL $0969 no_digit_1r
LABEL $0981 str_pat_and_scale_vlprd
LABEL $09A0 str_pat_and_scale_vlprd_nv
LABEL $098F end_of_computing_vlprd
LABEL $09EB make_two_pieces_invisible_vlprd
LABEL $0985 str_pat_and_scale_vlprd_nt
LABEL $099B str_pat_and_scale_vlprd_nt_ft
LABEL $09C7 no_digit_2r
LABEL $09E9 make_two_pieces_visible_vlprd
LABEL $09FE is_pl146
LABEL $0A38 div_d_3246
LABEL $0A27 div_d_1646
LABEL $0A06 div_d_6446
LABEL $0A0D is_pl246
LABEL $0A14 is_pl346
LABEL $0A1E no_neggi146
LABEL $0A5D end_macro46
LABEL $0A2E is_pl446
LABEL $0A35 is_pl546
LABEL $0A49 enter_div3246
LABEL $0A3F is_pl646
LABEL $0A46 is_pl746
LABEL $0A56 no_neggi46
LABEL $0A9E do_ym_sound_done
LABEL $0A89 next_reg
LABEL $0B14 get_current_byte
LABEL $0A9F no_valid_byte
LABEL $0AAF byte_ready_1
LABEL $0B36 no_single_byte
LABEL $0AB7 single_byte
LABEL $0AB9 dechifer
LABEL $0ABF try_next_bit
LABEL $0AD5 byte_ready
LABEL $0ADE no_add
LABEL $0AE0 search_again
LABEL $0B0E no_phrase_d
LABEL $0B08 phrase_found
LABEL $0B01 next_phrase
LABEL $0B14 out
LABEL $0B2E no_phrase
LABEL $0B33 counter_not_minus_one
LABEL $0B3B more_bits
LABEL $0B4E byte_ready_2
LABEL $0B5B go_on
LABEL $0B6B byte_ready_3
LABEL $0B73 end_here_3
LABEL $0B75 go_on_2
LABEL $0B85 byte_ready_4
LABEL $0B8D end_here_4
LABEL $0B8E shifting_not_yet_done
LABEL $0B94 no_carry
LABEL $0B99 shifting_done
LABEL $0BC4 next_reg_init
LABEL $0C09 clear_next_register52
LABEL $0C60 LF19E54
LABEL $0C19 play_one_digit54
LABEL $0C60 makro_rts55
LABEL $0C55 sound_not_done55
LABEL $0C2B sound_done55
LABEL $0C40 reinit_sample55
LABEL $0C6F out_of_loop54
LABEL $0CC5 move_to_d_digit
LABEL $0CAB wait_for_next_digit59
LABEL $0CB2 jump59
LABEL $0CC7 wait_for_next_digit63
LABEL $0CCE jump63
LABEL $0CF5 wait_for_t161
LABEL $0CFA Draw_VLc_digit
LABEL $0D00 dvlc165
LABEL $0D45 dvlcEnd65
LABEL $0D28 will_output_digit65
LABEL $0D20 dvlc265
LABEL $0D30 dvlc465
LABEL $0D48 dvlc365
LABEL $0D4F intensity_a_digit
LABEL $0D5D Draw_VLp_digit
LABEL $0D5D dvlp168
LABEL $0DA2 dvlpEnd68
LABEL $0D85 will_output_digit68
LABEL $0D7D dvlp268
LABEL $0D8D dvlp468
LABEL $0DA5 dvlp368
LABEL $0DAB end_DRAW_VLP68
LABEL $0DAC next_digit
LABEL $0DFA makro_rts70
LABEL $0DB1 wait_for_next_digit71
LABEL $0DB8 jump71
LABEL $0DEF sound_not_done70
LABEL $0DC5 sound_done70
LABEL $0DDA reinit_sample70
LABEL $0DFB Read_Btns_digit
LABEL $0E79 is_divider_173
LABEL $0E41 procede173
LABEL $0E7E is_divider_273
LABEL $0E4A procede273
LABEL $0E83 is_divider_373
LABEL $0E53 procede373
LABEL $0E88 is_divider_473
LABEL $0E5C procede473
LABEL $0E8D is_divider_573
LABEL $0E65 procede573
LABEL $0E92 is_divider_673
LABEL $0E6E procede673
LABEL $0E97 is_divider_773
LABEL $0E9A macro_end73
LABEL $0EA7 no_correcting
LABEL $0EC1 next_maze
LABEL $1596 vpos_1
LABEL $0EE8 in_first
LABEL $0F15 square_full
LABEL $0F03 square_quarter_left
LABEL $0F10 square_quarter_right
LABEL $15B8 square_half_vlist
LABEL $0F18 draw_square
LABEL $1598 square_quarter_left_vlist
LABEL $0F21 draw_no_square
LABEL $15A5 square_quarter_right_vlist
LABEL $15D1 square_full_vlist
LABEL $0F1A wait_for_move_finish
LABEL $0F3B left_wall
LABEL $0F5A no_left
LABEL $0F2D no_no_left
LABEL $161E no_left_wall_vlist
LABEL $162E no_left_return
LABEL $0F4E draw_usual_left
LABEL $1604 left_wall_vlist_first
LABEL $1614 left_return_first
LABEL $15EA left_wall_vlist
LABEL $15FA left_return
LABEL $0F6E right_wall
LABEL $0F81 no_right
LABEL $1661 no_right_wall_vlist
LABEL $0F7B draw_usual_right
LABEL $164B right_wall_vlist_first
LABEL $1635 right_wall_vlist
LABEL $1129 draw_finished
LABEL $1113 no_monster_in_front
LABEL $0FCA negative_steps
LABEL $0FD6 step_fiddling_done
LABEL $0FB8 overflow_minus
LABEL $1055 halving_done
LABEL $1021 is_divider_178
LABEL $0FE9 procede178
LABEL $1026 is_divider_278
LABEL $0FF2 procede278
LABEL $102B is_divider_378
LABEL $0FFB procede378
LABEL $1030 is_divider_478
LABEL $1004 procede478
LABEL $1035 is_divider_578
LABEL $100D procede578
LABEL $103A is_divider_678
LABEL $1016 procede678
LABEL $103F is_divider_778
LABEL $1042 macro_end78
LABEL $1051 halving_again
LABEL $10EA center_display
LABEL $10A6 right_display
LABEL $1062 left_display
LABEL $108C not_in_axis_left
LABEL $1099 move_monster_left
LABEL $1113 finish_current_maze
LABEL $10D0 not_in_axis_right
LABEL $10DD move_monster_right
LABEL $1102 no_lower_clip
LABEL $112D wait_for_next_digit82
LABEL $1134 jump82
LABEL $1194 is_divider_184
LABEL $115C procede184
LABEL $1199 is_divider_284
LABEL $1165 procede284
LABEL $119E is_divider_384
LABEL $116E procede384
LABEL $11A3 is_divider_484
LABEL $1177 procede484
LABEL $11A8 is_divider_584
LABEL $1180 procede584
LABEL $11AD is_divider_684
LABEL $1189 procede684
LABEL $11B2 is_divider_784
LABEL $11B5 macro_end84
LABEL $11C2 no_correcting_digit
LABEL $11C2 wait_for_next_digit87
LABEL $11C9 jump87
LABEL $11F5 next_maze_digit
LABEL $1249 square_full_digit
LABEL $1237 square_quarter_left_digit
LABEL $1244 square_quarter_right_digit
LABEL $124C draw_square_digit
LABEL $1255 draw_no_square_digit
LABEL $124E wait_for_move_finish_digit
LABEL $126F left_wall_digit
LABEL $128E no_left_digit
LABEL $1261 no_no_left_digit
LABEL $1282 draw_usual_left_digit
LABEL $12A2 right_wall_digit
LABEL $12B5 no_right_digit
LABEL $12AF draw_usual_right_digit
LABEL $14C6 draw_finished_digit
LABEL $14B0 no_monster_in_front_digit
LABEL $12FE negative_steps_digit
LABEL $130A step_fiddling_done_digit
LABEL $12EC overflow_minus_digit
LABEL $13A6 halving_done_digit
LABEL $130F wait_for_next_digit93
LABEL $1316 jump93
LABEL $1372 is_divider_195
LABEL $133A procede195
LABEL $1377 is_divider_295
LABEL $1343 procede295
LABEL $137C is_divider_395
LABEL $134C procede395
LABEL $1381 is_divider_495
LABEL $1355 procede495
LABEL $1386 is_divider_595
LABEL $135E procede595
LABEL $138B is_divider_695
LABEL $1367 procede695
LABEL $1390 is_divider_795
LABEL $1393 macro_end95
LABEL $13A2 halving_again_digit
LABEL $146E center_display_digit
LABEL $1411 right_display_digit
LABEL $13B3 left_display_digit
LABEL $13BA wait_for_next_digit98
LABEL $13C1 jump98
LABEL $13F6 not_in_axis_left_digit
LABEL $1403 move_monster_left_digit
LABEL $14B0 finish_current_maze_digit
LABEL $1418 wait_for_next_digit101
LABEL $141F jump101
LABEL $1454 not_in_axis_right_digit
LABEL $1461 move_monster_right_digit
LABEL $1473 wait_for_next_digit104
LABEL $147A jump104
LABEL $149F no_lower_clip_digit
LABEL $14E9 copy_maze_west
LABEL $1520 copy_maze_north
LABEL $1551 copy_maze_east
LABEL $1581 copy_maze_south
LABEL $1596 vpos_y_1
LABEL $1597 vpos_x_1
EQU -$0F MIDDLE_CORRECT
LABEL $16E2 joystick_done_y
LABEL $16B5 moved_down
LABEL $1686 moved_up
LABEL $16B3 up_done
LABEL $16AE up_not_allowed
LABEL $16DD down_not_allowed
LABEL $16FF joystick_done_really
LABEL $16F8 turn_right
LABEL $16F1 turn_left
LABEL $1706 wait_for_next_digit108
LABEL $170D jump108
LABEL $1784 joystick_done_y_digit
LABEL $1757 moved_down_digit
LABEL $1728 moved_up_digit
LABEL $1755 up_done_digit
LABEL $1750 up_not_allowed_digit
LABEL $177F down_not_allowed_digit
LABEL $17A1 joystick_done_really_digit
LABEL $179A turn_right_digit
LABEL $1793 turn_left_digit
LABEL $18A5 player_start1
LABEL $18A7 player_direction1
LABEL $18A8 monster1
LABEL $18C2 goblin_monster
LABEL $18B4 monster2
LABEL $18C0 monster3
LABEL $18C5 goblin_animation
LABEL $3562 Figure0
LABEL $35B4 Figure1
LABEL $360C Figure2
EQU $7E TILE_SIZE
LABEL $1937 YM_007_start
LABEL $1939 YM_007_reg_0
LABEL $1960 YM_007_pd_0
LABEL $1960 YM_007_reg_0_data
LABEL $19A0 YM_007_reg_1
LABEL $19AF YM_007_pd_1
LABEL $19AF YM_007_reg_1_data
LABEL $19CF YM_007_reg_2
LABEL $1A17 YM_007_pd_2
LABEL $1A17 YM_007_reg_2_data
LABEL $1C0C YM_007_reg_3
LABEL $1C21 YM_007_pd_3
LABEL $1C21 YM_007_reg_3_data
LABEL $1D69 YM_007_reg_4
LABEL $1D8D YM_007_pd_4
LABEL $1D8D YM_007_reg_4_data
LABEL $1DD8 YM_007_reg_5
LABEL $1DED YM_007_pd_5
LABEL $1DED YM_007_reg_5_data
LABEL $1E26 YM_007_reg_6
LABEL $1E29 YM_007_pd_6
LABEL $1E29 YM_007_reg_6_data
LABEL $1E2D YM_007_reg_7
LABEL $1E3C YM_007_pd_7
LABEL $1E3C YM_007_reg_7_data
LABEL $1E54 YM_007_reg_8
LABEL $1E8A YM_007_pd_8
LABEL $1E9C YM_007_reg_8_data
LABEL $1F7D YM_007_reg_9
LABEL $1FB0 YM_007_pd_9
LABEL $1FC0 YM_007_reg_9_data
LABEL $20A1 YM_007_reg_10
LABEL $20D4 YM_007_pd_10
LABEL $20E1 YM_007_reg_10_data
LABEL $2189 YM_007_data
LABEL $21CD YM_007_name
LABEL $21E5 sample_buffer
LABEL $2211 turning_sample_start
LABEL $2546 turning_sample_end
LABEL $0335 turning_sample_length
LABEL $2546 west_sample_start
LABEL $29FB west_sample_end
LABEL $04B5 west_sample_length
LABEL $29FB east_sample_start
LABEL $2D8B east_sample_end
LABEL $0390 east_sample_length
LABEL $2D8B north_sample_start
LABEL $31BD north_sample_end
LABEL $0432 north_sample_length
LABEL $31BD south_sample_start
LABEL $3536 south_sample_end
LABEL $0379 south_sample_length
EQU $10 GOBLINE_SIZE
LABEL $3662 *
EQU $2B *xfer
COMMENT_LINE $0000 magic - slow, fast, dizzy
COMMENT_LINE $0000 magic map,
COMMENT_LINE $0000 light, darkness
COMMENT_LINE $0000 traps -> forget map
COMMENT_LINE $0000 ceiling colapses
COMMENT_LINE $0000 traps to next level
COMMENT_LINE $0000 stalagtides, stalagnites
COMMENT_LINE $0000 treasure
COMMENT_LINE $0000 throwable (3d) items
COMMENT_LINE $0000 temple
COMMENT_LINE $0000 teleport
COMMENT_LINE $0000 secret doors
COMMENT_LINE $0000 level teleport
COMMENT_LINE $0000 monster information screen
COMMENT_LINE $0000 strategic, or action battle
COMMENT_LINE $0000 monster not passable
COMMENT_LINE $0000 monster passable
COMMENT_LINE $0000 ghost monster (go thru wall)
COMMENT_LINE $0000 levitate, go thru wall...
COMMENT_LINE $0000 labyrinth that is open to all sides (wrapping)
COMMENT_LINE $0000 torches, candles, lamp
COMMENT $0000 vectrex function includes
COMMENT_LINE $0000 this file is part of vectrex frogger, written by Malban
COMMENT_LINE $0000 in March-April 1998
COMMENT_LINE $0000 all stuff contained here is public domain (?)
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 this file contains includes for vectrex BIOS functions and variables      ;
COMMENT_LINE $0000 it was written by Bruce Tomlin, slightly changed by Malban                ;
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 $C839   ;Pointer to copyright string during startup
COMMENT_LINE $0000 $C83B   ;High score cold-start flag (=0 if valid)
COMMENT_LINE $0000 $C83C   ;temp byte
COMMENT_LINE $0000 $C843   ;        register 9
COMMENT_LINE $0000 $C844   ;        register 8
COMMENT_LINE $0000 $C848   ;        register 4
COMMENT_LINE $0000 $C849   ;        register 3
COMMENT_LINE $0000 $C84A   ;        register 2
COMMENT_LINE $0000 $C84C   ;        register 0
COMMENT_LINE $0000 $C85E   ;Scratch 'score' storage for Display_Option (7 bytes)
COMMENT_LINE $0000 $C868...$C876   ;Unused?
COMMENT_LINE $0000 $C878   ;Unused?
COMMENT_LINE $0000 $C880 - $CBEA is user RAM  ;
COMMENT_LINE $0000 0 sample/hold (0=enable  mux 1=disable mux)
COMMENT_LINE $0000 1 mux sel 0
COMMENT_LINE $0000 2 mux sel 1
COMMENT_LINE $0000 3 sound BC1
COMMENT_LINE $0000 4 sound BDIR
COMMENT_LINE $0000 5 comparator input
COMMENT_LINE $0000 6 external device (slot pin 35) initialized to input
COMMENT_LINE $0000 7 /RAMP
COMMENT_LINE $0000 0 PA latch enable
COMMENT_LINE $0000 1 PB latch enable
COMMENT_LINE $0000 2 \                     110=output to CB2 under control of phase 2 clock
COMMENT_LINE $0000 3  > shift register control     (110 is the only mode used by the Vectrex ROM)
COMMENT_LINE $0000 4 /
COMMENT_LINE $0000 5 0=t2 one shot                 1=t2 free running
COMMENT_LINE $0000 6 0=t1 one shot                 1=t1 free running
COMMENT_LINE $0000 7 0=t1 disable PB7 output       1=t1 enable PB7 output
COMMENT_LINE $0000 0 CA1 control     CA1 -> SW7    0=IRQ on low 1=IRQ on high
COMMENT_LINE $0000 1 \
COMMENT_LINE $0000 2  > CA2 control  CA2 -> /ZERO  110=low 111=high
COMMENT_LINE $0000 3 /
COMMENT_LINE $0000 4 CB1 control     CB1 -> NC     0=IRQ on low 1=IRQ on high
COMMENT_LINE $0000 5 \
COMMENT_LINE $0000 6  > CB2 control  CB2 -> /BLANK 110=low 111=high
COMMENT_LINE $0000 7 /
COMMENT_LINE $0000 bit                             cleared by
COMMENT_LINE $0000 0 CA2 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 1 CA1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 2 shift register interrupt flag reading or writing shift register
COMMENT_LINE $0000 3 CB2 interrupt flag            reading or writing port B I/O
COMMENT_LINE $0000 4 CB1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 5 timer 2 interrupt flag        read t2 low or write t2 high
COMMENT_LINE $0000 6 timer 1 interrupt flag        read t1 count low or write t1 high
COMMENT_LINE $0000 7 IRQ status flag               write logic 0 to IER or IFR bit
COMMENT_LINE $0000 0 CA2 interrupt enable
COMMENT_LINE $0000 1 CA1 interrupt enable
COMMENT_LINE $0000 2 shift register interrupt enable
COMMENT_LINE $0000 3 CB2 interrupt enable
COMMENT_LINE $0000 4 CB1 interrupt enable
COMMENT_LINE $0000 5 timer 2 interrupt enable
COMMENT_LINE $0000 6 timer 1 interrupt enable
COMMENT_LINE $0000 7 IER set/clear control
COMMENT $0000 vectrex function includes
COMMENT_LINE $0000 all stuff contained here is public domain (?)
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 this file contains makro definitions of vectrex BIOS functions, these are ;
COMMENT_LINE $0000 exact clones of the BIOS functions                                        ;
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 this file is part of vectrex frogger, written by Malban
COMMENT_LINE $0000 in March-April 1998
COMMENT_LINE $0000 all stuff contained here is public domain (?)
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 this file contains includes for vectrex BIOS functions and variables      ;
COMMENT_LINE $0000 it was written by Bruce Tomlin, slightly changed by Malban                ;
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $0000 Shadow of sound chip registers (15 bytes)
COMMENT $0000 Current state of all joystick buttons
COMMENT $0000 Previous state of all joystick buttons
COMMENT $0000 Current toggle state of all buttons
COMMENT $0000 Current toggle state of stick 1 button 1
COMMENT $0000 Current toggle state of stick 1 button 2
COMMENT $0000 Current toggle state of stick 1 button 3
COMMENT $0000 Current toggle state of stick 1 button 4
COMMENT $0000 Current toggle state of stick 2 button 1
COMMENT $0000 Current toggle state of stick 2 button 2
COMMENT $0000 Current toggle state of stick 2 button 3
COMMENT $0000 Current toggle state of stick 2 button 4
COMMENT $0000 Joystick A/D resolution ($80=min $00=max)
COMMENT $0000 Joystick 1 left/right
COMMENT $0000 Joystick 1 up/down
COMMENT $0000 Joystick 2 left/right
COMMENT $0000 Joystick 2 up/down
COMMENT $0000 Joystick enable/mux flags (4 bytes)
COMMENT $0000 Joystick 1 X enable/mux flag (=1)
COMMENT $0000 Joystick 1 Y enable/mux flag (=3)
COMMENT $0000 Joystick 2 X enable/mux flag (=5)
COMMENT $0000 Joystick 2 Y enable/mux flag (=7)
COMMENT $0000 Misc counter/flag byte, zero when not in use
COMMENT $0000 Check0Ref enable flag
COMMENT $0000 Loop counter word (incremented in Wait_Recal)
COMMENT $0000 Default brightness
COMMENT $0000 Dot dwell time?
COMMENT $0000 Dot pattern (bits)
COMMENT $0000 Default text height and width
COMMENT $0000 Default text height
COMMENT $0000 Default text width
COMMENT $0000 Temporary string pointer for Print_Str
COMMENT $0000 Six bytes of counters
COMMENT $0000 First  counter byte
COMMENT $0000 Second counter byte
COMMENT $0000 Third  counter byte
COMMENT $0000 Fourth counter byte
COMMENT $0000 Fifth  counter byte
COMMENT $0000 Sixth  counter byte
COMMENT $0000 Temp storage word for rise/run
COMMENT $0000 Angle for rise/run and rotation calculations
COMMENT $0000 Index pair for run
COMMENT_LINE $0000 $C839   ;Pointer to copyright string during startup
COMMENT $0000 Index pair for rise
COMMENT_LINE $0000 $C83B   ;High score cold-start flag (=0 if valid)
COMMENT $0000 length for rise/run
COMMENT_LINE $0000 $C83C   ;temp byte
COMMENT $0000 Refresh time (divided by 1.5MHz)
COMMENT $0000 Refresh time low byte
COMMENT $0000 Refresh time high byte
COMMENT $0000 Music work buffer (14 bytes, backwards?)
COMMENT $0000 register 10
COMMENT_LINE $0000 $C843   ;        register 9
COMMENT_LINE $0000 $C844   ;        register 8
COMMENT $0000 register 7
COMMENT $0000 register 6
COMMENT $0000 register 5
COMMENT_LINE $0000 $C848   ;        register 4
COMMENT_LINE $0000 $C849   ;        register 3
COMMENT_LINE $0000 $C84A   ;        register 2
COMMENT $0000 register 1
COMMENT_LINE $0000 $C84C   ;        register 0
COMMENT $0000 Pointer to note-to-frequency table (normally $FC8D)
COMMENT $0000 Maximum number of players for Select_Game
COMMENT $0000 Maximum number of games for Select_Game
COMMENT $0000 Storage for first music header word (ADSR table)
COMMENT $0000 Storage for second music header word ('twang' table)
COMMENT $0000 Music data pointer
COMMENT $0000 Used by Explosion_Snd - bit for first channel used?
COMMENT $0000 Used by Explosion_Snd - bits for all channels used?
COMMENT $0000 Current sound channel number for Init_Music
COMMENT $0000 Music active flag ($00=off $01=start $80=on)
COMMENT $0000 Duration counter for Init_Music
COMMENT $0000 3 word 'twang' table used by Init_Music
COMMENT $0000 Four bytes copied from Explosion_Snd's U-reg parameters
COMMENT $0000 Used by Explosion_Snd - channel number in use?
COMMENT $0000 Used by Explosion_Snd - bit for second channel used?
COMMENT $0000 ADSR timers for each sound channel (3 bytes)
COMMENT $0000 Storage for base frequency of each channel (3 words)
COMMENT_LINE $0000 $C85E   ;Scratch 'score' storage for Display_Option (7 bytes)
COMMENT $0000 Explosion_Snd initialization flag?
COMMENT_LINE $0000 $C868...$C876   ;Unused?
COMMENT $0000 Used by Explosion_Snd
COMMENT_LINE $0000 $C878   ;Unused?
COMMENT $0000 Number of players selected in Select_Game
COMMENT $0000 Game number selected in Select_Game
COMMENT $0000 Pointer to 3-byte random number seed (=$C87D)
COMMENT $0000 Default 3-byte random number seed
COMMENT_LINE $0000 $C880 - $CBEA is user RAM  ;
COMMENT $0000 Default top-of-stack
COMMENT $0000 High score storage (7 bytes)
COMMENT $0000 SWI2/SWI3 interrupt vector (3 bytes)
COMMENT $0000 SWI2/SWI3 interrupt vector (3 bytes)
COMMENT $0000 FIRQ interrupt vector (3 bytes)
COMMENT $0000 IRQ interrupt vector (3 bytes)
COMMENT $0000 SWI/NMI interrupt vector (3 bytes)
COMMENT $0000 SWI/NMI interrupt vector (3 bytes)
COMMENT $0000 Cold start flag (warm start if = $7321)
COMMENT $0000 VIA port B data I/O register
COMMENT_LINE $0000 0 sample/hold (0=enable  mux 1=disable mux)
COMMENT_LINE $0000 1 mux sel 0
COMMENT_LINE $0000 2 mux sel 1
COMMENT_LINE $0000 3 sound BC1
COMMENT_LINE $0000 4 sound BDIR
COMMENT_LINE $0000 5 comparator input
COMMENT_LINE $0000 6 external device (slot pin 35) initialized to input
COMMENT_LINE $0000 7 /RAMP
COMMENT $0000 VIA port A data I/O register (handshaking)
COMMENT $0000 VIA port B data direction register (0=input 1=output)
COMMENT $0000 VIA port A data direction register (0=input 1=output)
COMMENT $0000 VIA timer 1 count register lo (scale factor)
COMMENT $0000 VIA timer 1 count register hi
COMMENT $0000 VIA timer 1 latch register lo
COMMENT $0000 VIA timer 1 latch register hi
COMMENT $0000 VIA timer 2 count/latch register lo (refresh)
COMMENT $0000 VIA timer 2 count/latch register hi
COMMENT $0000 VIA shift register
COMMENT $0000 VIA auxiliary control register
COMMENT_LINE $0000 0 PA latch enable
COMMENT_LINE $0000 1 PB latch enable
COMMENT_LINE $0000 2 \                     110=output to CB2 under control of phase 2 clock
COMMENT_LINE $0000 3  > shift register control     (110 is the only mode used by the Vectrex ROM)
COMMENT_LINE $0000 4 /
COMMENT_LINE $0000 5 0=t2 one shot                 1=t2 free running
COMMENT_LINE $0000 6 0=t1 one shot                 1=t1 free running
COMMENT_LINE $0000 7 0=t1 disable PB7 output       1=t1 enable PB7 output
COMMENT $0000 VIA control register
COMMENT_LINE $0000 0 CA1 control     CA1 -> SW7    0=IRQ on low 1=IRQ on high
COMMENT_LINE $0000 1 \
COMMENT_LINE $0000 2  > CA2 control  CA2 -> /ZERO  110=low 111=high
COMMENT_LINE $0000 3 /
COMMENT_LINE $0000 4 CB1 control     CB1 -> NC     0=IRQ on low 1=IRQ on high
COMMENT_LINE $0000 5 \
COMMENT_LINE $0000 6  > CB2 control  CB2 -> /BLANK 110=low 111=high
COMMENT_LINE $0000 7 /
COMMENT $0000 VIA interrupt flags register
COMMENT_LINE $0000 bit                             cleared by
COMMENT_LINE $0000 0 CA2 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 1 CA1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 2 shift register interrupt flag reading or writing shift register
COMMENT_LINE $0000 3 CB2 interrupt flag            reading or writing port B I/O
COMMENT_LINE $0000 4 CB1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 5 timer 2 interrupt flag        read t2 low or write t2 high
COMMENT_LINE $0000 6 timer 1 interrupt flag        read t1 count low or write t1 high
COMMENT_LINE $0000 7 IRQ status flag               write logic 0 to IER or IFR bit
COMMENT $0000 VIA interrupt enable register
COMMENT_LINE $0000 0 CA2 interrupt enable
COMMENT_LINE $0000 1 CA1 interrupt enable
COMMENT_LINE $0000 2 shift register interrupt enable
COMMENT_LINE $0000 3 CB2 interrupt enable
COMMENT_LINE $0000 4 CB1 interrupt enable
COMMENT_LINE $0000 5 timer 2 interrupt enable
COMMENT_LINE $0000 6 timer 1 interrupt enable
COMMENT_LINE $0000 7 IER set/clear control
COMMENT $0000 VIA port A data I/O register (no handshaking)
COMMENT $0000 count y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 count scale y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 count y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 count scale y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 pattern y x pattern y x ... $01
COMMENT $0000 pattern y x pattern y x ... $01
COMMENT $0000 scale pattern y x pattern y x ... $01
COMMENT $0000 pattern y x pattern y x ... $01
COMMENT $0000 pattern y x pattern y x ... $01
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 mode y x mode y x ... $01
COMMENT $0000 never used by GCE carts?
COMMENT $0000 30 cycles
COMMENT $0000 25 cycles
COMMENT $0000 20 cycles
COMMENT $0000 12 cycles
COMMENT $0000 5*B + 10 cycles
COMMENT $0000 5 cycles
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 /BLANK low and /ZERO low
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 like BIOS, but Macro
COMMENT $0000 Store intensity in D/A
COMMENT $0000 Save intensity in $C827
COMMENT $0000 mux disabled channel 2
COMMENT $0000 mux enabled channel 2
COMMENT $0000 do it again just because ?
COMMENT $0000 turn off mux
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 like BIOS, but Macro
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 optimzed
COMMENT $0000 Store intensity in D/A
COMMENT $0000 mux disabled channel 2
COMMENT $0000 mux enabled channel 2
COMMENT $0000 turn off mux
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 optimzed
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 move to time 1 lo, this means scaling
COMMENT $0000 move to time 1 lo, this means scaling
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 scale for placing first point
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 following code uses d0
COMMENT $0000 Store Y in D/A register
COMMENT $0000 Blank low, zero high?
COMMENT $0000 Enable mux
COMMENT $0000 Clear shift regigster
COMMENT $0000 Disable mux
COMMENT $0000 Store X in D/A register
COMMENT $0000 enable timer
COMMENT $0000 following code uses d0
COMMENT $0000 Store Y in D/A register
COMMENT $0000 Blank low, zero high?
COMMENT $0000 Enable mux
COMMENT_LINE $0000 STA     VIA_shift_reg  ;Clear shift regigster
COMMENT $0000 Disable mux
COMMENT $0000 Store X in D/A register
COMMENT $0000 enable timer
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 following code uses d0
COMMENT $0000 Disable mux
COMMENT $0000 Send X to A/D
COMMENT $0000 Put pattern in shift register
COMMENT $0000 enable timer 1
COMMENT $0000 6
COMMENT $0000 7
COMMENT $0000 3 Go back for more points
COMMENT $0000 B-reg = T1 interrupt bit
COMMENT $0000 Wait for T1 to time out
COMMENT $0000 Wait a moment more
COMMENT $0000 Clear shift register (blank output)
COMMENT $0000 3
COMMENT $0000 B-reg = T1 interrupt bit
COMMENT $0000 Wait for T1 to time out
COMMENT $0000 Wait a moment more
COMMENT_LINE $0000 one more round
COMMENT $0000 Disable mux
COMMENT $0000 Send X to A/D
COMMENT $0000 Put pattern in shift register
COMMENT $0000 enable timer 1
COMMENT $0000 B-reg = T1 interrupt bit
COMMENT $0000 Wait for T1 to time out
COMMENT $0000 Clear shift register (blank output)
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 following code uses d0
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 there are many 16 bit operands missing, so is
COMMENT_LINE $0000 a LSRD
COMMENT_LINE $0000 this macro does a 16 bit LSR on register D
COMMENT $0000 LSR A
COMMENT $0000 LSR B
COMMENT $0000 if no carry, than exit
COMMENT $0000 done
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 JSR     Draw_VLp
COMMENT_LINE $0000 RTS
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 Size definitions
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 in maze
COMMENT_LINE $0000 used as init-value in calculation which
COMMENT_LINE $0000 monster is nearest - and therefor visible
COMMENT_LINE $0000 (if done in BIT not BYTE)
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 Type defintions
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 Structure definitions
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 current active monsters
COMMENT_LINE $0000 these are initialized to RAM when level is loaded
COMMENT_LINE $0000 DB 0,0 ; 0 x,y 0,0 denotes NO monster
COMMENT_LINE $0000 DB 0,0 ; 2 x,y offset
COMMENT_LINE $0000 DB 0   ; 4 movement type
COMMENT_LINE $0000 DW 0   ; 5 monster definition place (from level)
COMMENT_LINE $0000 DB 0   ; 7 animation counter
COMMENT_LINE $0000 DW 0   ; 8 current graphic pointer
COMMENT_LINE $0000 DB 0   ; 10 current graphic counter
COMMENT_LINE $0000 DB 0   ; 11 heading
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 monster information
COMMENT_LINE $0000 is placed in ROM, see data section
COMMENT_LINE $0000 DB 3, 5               ; 0 x, y position in Labyrinth
COMMENT_LINE $0000 DB 0, 0               ; 2 x, y offset position in field
COMMENT_LINE $0000 DB NOT_MOVING         ; 4 moving type
COMMENT_LINE $0000 DB 0                  ; 5 moving type speed
COMMENT_LINE $0000 DB 0,0,0,0            ; 6 moving type information (not used here)
COMMENT_LINE $0000 DW goblin_monster     ; 10 monster information structure
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 animation structure for 'objects'
COMMENT_LINE $0000 is places in ROM, see data section
COMMENT_LINE $0000 DB 5            ; 0 anim delay value
COMMENT_LINE $0000 DB ANIMATION    ; 1 type of animation ANIMATION or MORPHING
COMMENT_LINE $0000 DW goblin_pic1  ; 2 vector VList
COMMENT_LINE $0000 DW goblin_pic2  ; ... vector VList
COMMENT_LINE $0000 DW 0            ; end of list
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 monster definition
COMMENT_LINE $0000 is placed in ROM, see data section
COMMENT_LINE $0000 DB 0                  ; 0 special information TORCH_CARRYING, TREASURE TYPE...
COMMENT_LINE $0000 ; baddie, goodie
COMMENT_LINE $0000 DW goblin_animation   ; 1 graphic definition
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $0000 well start of our ram space
COMMENT $C880 vectrex function includes
COMMENT_LINE $C880 this file is part of vectrex frogger, written by Malban
COMMENT_LINE $C880 in March-April 1998
COMMENT_LINE $C880 all stuff contained here is public domain (?)
COMMENT_LINE $C880 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $C880 this file contains includes for vectrex BIOS functions and variables      ;
COMMENT_LINE $C880 it was written by Bruce Tomlin, slightly changed by Malban                ;
COMMENT_LINE $C880 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $C880 Shadow of sound chip registers (15 bytes)
COMMENT $C880 Current state of all joystick buttons
COMMENT $C880 Previous state of all joystick buttons
COMMENT $C880 Current toggle state of all buttons
COMMENT $C880 Current toggle state of stick 1 button 1
COMMENT $C880 Current toggle state of stick 1 button 2
COMMENT $C880 Current toggle state of stick 1 button 3
COMMENT $C880 Current toggle state of stick 1 button 4
COMMENT $C880 Current toggle state of stick 2 button 1
COMMENT $C880 Current toggle state of stick 2 button 2
COMMENT $C880 Current toggle state of stick 2 button 3
COMMENT $C880 Current toggle state of stick 2 button 4
COMMENT $C880 Joystick A/D resolution ($80=min $00=max)
COMMENT $C880 Joystick 1 left/right
COMMENT $C880 Joystick 1 up/down
COMMENT $C880 Joystick 2 left/right
COMMENT $C880 Joystick 2 up/down
COMMENT $C880 Joystick enable/mux flags (4 bytes)
COMMENT $C880 Joystick 1 X enable/mux flag (=1)
COMMENT $C880 Joystick 1 Y enable/mux flag (=3)
COMMENT $C880 Joystick 2 X enable/mux flag (=5)
COMMENT $C880 Joystick 2 Y enable/mux flag (=7)
COMMENT $C880 Misc counter/flag byte, zero when not in use
COMMENT $C880 Check0Ref enable flag
COMMENT $C880 Loop counter word (incremented in Wait_Recal)
COMMENT $C880 Default brightness
COMMENT $C880 Dot dwell time?
COMMENT $C880 Dot pattern (bits)
COMMENT $C880 Default text height and width
COMMENT $C880 Default text height
COMMENT $C880 Default text width
COMMENT $C880 Temporary string pointer for Print_Str
COMMENT $C880 Six bytes of counters
COMMENT $C880 First  counter byte
COMMENT $C880 Second counter byte
COMMENT $C880 Third  counter byte
COMMENT $C880 Fourth counter byte
COMMENT $C880 Fifth  counter byte
COMMENT $C880 Sixth  counter byte
COMMENT $C880 Temp storage word for rise/run
COMMENT $C880 Angle for rise/run and rotation calculations
COMMENT $C880 Index pair for run
COMMENT_LINE $C880 $C839   ;Pointer to copyright string during startup
COMMENT $C880 Index pair for rise
COMMENT_LINE $C880 $C83B   ;High score cold-start flag (=0 if valid)
COMMENT $C880 length for rise/run
COMMENT_LINE $C880 $C83C   ;temp byte
COMMENT $C880 Refresh time (divided by 1.5MHz)
COMMENT $C880 Refresh time low byte
COMMENT $C880 Refresh time high byte
COMMENT $C880 Music work buffer (14 bytes, backwards?)
COMMENT $C880 register 10
COMMENT_LINE $C880 $C843   ;        register 9
COMMENT_LINE $C880 $C844   ;        register 8
COMMENT $C880 register 7
COMMENT $C880 register 6
COMMENT $C880 register 5
COMMENT_LINE $C880 $C848   ;        register 4
COMMENT_LINE $C880 $C849   ;        register 3
COMMENT_LINE $C880 $C84A   ;        register 2
COMMENT $C880 register 1
COMMENT_LINE $C880 $C84C   ;        register 0
COMMENT $C880 Pointer to note-to-frequency table (normally $FC8D)
COMMENT $C880 Maximum number of players for Select_Game
COMMENT $C880 Maximum number of games for Select_Game
COMMENT $C880 Storage for first music header word (ADSR table)
COMMENT $C880 Storage for second music header word ('twang' table)
COMMENT $C880 Music data pointer
COMMENT $C880 Used by Explosion_Snd - bit for first channel used?
COMMENT $C880 Used by Explosion_Snd - bits for all channels used?
COMMENT $C880 Current sound channel number for Init_Music
COMMENT $C880 Music active flag ($00=off $01=start $80=on)
COMMENT $C880 Duration counter for Init_Music
COMMENT $C880 3 word 'twang' table used by Init_Music
COMMENT $C880 Four bytes copied from Explosion_Snd's U-reg parameters
COMMENT $C880 Used by Explosion_Snd - channel number in use?
COMMENT $C880 Used by Explosion_Snd - bit for second channel used?
COMMENT $C880 ADSR timers for each sound channel (3 bytes)
COMMENT $C880 Storage for base frequency of each channel (3 words)
COMMENT_LINE $C880 $C85E   ;Scratch 'score' storage for Display_Option (7 bytes)
COMMENT $C880 Explosion_Snd initialization flag?
COMMENT_LINE $C880 $C868...$C876   ;Unused?
COMMENT $C880 Used by Explosion_Snd
COMMENT_LINE $C880 $C878   ;Unused?
COMMENT $C880 Number of players selected in Select_Game
COMMENT $C880 Game number selected in Select_Game
COMMENT $C880 Pointer to 3-byte random number seed (=$C87D)
COMMENT $C880 Default 3-byte random number seed
COMMENT_LINE $C880 $C880 - $CBEA is user RAM  ;
COMMENT $C880 Default top-of-stack
COMMENT $C880 High score storage (7 bytes)
COMMENT $C880 SWI2/SWI3 interrupt vector (3 bytes)
COMMENT $C880 SWI2/SWI3 interrupt vector (3 bytes)
COMMENT $C880 FIRQ interrupt vector (3 bytes)
COMMENT $C880 IRQ interrupt vector (3 bytes)
COMMENT $C880 SWI/NMI interrupt vector (3 bytes)
COMMENT $C880 SWI/NMI interrupt vector (3 bytes)
COMMENT $C880 Cold start flag (warm start if = $7321)
COMMENT $C880 VIA port B data I/O register
COMMENT_LINE $C880 0 sample/hold (0=enable  mux 1=disable mux)
COMMENT_LINE $C880 1 mux sel 0
COMMENT_LINE $C880 2 mux sel 1
COMMENT_LINE $C880 3 sound BC1
COMMENT_LINE $C880 4 sound BDIR
COMMENT_LINE $C880 5 comparator input
COMMENT_LINE $C880 6 external device (slot pin 35) initialized to input
COMMENT_LINE $C880 7 /RAMP
COMMENT $C880 VIA port A data I/O register (handshaking)
COMMENT $C880 VIA port B data direction register (0=input 1=output)
COMMENT $C880 VIA port A data direction register (0=input 1=output)
COMMENT $C880 VIA timer 1 count register lo (scale factor)
COMMENT $C880 VIA timer 1 count register hi
COMMENT $C880 VIA timer 1 latch register lo
COMMENT $C880 VIA timer 1 latch register hi
COMMENT $C880 VIA timer 2 count/latch register lo (refresh)
COMMENT $C880 VIA timer 2 count/latch register hi
COMMENT $C880 VIA shift register
COMMENT $C880 VIA auxiliary control register
COMMENT_LINE $C880 0 PA latch enable
COMMENT_LINE $C880 1 PB latch enable
COMMENT_LINE $C880 2 \                     110=output to CB2 under control of phase 2 clock
COMMENT_LINE $C880 3  > shift register control     (110 is the only mode used by the Vectrex ROM)
COMMENT_LINE $C880 4 /
COMMENT_LINE $C880 5 0=t2 one shot                 1=t2 free running
COMMENT_LINE $C880 6 0=t1 one shot                 1=t1 free running
COMMENT_LINE $C880 7 0=t1 disable PB7 output       1=t1 enable PB7 output
COMMENT $C880 VIA control register
COMMENT_LINE $C880 0 CA1 control     CA1 -> SW7    0=IRQ on low 1=IRQ on high
COMMENT_LINE $C880 1 \
COMMENT_LINE $C880 2  > CA2 control  CA2 -> /ZERO  110=low 111=high
COMMENT_LINE $C880 3 /
COMMENT_LINE $C880 4 CB1 control     CB1 -> NC     0=IRQ on low 1=IRQ on high
COMMENT_LINE $C880 5 \
COMMENT_LINE $C880 6  > CB2 control  CB2 -> /BLANK 110=low 111=high
COMMENT_LINE $C880 7 /
COMMENT $C880 VIA interrupt flags register
COMMENT_LINE $C880 bit                             cleared by
COMMENT_LINE $C880 0 CA2 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C880 1 CA1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C880 2 shift register interrupt flag reading or writing shift register
COMMENT_LINE $C880 3 CB2 interrupt flag            reading or writing port B I/O
COMMENT_LINE $C880 4 CB1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C880 5 timer 2 interrupt flag        read t2 low or write t2 high
COMMENT_LINE $C880 6 timer 1 interrupt flag        read t1 count low or write t1 high
COMMENT_LINE $C880 7 IRQ status flag               write logic 0 to IER or IFR bit
COMMENT $C880 VIA interrupt enable register
COMMENT_LINE $C880 0 CA2 interrupt enable
COMMENT_LINE $C880 1 CA1 interrupt enable
COMMENT_LINE $C880 2 shift register interrupt enable
COMMENT_LINE $C880 3 CB2 interrupt enable
COMMENT_LINE $C880 4 CB1 interrupt enable
COMMENT_LINE $C880 5 timer 2 interrupt enable
COMMENT_LINE $C880 6 timer 1 interrupt enable
COMMENT_LINE $C880 7 IER set/clear control
COMMENT $C880 VIA port A data I/O register (no handshaking)
COMMENT $C880 count y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 count scale y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 count y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 count scale y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 pattern y x pattern y x ... $01
COMMENT $C880 pattern y x pattern y x ... $01
COMMENT $C880 scale pattern y x pattern y x ... $01
COMMENT $C880 pattern y x pattern y x ... $01
COMMENT $C880 pattern y x pattern y x ... $01
COMMENT $C880 y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 y x y x ...
COMMENT $C880 mode y x mode y x ... $01
COMMENT $C880 never used by GCE carts?
COMMENT $C880 30 cycles
COMMENT $C880 25 cycles
COMMENT $C880 20 cycles
COMMENT $C880 12 cycles
COMMENT $C880 5*B + 10 cycles
COMMENT $C880 5 cycles
COMMENT_LINE $0000 Macro
COMMENT_LINE $C880 all stuff contained here is public domain (?)
COMMENT_LINE $C880 ***************************************************************************
COMMENT $0000 done
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 this divides d by 64
COMMENT $0000 result in A
COMMENT $0000 done
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $C880 all stuff contained here is public domain (?)
COMMENT_LINE $C880 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $C880 this file contains makro definitions of vectrex BIOS functions, these are ;
COMMENT_LINE $C880 exact clones of the BIOS functions                                        ;
COMMENT_LINE $C880 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $C880 ***************************************************************************
COMMENT $0000 pretty for optimizing to use a makro :-)
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 pretty for optimizing to use a makro :-)
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 pretty for optimizing to use a makro :-)
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 pretty for optimizing to use a makro :-)
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 pretty for optimizing to use a makro :-)
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $C880 ***************************************************************************
COMMENT_LINE $C880 entry:   D has clip_counter
COMMENT_LINE $C880 clip_test is set
COMMENT_LINE $C880 v0 is set
COMMENT_LINE $C880 result: v1 = y1, x1
COMMENT_LINE $C880 v2 = y2, x2
COMMENT_LINE $C880 get calculated
COMMENT_LINE $C880 this one assumes X0 is either 64, 32 or 16
COMMENT_LINE $C880 divide is pretty fast than...
COMMENT_LINE $0000 first setup x1 and x2 according to clipping
COMMENT_LINE $0000 information
COMMENT $0000 part of vector that is visible (or vice versa)
COMMENT $0000 part of vector that is invisible (or vice versa)
COMMENT_LINE $0000 now we have to calculate the Y part of the two
COMMENT_LINE $0000 halves
COMMENT_LINE $0000 Y1/X1 and Y2/X2 should be like Y0/X0
COMMENT_LINE $0000 X0 = original length
COMMENT_LINE $0000 than Y1 = Y0*X1/X0
COMMENT_LINE $0000 than Y2 = Y0*X2/X0
COMMENT_LINE $0000 but we know that Y1 + Y2 = Y0
COMMENT_LINE $0000 -> Y2 = Y0 - Y1
COMMENT_LINE $0000 div cycles depend on size of tmp1
COMMENT_LINE $0000 the bigger tmp1 the faster div
COMMENT_LINE $0000 we do div and mul unsigned
COMMENT_LINE $0000 so check for signness here
COMMENT_LINE $0000 and adjust later
COMMENT $0000 this divides d by 64
COMMENT $0000 result in A
COMMENT $0000 store y1
COMMENT $0000 -y1 + y0 = y0 - y1 = y2
COMMENT $0000 store y2
COMMENT $0000 store y1
COMMENT $0000 -y1 + y0 = y0 - y1 = y2
COMMENT $0000 store y2
COMMENT_LINE $0000 Variable
COMMENT_LINE $C906 I used the 6809 assembler:
COMMENT_LINE $C906 as09 [1.11].
COMMENT_LINE $C906 Copyright 1990-1994, Frank A. Vorstenbosch, Kingswood Software.
COMMENT_LINE $C906 Available at:
COMMENT_LINE $C906 http://www.falstaff.demon.co.uk/cross.html
COMMENT $C906 vectrex function includes
COMMENT_LINE $C906 this file is part of vectrex frogger, written by Malban
COMMENT_LINE $C906 in March-April 1998
COMMENT_LINE $C906 all stuff contained here is public domain (?)
COMMENT_LINE $C906 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $C906 this file contains includes for vectrex BIOS functions and variables      ;
COMMENT_LINE $C906 it was written by Bruce Tomlin, slightly changed by Malban                ;
COMMENT_LINE $C906 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $C906 Shadow of sound chip registers (15 bytes)
COMMENT $C906 Current state of all joystick buttons
COMMENT $C906 Previous state of all joystick buttons
COMMENT $C906 Current toggle state of all buttons
COMMENT $C906 Current toggle state of stick 1 button 1
COMMENT $C906 Current toggle state of stick 1 button 2
COMMENT $C906 Current toggle state of stick 1 button 3
COMMENT $C906 Current toggle state of stick 1 button 4
COMMENT $C906 Current toggle state of stick 2 button 1
COMMENT $C906 Current toggle state of stick 2 button 2
COMMENT $C906 Current toggle state of stick 2 button 3
COMMENT $C906 Current toggle state of stick 2 button 4
COMMENT $C906 Joystick A/D resolution ($80=min $00=max)
COMMENT $C906 Joystick 1 left/right
COMMENT $C906 Joystick 1 up/down
COMMENT $C906 Joystick 2 left/right
COMMENT $C906 Joystick 2 up/down
COMMENT $C906 Joystick enable/mux flags (4 bytes)
COMMENT $C906 Joystick 1 X enable/mux flag (=1)
COMMENT $C906 Joystick 1 Y enable/mux flag (=3)
COMMENT $C906 Joystick 2 X enable/mux flag (=5)
COMMENT $C906 Joystick 2 Y enable/mux flag (=7)
COMMENT $C906 Misc counter/flag byte, zero when not in use
COMMENT $C906 Check0Ref enable flag
COMMENT $C906 Loop counter word (incremented in Wait_Recal)
COMMENT $C906 Default brightness
COMMENT $C906 Dot dwell time?
COMMENT $C906 Dot pattern (bits)
COMMENT $C906 Default text height and width
COMMENT $C906 Default text height
COMMENT $C906 Default text width
COMMENT $C906 Temporary string pointer for Print_Str
COMMENT $C906 Six bytes of counters
COMMENT $C906 First  counter byte
COMMENT $C906 Second counter byte
COMMENT $C906 Third  counter byte
COMMENT $C906 Fourth counter byte
COMMENT $C906 Fifth  counter byte
COMMENT $C906 Sixth  counter byte
COMMENT $C906 Temp storage word for rise/run
COMMENT $C906 Angle for rise/run and rotation calculations
COMMENT $C906 Index pair for run
COMMENT_LINE $C906 $C839   ;Pointer to copyright string during startup
COMMENT $C906 Index pair for rise
COMMENT_LINE $C906 $C83B   ;High score cold-start flag (=0 if valid)
COMMENT $C906 length for rise/run
COMMENT_LINE $C906 $C83C   ;temp byte
COMMENT $C906 Refresh time (divided by 1.5MHz)
COMMENT $C906 Refresh time low byte
COMMENT $C906 Refresh time high byte
COMMENT $C906 Music work buffer (14 bytes, backwards?)
COMMENT $C906 register 10
COMMENT_LINE $C906 $C843   ;        register 9
COMMENT_LINE $C906 $C844   ;        register 8
COMMENT $C906 register 7
COMMENT $C906 register 6
COMMENT $C906 register 5
COMMENT_LINE $C906 $C848   ;        register 4
COMMENT_LINE $C906 $C849   ;        register 3
COMMENT_LINE $C906 $C84A   ;        register 2
COMMENT $C906 register 1
COMMENT_LINE $C906 $C84C   ;        register 0
COMMENT $C906 Pointer to note-to-frequency table (normally $FC8D)
COMMENT $C906 Maximum number of players for Select_Game
COMMENT $C906 Maximum number of games for Select_Game
COMMENT $C906 Storage for first music header word (ADSR table)
COMMENT $C906 Storage for second music header word ('twang' table)
COMMENT $C906 Music data pointer
COMMENT $C906 Used by Explosion_Snd - bit for first channel used?
COMMENT $C906 Used by Explosion_Snd - bits for all channels used?
COMMENT $C906 Current sound channel number for Init_Music
COMMENT $C906 Music active flag ($00=off $01=start $80=on)
COMMENT $C906 Duration counter for Init_Music
COMMENT $C906 3 word 'twang' table used by Init_Music
COMMENT $C906 Four bytes copied from Explosion_Snd's U-reg parameters
COMMENT $C906 Used by Explosion_Snd - channel number in use?
COMMENT $C906 Used by Explosion_Snd - bit for second channel used?
COMMENT $C906 ADSR timers for each sound channel (3 bytes)
COMMENT $C906 Storage for base frequency of each channel (3 words)
COMMENT_LINE $C906 $C85E   ;Scratch 'score' storage for Display_Option (7 bytes)
COMMENT $C906 Explosion_Snd initialization flag?
COMMENT_LINE $C906 $C868...$C876   ;Unused?
COMMENT $C906 Used by Explosion_Snd
COMMENT_LINE $C906 $C878   ;Unused?
COMMENT $C906 Number of players selected in Select_Game
COMMENT $C906 Game number selected in Select_Game
COMMENT $C906 Pointer to 3-byte random number seed (=$C87D)
COMMENT $C906 Default 3-byte random number seed
COMMENT_LINE $C906 $C880 - $CBEA is user RAM  ;
COMMENT $C906 Default top-of-stack
COMMENT $C906 High score storage (7 bytes)
COMMENT $C906 SWI2/SWI3 interrupt vector (3 bytes)
COMMENT $C906 SWI2/SWI3 interrupt vector (3 bytes)
COMMENT $C906 FIRQ interrupt vector (3 bytes)
COMMENT $C906 IRQ interrupt vector (3 bytes)
COMMENT $C906 SWI/NMI interrupt vector (3 bytes)
COMMENT $C906 SWI/NMI interrupt vector (3 bytes)
COMMENT $C906 Cold start flag (warm start if = $7321)
COMMENT $C906 VIA port B data I/O register
COMMENT_LINE $C906 0 sample/hold (0=enable  mux 1=disable mux)
COMMENT_LINE $C906 1 mux sel 0
COMMENT_LINE $C906 2 mux sel 1
COMMENT_LINE $C906 3 sound BC1
COMMENT_LINE $C906 4 sound BDIR
COMMENT_LINE $C906 5 comparator input
COMMENT_LINE $C906 6 external device (slot pin 35) initialized to input
COMMENT_LINE $C906 7 /RAMP
COMMENT $C906 VIA port A data I/O register (handshaking)
COMMENT $C906 VIA port B data direction register (0=input 1=output)
COMMENT $C906 VIA port A data direction register (0=input 1=output)
COMMENT $C906 VIA timer 1 count register lo (scale factor)
COMMENT $C906 VIA timer 1 count register hi
COMMENT $C906 VIA timer 1 latch register lo
COMMENT $C906 VIA timer 1 latch register hi
COMMENT $C906 VIA timer 2 count/latch register lo (refresh)
COMMENT $C906 VIA timer 2 count/latch register hi
COMMENT $C906 VIA shift register
COMMENT $C906 VIA auxiliary control register
COMMENT_LINE $C906 0 PA latch enable
COMMENT_LINE $C906 1 PB latch enable
COMMENT_LINE $C906 2 \                     110=output to CB2 under control of phase 2 clock
COMMENT_LINE $C906 3  > shift register control     (110 is the only mode used by the Vectrex ROM)
COMMENT_LINE $C906 4 /
COMMENT_LINE $C906 5 0=t2 one shot                 1=t2 free running
COMMENT_LINE $C906 6 0=t1 one shot                 1=t1 free running
COMMENT_LINE $C906 7 0=t1 disable PB7 output       1=t1 enable PB7 output
COMMENT $C906 VIA control register
COMMENT_LINE $C906 0 CA1 control     CA1 -> SW7    0=IRQ on low 1=IRQ on high
COMMENT_LINE $C906 1 \
COMMENT_LINE $C906 2  > CA2 control  CA2 -> /ZERO  110=low 111=high
COMMENT_LINE $C906 3 /
COMMENT_LINE $C906 4 CB1 control     CB1 -> NC     0=IRQ on low 1=IRQ on high
COMMENT_LINE $C906 5 \
COMMENT_LINE $C906 6  > CB2 control  CB2 -> /BLANK 110=low 111=high
COMMENT_LINE $C906 7 /
COMMENT $C906 VIA interrupt flags register
COMMENT_LINE $C906 bit                             cleared by
COMMENT_LINE $C906 0 CA2 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C906 1 CA1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C906 2 shift register interrupt flag reading or writing shift register
COMMENT_LINE $C906 3 CB2 interrupt flag            reading or writing port B I/O
COMMENT_LINE $C906 4 CB1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C906 5 timer 2 interrupt flag        read t2 low or write t2 high
COMMENT_LINE $C906 6 timer 1 interrupt flag        read t1 count low or write t1 high
COMMENT_LINE $C906 7 IRQ status flag               write logic 0 to IER or IFR bit
COMMENT $C906 VIA interrupt enable register
COMMENT_LINE $C906 0 CA2 interrupt enable
COMMENT_LINE $C906 1 CA1 interrupt enable
COMMENT_LINE $C906 2 shift register interrupt enable
COMMENT_LINE $C906 3 CB2 interrupt enable
COMMENT_LINE $C906 4 CB1 interrupt enable
COMMENT_LINE $C906 5 timer 2 interrupt enable
COMMENT_LINE $C906 6 timer 1 interrupt enable
COMMENT_LINE $C906 7 IER set/clear control
COMMENT $C906 VIA port A data I/O register (no handshaking)
COMMENT $C906 count y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 count scale y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 count y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 count scale y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 pattern y x pattern y x ... $01
COMMENT $C906 pattern y x pattern y x ... $01
COMMENT $C906 scale pattern y x pattern y x ... $01
COMMENT $C906 pattern y x pattern y x ... $01
COMMENT $C906 pattern y x pattern y x ... $01
COMMENT $C906 y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 y x y x ...
COMMENT $C906 mode y x mode y x ... $01
COMMENT $C906 never used by GCE carts?
COMMENT $C906 30 cycles
COMMENT $C906 25 cycles
COMMENT $C906 20 cycles
COMMENT $C906 12 cycles
COMMENT $C906 5*B + 10 cycles
COMMENT $C906 5 cycles
COMMENT_LINE $C9AC Plays digitized sound, while displaying vectors
COMMENT_LINE $C9AC This is a second version, DIFFERENT than last one, might be more
COMMENT_LINE $C9AC efficient!
COMMENT_LINE $C9AC Sample output is not guranteed to be 'in time'.
COMMENT_LINE $C9AC That means the samples are not send to via with a fixed frequence, rather
COMMENT_LINE $C9AC at some frequency that comes near the desired frequency.
COMMENT_LINE $C9AC The programmer using these routines must make sure
COMMENT_LINE $C9AC the samples are output often enough.
COMMENT_LINE $C9AC The provided DRAW, MOVE and RECALIBRATION routines update in correct
COMMENT_LINE $C9AC frequencies, the things the programmer does apart from
COMMENT_LINE $C9AC these routines... well, is his concern.
COMMENT_LINE $C9AC As said above, missing a sample output by some cycles ... doesn't really
COMMENT_LINE $C9AC matter.
COMMENT_LINE $C9AC How it works this time.
COMMENT_LINE $C9AC The timer 2 is = as usual to 30000 so that update frequency is 50Hz.
COMMENT_LINE $C9AC depending on the sample rate I calculate the next cycle that a sample
COMMENT_LINE $C9AC should be put to VIA.
COMMENT_LINE $C9AC 2kHz samples should (about) be outputed(?grammar?) every 700 cycles.
COMMENT_LINE $C9AC So we should output at:
COMMENT_LINE $C9AC 29300, 28600, 27900, ...
COMMENT_LINE $C9AC The (non public) macro WAIT_FOR_NEXT_DIGIT does wait for the next
COMMENT_LINE $C9AC timer position to output a sample (if the timer has not already passed).
COMMENT_LINE $C9AC The macro NEXT_DIGIT_BYTE puts the next sample to VIA after calling above
COMMENT_LINE $C9AC macro. NEXT_DIGIT_BYTE does not test whether the complete sample has already
COMMENT_LINE $C9AC finished playing! NEXT_DIGIT_BYTE should not be put to code randomly
COMMENT_LINE $C9AC since it ALLWAYS puts some sort of sample to VIA. That might be WRONG.
COMMENT_LINE $C9AC Likewise for optimization, the MOVE and DRAW macros (which do use
COMMENT_LINE $C9AC NEXT_DIGIT_BYTE, should not be called when no sample is playing).
COMMENT_LINE $C9AC If you want to use routines which can allways be used, change below
COMMENT_LINE $C9AC MOVE and DRAW macros to use NEXT_DIGIT_BYTE_WITH_TEST.
COMMENT_LINE $C9AC Which does test for sample end and sets the variables for checking
COMMENT_LINE $C9AC accordingly.
COMMENT_LINE $C9AC The provided RECALIBRATION macro uses NEXT_DIGIT_BYTE_WITH_TEST, therefor
COMMENT_LINE $C9AC per default a sample is only checked for its end during the recalibration
COMMENT_LINE $C9AC phase. This saves considerable time! (about 5000 - 8000 cycles)
COMMENT_LINE $C9AC Current sample position is stored in register Y.
COMMENT_LINE $C9AC Y MUST NOT BE CHANGED!
COMMENT_LINE $C9AC (or you have to reprogram the makros below to use a ram slot and not Y)
COMMENT_LINE $C9AC Routines play sample structures now,
COMMENT_LINE $C9AC that way samples might be concatinated on the fly and thus
COMMENT_LINE $C9AC reused.
COMMENT_LINE $C9AC following is the sample structure:
COMMENT_LINE $C9AC Structure of samples
COMMENT_LINE $C9AC DB 0      ; is looping 0 or 1
COMMENT_LINE $C9AC DW 0, 0   ; start position and length of sample
COMMENT_LINE $C9AC DW 0, 0   ; start position and length of sample 2...
COMMENT_LINE $C9AC ...
COMMENT_LINE $C9AC DW 0      ; finishes with a zero to indicate end of sample!
COMMENT_LINE $C9AC A sample should have a small buffer behind (befor, since played backwords) it,
COMMENT_LINE $C9AC since it is only check during recalibration whether the sample
COMMENT_LINE $C9AC is finished.
COMMENT_LINE $C9AC Using 2kHz samples playes about 40 = (30000 / T2_TIMER_PEROID_REAL)
COMMENT_LINE $C9AC samples per update round
COMMENT_LINE $C9AC so -> in worst case we play 39 garbage samples.
COMMENT_LINE $C9AC samples must be:
COMMENT_LINE $C9AC 8 bit mono signed
COMMENT_LINE $C9AC different sample-frequency can be used, provided
COMMENT_LINE $C9AC the constant "T2_TIMER_PEROID_REAL" is = to a appropriate value
COMMENT_LINE $C9AC for now this routine playes all samples 'backwards'
COMMENT_LINE $C9AC -> so you also have to turn your samples arround :-)
COMMENT_LINE $C9AC I used the 6809 assembler:
COMMENT_LINE $C9AC as09 [1.11].
COMMENT_LINE $C9AC Copyright 1990-1994, Frank A. Vorstenbosch, Kingswood Software.
COMMENT_LINE $C9AC Available at:
COMMENT_LINE $C9AC http://www.falstaff.demon.co.uk/cross.html
COMMENT $C9AC vectrex function includes
COMMENT_LINE $C9AC this file is part of vectrex frogger, written by Malban
COMMENT_LINE $C9AC in March-April 1998
COMMENT_LINE $C9AC all stuff contained here is public domain (?)
COMMENT_LINE $C9AC ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $C9AC this file contains includes for vectrex BIOS functions and variables      ;
COMMENT_LINE $C9AC it was written by Bruce Tomlin, slightly changed by Malban                ;
COMMENT_LINE $C9AC ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $C9AC Shadow of sound chip registers (15 bytes)
COMMENT $C9AC Current state of all joystick buttons
COMMENT $C9AC Previous state of all joystick buttons
COMMENT $C9AC Current toggle state of all buttons
COMMENT $C9AC Current toggle state of stick 1 button 1
COMMENT $C9AC Current toggle state of stick 1 button 2
COMMENT $C9AC Current toggle state of stick 1 button 3
COMMENT $C9AC Current toggle state of stick 1 button 4
COMMENT $C9AC Current toggle state of stick 2 button 1
COMMENT $C9AC Current toggle state of stick 2 button 2
COMMENT $C9AC Current toggle state of stick 2 button 3
COMMENT $C9AC Current toggle state of stick 2 button 4
COMMENT $C9AC Joystick A/D resolution ($80=min $00=max)
COMMENT $C9AC Joystick 1 left/right
COMMENT $C9AC Joystick 1 up/down
COMMENT $C9AC Joystick 2 left/right
COMMENT $C9AC Joystick 2 up/down
COMMENT $C9AC Joystick enable/mux flags (4 bytes)
COMMENT $C9AC Joystick 1 X enable/mux flag (=1)
COMMENT $C9AC Joystick 1 Y enable/mux flag (=3)
COMMENT $C9AC Joystick 2 X enable/mux flag (=5)
COMMENT $C9AC Joystick 2 Y enable/mux flag (=7)
COMMENT $C9AC Misc counter/flag byte, zero when not in use
COMMENT $C9AC Check0Ref enable flag
COMMENT $C9AC Loop counter word (incremented in Wait_Recal)
COMMENT $C9AC Default brightness
COMMENT $C9AC Dot dwell time?
COMMENT $C9AC Dot pattern (bits)
COMMENT $C9AC Default text height and width
COMMENT $C9AC Default text height
COMMENT $C9AC Default text width
COMMENT $C9AC Temporary string pointer for Print_Str
COMMENT $C9AC Six bytes of counters
COMMENT $C9AC First  counter byte
COMMENT $C9AC Second counter byte
COMMENT $C9AC Third  counter byte
COMMENT $C9AC Fourth counter byte
COMMENT $C9AC Fifth  counter byte
COMMENT $C9AC Sixth  counter byte
COMMENT $C9AC Temp storage word for rise/run
COMMENT $C9AC Angle for rise/run and rotation calculations
COMMENT $C9AC Index pair for run
COMMENT_LINE $C9AC $C839   ;Pointer to copyright string during startup
COMMENT $C9AC Index pair for rise
COMMENT_LINE $C9AC $C83B   ;High score cold-start flag (=0 if valid)
COMMENT $C9AC length for rise/run
COMMENT_LINE $C9AC $C83C   ;temp byte
COMMENT $C9AC Refresh time (divided by 1.5MHz)
COMMENT $C9AC Refresh time low byte
COMMENT $C9AC Refresh time high byte
COMMENT $C9AC Music work buffer (14 bytes, backwards?)
COMMENT $C9AC register 10
COMMENT_LINE $C9AC $C843   ;        register 9
COMMENT_LINE $C9AC $C844   ;        register 8
COMMENT $C9AC register 7
COMMENT $C9AC register 6
COMMENT $C9AC register 5
COMMENT_LINE $C9AC $C848   ;        register 4
COMMENT_LINE $C9AC $C849   ;        register 3
COMMENT_LINE $C9AC $C84A   ;        register 2
COMMENT $C9AC register 1
COMMENT_LINE $C9AC $C84C   ;        register 0
COMMENT $C9AC Pointer to note-to-frequency table (normally $FC8D)
COMMENT $C9AC Maximum number of players for Select_Game
COMMENT $C9AC Maximum number of games for Select_Game
COMMENT $C9AC Storage for first music header word (ADSR table)
COMMENT $C9AC Storage for second music header word ('twang' table)
COMMENT $C9AC Music data pointer
COMMENT $C9AC Used by Explosion_Snd - bit for first channel used?
COMMENT $C9AC Used by Explosion_Snd - bits for all channels used?
COMMENT $C9AC Current sound channel number for Init_Music
COMMENT $C9AC Music active flag ($00=off $01=start $80=on)
COMMENT $C9AC Duration counter for Init_Music
COMMENT $C9AC 3 word 'twang' table used by Init_Music
COMMENT $C9AC Four bytes copied from Explosion_Snd's U-reg parameters
COMMENT $C9AC Used by Explosion_Snd - channel number in use?
COMMENT $C9AC Used by Explosion_Snd - bit for second channel used?
COMMENT $C9AC ADSR timers for each sound channel (3 bytes)
COMMENT $C9AC Storage for base frequency of each channel (3 words)
COMMENT_LINE $C9AC $C85E   ;Scratch 'score' storage for Display_Option (7 bytes)
COMMENT $C9AC Explosion_Snd initialization flag?
COMMENT_LINE $C9AC $C868...$C876   ;Unused?
COMMENT $C9AC Used by Explosion_Snd
COMMENT_LINE $C9AC $C878   ;Unused?
COMMENT $C9AC Number of players selected in Select_Game
COMMENT $C9AC Game number selected in Select_Game
COMMENT $C9AC Pointer to 3-byte random number seed (=$C87D)
COMMENT $C9AC Default 3-byte random number seed
COMMENT_LINE $C9AC $C880 - $CBEA is user RAM  ;
COMMENT $C9AC Default top-of-stack
COMMENT $C9AC High score storage (7 bytes)
COMMENT $C9AC SWI2/SWI3 interrupt vector (3 bytes)
COMMENT $C9AC SWI2/SWI3 interrupt vector (3 bytes)
COMMENT $C9AC FIRQ interrupt vector (3 bytes)
COMMENT $C9AC IRQ interrupt vector (3 bytes)
COMMENT $C9AC SWI/NMI interrupt vector (3 bytes)
COMMENT $C9AC SWI/NMI interrupt vector (3 bytes)
COMMENT $C9AC Cold start flag (warm start if = $7321)
COMMENT $C9AC VIA port B data I/O register
COMMENT_LINE $C9AC 0 sample/hold (0=enable  mux 1=disable mux)
COMMENT_LINE $C9AC 1 mux sel 0
COMMENT_LINE $C9AC 2 mux sel 1
COMMENT_LINE $C9AC 3 sound BC1
COMMENT_LINE $C9AC 4 sound BDIR
COMMENT_LINE $C9AC 5 comparator input
COMMENT_LINE $C9AC 6 external device (slot pin 35) initialized to input
COMMENT_LINE $C9AC 7 /RAMP
COMMENT $C9AC VIA port A data I/O register (handshaking)
COMMENT $C9AC VIA port B data direction register (0=input 1=output)
COMMENT $C9AC VIA port A data direction register (0=input 1=output)
COMMENT $C9AC VIA timer 1 count register lo (scale factor)
COMMENT $C9AC VIA timer 1 count register hi
COMMENT $C9AC VIA timer 1 latch register lo
COMMENT $C9AC VIA timer 1 latch register hi
COMMENT $C9AC VIA timer 2 count/latch register lo (refresh)
COMMENT $C9AC VIA timer 2 count/latch register hi
COMMENT $C9AC VIA shift register
COMMENT $C9AC VIA auxiliary control register
COMMENT_LINE $C9AC 0 PA latch enable
COMMENT_LINE $C9AC 1 PB latch enable
COMMENT_LINE $C9AC 2 \                     110=output to CB2 under control of phase 2 clock
COMMENT_LINE $C9AC 3  > shift register control     (110 is the only mode used by the Vectrex ROM)
COMMENT_LINE $C9AC 4 /
COMMENT_LINE $C9AC 5 0=t2 one shot                 1=t2 free running
COMMENT_LINE $C9AC 6 0=t1 one shot                 1=t1 free running
COMMENT_LINE $C9AC 7 0=t1 disable PB7 output       1=t1 enable PB7 output
COMMENT $C9AC VIA control register
COMMENT_LINE $C9AC 0 CA1 control     CA1 -> SW7    0=IRQ on low 1=IRQ on high
COMMENT_LINE $C9AC 1 \
COMMENT_LINE $C9AC 2  > CA2 control  CA2 -> /ZERO  110=low 111=high
COMMENT_LINE $C9AC 3 /
COMMENT_LINE $C9AC 4 CB1 control     CB1 -> NC     0=IRQ on low 1=IRQ on high
COMMENT_LINE $C9AC 5 \
COMMENT_LINE $C9AC 6  > CB2 control  CB2 -> /BLANK 110=low 111=high
COMMENT_LINE $C9AC 7 /
COMMENT $C9AC VIA interrupt flags register
COMMENT_LINE $C9AC bit                             cleared by
COMMENT_LINE $C9AC 0 CA2 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C9AC 1 CA1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C9AC 2 shift register interrupt flag reading or writing shift register
COMMENT_LINE $C9AC 3 CB2 interrupt flag            reading or writing port B I/O
COMMENT_LINE $C9AC 4 CB1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $C9AC 5 timer 2 interrupt flag        read t2 low or write t2 high
COMMENT_LINE $C9AC 6 timer 1 interrupt flag        read t1 count low or write t1 high
COMMENT_LINE $C9AC 7 IRQ status flag               write logic 0 to IER or IFR bit
COMMENT $C9AC VIA interrupt enable register
COMMENT_LINE $C9AC 0 CA2 interrupt enable
COMMENT_LINE $C9AC 1 CA1 interrupt enable
COMMENT_LINE $C9AC 2 shift register interrupt enable
COMMENT_LINE $C9AC 3 CB2 interrupt enable
COMMENT_LINE $C9AC 4 CB1 interrupt enable
COMMENT_LINE $C9AC 5 timer 2 interrupt enable
COMMENT_LINE $C9AC 6 timer 1 interrupt enable
COMMENT_LINE $C9AC 7 IER set/clear control
COMMENT $C9AC VIA port A data I/O register (no handshaking)
COMMENT $C9AC count y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC count scale y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC count y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC count scale y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC pattern y x pattern y x ... $01
COMMENT $C9AC pattern y x pattern y x ... $01
COMMENT $C9AC scale pattern y x pattern y x ... $01
COMMENT $C9AC pattern y x pattern y x ... $01
COMMENT $C9AC pattern y x pattern y x ... $01
COMMENT $C9AC y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC y x y x ...
COMMENT $C9AC mode y x mode y x ... $01
COMMENT $C9AC never used by GCE carts?
COMMENT $C9AC 30 cycles
COMMENT $C9AC 25 cycles
COMMENT $C9AC 20 cycles
COMMENT $C9AC 12 cycles
COMMENT $C9AC 5*B + 10 cycles
COMMENT $C9AC 5 cycles
COMMENT $C9AC vectrex function includes
COMMENT_LINE $C9AC all stuff contained here is public domain (?)
COMMENT_LINE $C9AC ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $C9AC this file contains makro definitions of vectrex BIOS functions, these are ;
COMMENT_LINE $C9AC exact clones of the BIOS functions                                        ;
COMMENT_LINE $C9AC ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 this file is part of vectrex frogger, written by Malban
COMMENT_LINE $0000 in March-April 1998
COMMENT_LINE $0000 all stuff contained here is public domain (?)
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 this file contains includes for vectrex BIOS functions and variables      ;
COMMENT_LINE $0000 it was written by Bruce Tomlin, slightly changed by Malban                ;
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT $0000 Shadow of sound chip registers (15 bytes)
COMMENT $0000 Current state of all joystick buttons
COMMENT $0000 Previous state of all joystick buttons
COMMENT $0000 Current toggle state of all buttons
COMMENT $0000 Current toggle state of stick 1 button 1
COMMENT $0000 Current toggle state of stick 1 button 2
COMMENT $0000 Current toggle state of stick 1 button 3
COMMENT $0000 Current toggle state of stick 1 button 4
COMMENT $0000 Current toggle state of stick 2 button 1
COMMENT $0000 Current toggle state of stick 2 button 2
COMMENT $0000 Current toggle state of stick 2 button 3
COMMENT $0000 Current toggle state of stick 2 button 4
COMMENT $0000 Joystick A/D resolution ($80=min $00=max)
COMMENT $0000 Joystick 1 left/right
COMMENT $0000 Joystick 1 up/down
COMMENT $0000 Joystick 2 left/right
COMMENT $0000 Joystick 2 up/down
COMMENT $0000 Joystick enable/mux flags (4 bytes)
COMMENT $0000 Joystick 1 X enable/mux flag (=1)
COMMENT $0000 Joystick 1 Y enable/mux flag (=3)
COMMENT $0000 Joystick 2 X enable/mux flag (=5)
COMMENT $0000 Joystick 2 Y enable/mux flag (=7)
COMMENT $0000 Misc counter/flag byte, zero when not in use
COMMENT $0000 Check0Ref enable flag
COMMENT $0000 Loop counter word (incremented in Wait_Recal)
COMMENT $0000 Default brightness
COMMENT $0000 Dot dwell time?
COMMENT $0000 Dot pattern (bits)
COMMENT $0000 Default text height and width
COMMENT $0000 Default text height
COMMENT $0000 Default text width
COMMENT $0000 Temporary string pointer for Print_Str
COMMENT $0000 Six bytes of counters
COMMENT $0000 First  counter byte
COMMENT $0000 Second counter byte
COMMENT $0000 Third  counter byte
COMMENT $0000 Fourth counter byte
COMMENT $0000 Fifth  counter byte
COMMENT $0000 Sixth  counter byte
COMMENT $0000 Temp storage word for rise/run
COMMENT $0000 Angle for rise/run and rotation calculations
COMMENT $0000 Index pair for run
COMMENT_LINE $0000 $C839   ;Pointer to copyright string during startup
COMMENT $0000 Index pair for rise
COMMENT_LINE $0000 $C83B   ;High score cold-start flag (=0 if valid)
COMMENT $0000 length for rise/run
COMMENT_LINE $0000 $C83C   ;temp byte
COMMENT $0000 Refresh time (divided by 1.5MHz)
COMMENT $0000 Refresh time low byte
COMMENT $0000 Refresh time high byte
COMMENT $0000 Music work buffer (14 bytes, backwards?)
COMMENT $0000 register 10
COMMENT_LINE $0000 $C843   ;        register 9
COMMENT_LINE $0000 $C844   ;        register 8
COMMENT $0000 register 7
COMMENT $0000 register 6
COMMENT $0000 register 5
COMMENT_LINE $0000 $C848   ;        register 4
COMMENT_LINE $0000 $C849   ;        register 3
COMMENT_LINE $0000 $C84A   ;        register 2
COMMENT $0000 register 1
COMMENT_LINE $0000 $C84C   ;        register 0
COMMENT $0000 Pointer to note-to-frequency table (normally $FC8D)
COMMENT $0000 Maximum number of players for Select_Game
COMMENT $0000 Maximum number of games for Select_Game
COMMENT $0000 Storage for first music header word (ADSR table)
COMMENT $0000 Storage for second music header word ('twang' table)
COMMENT $0000 Music data pointer
COMMENT $0000 Used by Explosion_Snd - bit for first channel used?
COMMENT $0000 Used by Explosion_Snd - bits for all channels used?
COMMENT $0000 Current sound channel number for Init_Music
COMMENT $0000 Music active flag ($00=off $01=start $80=on)
COMMENT $0000 Duration counter for Init_Music
COMMENT $0000 3 word 'twang' table used by Init_Music
COMMENT $0000 Four bytes copied from Explosion_Snd's U-reg parameters
COMMENT $0000 Used by Explosion_Snd - channel number in use?
COMMENT $0000 Used by Explosion_Snd - bit for second channel used?
COMMENT $0000 ADSR timers for each sound channel (3 bytes)
COMMENT $0000 Storage for base frequency of each channel (3 words)
COMMENT_LINE $0000 $C85E   ;Scratch 'score' storage for Display_Option (7 bytes)
COMMENT $0000 Explosion_Snd initialization flag?
COMMENT_LINE $0000 $C868...$C876   ;Unused?
COMMENT $0000 Used by Explosion_Snd
COMMENT_LINE $0000 $C878   ;Unused?
COMMENT $0000 Number of players selected in Select_Game
COMMENT $0000 Game number selected in Select_Game
COMMENT $0000 Pointer to 3-byte random number seed (=$C87D)
COMMENT $0000 Default 3-byte random number seed
COMMENT_LINE $0000 $C880 - $CBEA is user RAM  ;
COMMENT $0000 Default top-of-stack
COMMENT $0000 High score storage (7 bytes)
COMMENT $0000 SWI2/SWI3 interrupt vector (3 bytes)
COMMENT $0000 SWI2/SWI3 interrupt vector (3 bytes)
COMMENT $0000 FIRQ interrupt vector (3 bytes)
COMMENT $0000 IRQ interrupt vector (3 bytes)
COMMENT $0000 SWI/NMI interrupt vector (3 bytes)
COMMENT $0000 SWI/NMI interrupt vector (3 bytes)
COMMENT $0000 Cold start flag (warm start if = $7321)
COMMENT $0000 VIA port B data I/O register
COMMENT_LINE $0000 0 sample/hold (0=enable  mux 1=disable mux)
COMMENT_LINE $0000 1 mux sel 0
COMMENT_LINE $0000 2 mux sel 1
COMMENT_LINE $0000 3 sound BC1
COMMENT_LINE $0000 4 sound BDIR
COMMENT_LINE $0000 5 comparator input
COMMENT_LINE $0000 6 external device (slot pin 35) initialized to input
COMMENT_LINE $0000 7 /RAMP
COMMENT $0000 VIA port A data I/O register (handshaking)
COMMENT $0000 VIA port B data direction register (0=input 1=output)
COMMENT $0000 VIA port A data direction register (0=input 1=output)
COMMENT $0000 VIA timer 1 count register lo (scale factor)
COMMENT $0000 VIA timer 1 count register hi
COMMENT $0000 VIA timer 1 latch register lo
COMMENT $0000 VIA timer 1 latch register hi
COMMENT $0000 VIA timer 2 count/latch register lo (refresh)
COMMENT $0000 VIA timer 2 count/latch register hi
COMMENT $0000 VIA shift register
COMMENT $0000 VIA auxiliary control register
COMMENT_LINE $0000 0 PA latch enable
COMMENT_LINE $0000 1 PB latch enable
COMMENT_LINE $0000 2 \                     110=output to CB2 under control of phase 2 clock
COMMENT_LINE $0000 3  > shift register control     (110 is the only mode used by the Vectrex ROM)
COMMENT_LINE $0000 4 /
COMMENT_LINE $0000 5 0=t2 one shot                 1=t2 free running
COMMENT_LINE $0000 6 0=t1 one shot                 1=t1 free running
COMMENT_LINE $0000 7 0=t1 disable PB7 output       1=t1 enable PB7 output
COMMENT $0000 VIA control register
COMMENT_LINE $0000 0 CA1 control     CA1 -> SW7    0=IRQ on low 1=IRQ on high
COMMENT_LINE $0000 1 \
COMMENT_LINE $0000 2  > CA2 control  CA2 -> /ZERO  110=low 111=high
COMMENT_LINE $0000 3 /
COMMENT_LINE $0000 4 CB1 control     CB1 -> NC     0=IRQ on low 1=IRQ on high
COMMENT_LINE $0000 5 \
COMMENT_LINE $0000 6  > CB2 control  CB2 -> /BLANK 110=low 111=high
COMMENT_LINE $0000 7 /
COMMENT $0000 VIA interrupt flags register
COMMENT_LINE $0000 bit                             cleared by
COMMENT_LINE $0000 0 CA2 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 1 CA1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 2 shift register interrupt flag reading or writing shift register
COMMENT_LINE $0000 3 CB2 interrupt flag            reading or writing port B I/O
COMMENT_LINE $0000 4 CB1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 5 timer 2 interrupt flag        read t2 low or write t2 high
COMMENT_LINE $0000 6 timer 1 interrupt flag        read t1 count low or write t1 high
COMMENT_LINE $0000 7 IRQ status flag               write logic 0 to IER or IFR bit
COMMENT $0000 VIA interrupt enable register
COMMENT_LINE $0000 0 CA2 interrupt enable
COMMENT_LINE $0000 1 CA1 interrupt enable
COMMENT_LINE $0000 2 shift register interrupt enable
COMMENT_LINE $0000 3 CB2 interrupt enable
COMMENT_LINE $0000 4 CB1 interrupt enable
COMMENT_LINE $0000 5 timer 2 interrupt enable
COMMENT_LINE $0000 6 timer 1 interrupt enable
COMMENT_LINE $0000 7 IER set/clear control
COMMENT $0000 VIA port A data I/O register (no handshaking)
COMMENT $0000 count y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 count scale y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 count y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 count scale y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 pattern y x pattern y x ... $01
COMMENT $0000 pattern y x pattern y x ... $01
COMMENT $0000 scale pattern y x pattern y x ... $01
COMMENT $0000 pattern y x pattern y x ... $01
COMMENT $0000 pattern y x pattern y x ... $01
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 y x y x ...
COMMENT $0000 mode y x mode y x ... $01
COMMENT $0000 never used by GCE carts?
COMMENT $0000 30 cycles
COMMENT $0000 25 cycles
COMMENT $0000 20 cycles
COMMENT $0000 12 cycles
COMMENT $0000 5*B + 10 cycles
COMMENT $0000 5 cycles
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 /BLANK low and /ZERO low
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 like BIOS, but Macro
COMMENT $0000 Store intensity in D/A
COMMENT $0000 Save intensity in $C827
COMMENT $0000 mux disabled channel 2
COMMENT $0000 mux enabled channel 2
COMMENT $0000 do it again just because ?
COMMENT $0000 turn off mux
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 like BIOS, but Macro
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 optimzed
COMMENT $0000 Store intensity in D/A
COMMENT $0000 mux disabled channel 2
COMMENT $0000 mux enabled channel 2
COMMENT $0000 turn off mux
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 optimzed
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 move to time 1 lo, this means scaling
COMMENT $0000 move to time 1 lo, this means scaling
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 scale for placing first point
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 This is the single most important variable...
COMMENT_LINE $0000 for different sample frequency, THIS must be adjusted...
COMMENT_LINE $0000 140 for 8KHz samples
COMMENT_LINE $0000 330 for 4KHz samples
COMMENT_LINE $0000 700 for 2KHz samples
COMMENT_LINE $0000 1400 for 1KHz samples
COMMENT_LINE $0000 ...
COMMENT_LINE $C9AC ***************************************************************************
COMMENT_LINE $C9AC this sets VIA B to our known sample state...
COMMENT_LINE $C9AC Kills A
COMMENT $0000 name of macro
COMMENT $0000 load the calculated VIA B
COMMENT $0000 write back to reg B in 6522
COMMENT $0000 end of macro
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 this calculates our sample state for VIA B
COMMENT_LINE $0000 Kills A
COMMENT $0000 name of macro
COMMENT $0000 data reg B from 6522
COMMENT $0000 save top 5 bits, mask off bottom 3
COMMENT $0000 set S/H, SEL 0, SEL 1
COMMENT $0000 and remember it
COMMENT $0000 end of macro
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 this is a waiter, for our current sample-byte to finnish
COMMENT_LINE $0000 Kills D
COMMENT $0000 name of macro
COMMENT $0000 get timer
COMMENT_LINE $0000 note:
COMMENT_LINE $0000 by reading the timer we
COMMENT_LINE $0000 can MISS an interrupt state
COMMENT_LINE $0000 since reading clears the
COMMENT_LINE $0000 interrupt!
COMMENT_LINE $0000 during recalibration this
COMMENT_LINE $0000 is considered (see below)
COMMENT_LINE $0000 hopefully we have NO
COMMENT_LINE $0000 interrupt miss here!
COMMENT $0000 and compare to next
COMMENT_LINE $0000 time we should update
COMMENT $0000 not yet? than test again
COMMENT $0000 note:
COMMENT_LINE $0000 if this thing is called early enough
COMMENT_LINE $0000 we could calculate this above
COMMENT_LINE $0000 and save some cycles here!
COMMENT_LINE $0000 on the other hand, IF we are called early
COMMENT_LINE $0000 enough... we don't need to save cycles :-)
COMMENT $0000 and store it
COMMENT $0000 end of macro
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 get timer
COMMENT $0000 and store it
COMMENT $0000 load the next sample_byte to A
COMMENT $0000 store in reg A in 6522 (DAC)
COMMENT $0000 this sets the MUX of 6522 to PSG
COMMENT $0000 Clear shift regigster, why ???
COMMENT $0000 and disable the mux, so no junk will
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 this outputs a sample if one is in the queue
COMMENT_LINE $0000 otherwise not,
COMMENT_LINE $0000 not testing if sample is active!
COMMENT_LINE $0000 Kills D
COMMENT_LINE $0000 must ALLWAYS have Y the position
COMMENT $0000 name of macro
COMMENT $0000 get timer
COMMENT_LINE $0000 note:
COMMENT_LINE $0000 by reading the timer we
COMMENT_LINE $0000 can MISS an interrupt state
COMMENT_LINE $0000 since reading clears the
COMMENT_LINE $0000 interrupt!
COMMENT_LINE $0000 during recalibration this
COMMENT_LINE $0000 is considered (see belowe)
COMMENT_LINE $0000 hopefully we have NO
COMMENT_LINE $0000 interrupt miss here!
COMMENT $0000 and compare to next
COMMENT_LINE $0000 time we should update
COMMENT $0000 not yet? than test again
COMMENT $0000 note:
COMMENT_LINE $0000 if this thing is called early enough
COMMENT_LINE $0000 we could calculate this above
COMMENT_LINE $0000 and save some cycles here!
COMMENT_LINE $0000 on the other hand, IF we are called early
COMMENT_LINE $0000 enough... we don't need to save cycles :-)
COMMENT $0000 and store it
COMMENT $0000 load the next sample_byte to A
COMMENT_LINE $0000 and store it to the 6522 -> PSG
COMMENT $0000 store in reg A in 6522 (DAC)
COMMENT_LINE $0000 following must come after the above, or we
COMMENT_LINE $0000 put noise to the psg,
COMMENT_LINE $0000 likewise, before storing anything else to
COMMENT_LINE $0000 port A, we will disable the connection to PSG
COMMENT $0000 this sets the MUX of 6522 to PSG
COMMENT $0000 Clear shift regigster, why ???
COMMENT_LINE $0000 without it, the display 'wobbles' a bit???
COMMENT $0000 and disable the mux, so no junk will
COMMENT_LINE $0000 enter our PSG-DAC...
COMMENT $0000 end of macro
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 Kills D
COMMENT_LINE $0000 not testing if sample is active!
COMMENT_LINE $0000 must ALLWAYS have Y the position
COMMENT $0000 name of macro
COMMENT $0000 wait till the last played
COMMENT_LINE $0000 sample-byte is finnished
COMMENT $0000 load the next sample_byte to A
COMMENT_LINE $0000 and store it to the 6522 -> PSG
COMMENT $0000 store in reg A in 6522 (DAC)
COMMENT_LINE $0000 following must come after the above, or we
COMMENT_LINE $0000 put noise to the psg,
COMMENT_LINE $0000 likewise, before storing anything else to
COMMENT_LINE $0000 port A, we will disable the connection to PSG
COMMENT $0000 this sets the MUX of 6522 to PSG
COMMENT $0000 Clear shift regigster, why ???
COMMENT_LINE $0000 without it, the display 'wobbles' a bit???
COMMENT $0000 and disable the mux, so no junk will
COMMENT_LINE $0000 enter our PSG-DAC...
COMMENT $0000 end of macro
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 First do output a sample ... and than MOVE to D
COMMENT $0000 save the position
COMMENT $0000 play one sample_byte
COMMENT $0000 restore position
COMMENT $0000 Store Y in D/A register
COMMENT $0000 Blank low, zero high?
COMMENT $0000 Enable mux
COMMENT $0000 Clear shift regigster
COMMENT $0000 Disable mux
COMMENT $0000 Store X in D/A register
COMMENT $0000 enable timer
COMMENT $0000 t1 flag
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 exactly 60 with 1 loop (scale minimum 10)
COMMENT_LINE $0000 scale 50 uses 60 + 45 -> 105 cycles
COMMENT_LINE $0000 loop 1: 4 + 5 = 9 (branched)
COMMENT_LINE $0000 loop END 1: 4 + 3 = 7 (not branched)
COMMENT_LINE $0000 loop 1: 3 + (4 + 5) * 0 + 4 + 3 = 10 (scale)
COMMENT_LINE $0000 loop 2: 3 + (4 + 5) * 1 + 4 + 3 = 19
COMMENT_LINE $0000 loop 3: 3 + (4 + 5) * 2 + 4 + 3 = 28
COMMENT_LINE $0000 loop 4: 3 + (4 + 5) * 3 + 4 + 3 = 37
COMMENT_LINE $0000 loop 5: 3 + (4 + 5) * 4 + 4 + 3 = 46
COMMENT_LINE $0000 loop 6: 3 + (4 + 5) * 5 + 4 + 3 = 55
COMMENT_LINE $0000 minimum 1 loop = 3 + 4 + 3 = 10 -> minimum scale possible = 10
COMMENT_LINE $0000 -> per additional loop + 7
COMMENT $0000 Send Y to A/D
COMMENT $0000 Enable mux switched
COMMENT $0000 Point to next coordinate pair X=X+2
COMMENT $0000 Wait a moment
COMMENT $0000 Disable mux
COMMENT $0000 Send X to A/D
COMMENT $0000 Shift reg=$FF (solid line), T1H=0
COMMENT $0000 Put pattern in shift register
COMMENT $0000 Set T1H (scale factor), enabling t1
COMMENT $0000 B-reg = T1 interrupt bit
COMMENT $0000 Clear shift register (blank output)
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 not testing whether sample is active!
COMMENT_LINE $0000 output first line without testing for end
COMMENT $0000 Load Y, X to D
COMMENT $0000 put Y to DAC
COMMENT $0000 MUX Y
COMMENT $0000 get pattern
COMMENT $0000 un MUX (X allways set)
COMMENT $0000 put X to DAC
COMMENT $0000 set pattern
COMMENT $0000 start timer
COMMENT_LINE $0000 do some work in timer waiting
COMMENT $0000 increase X by 3
COMMENT $0000 load next pattern
COMMENT $0000 if one(!) - branch
COMMENT_LINE $0000 now digit stuff
COMMENT_LINE $0000 testing for timer...
COMMENT $0000 get timer
COMMENT $0000 and compare to next
COMMENT $0000 load zero and timer interrupt bit
COMMENT $0000 loop till timer interrupt bit set
COMMENT $0000 pattern to OFF
COMMENT $0000 and go on with next vector
COMMENT $0000 note:
COMMENT $0000 and store it
COMMENT $0000 load zero and timer interrupt bit
COMMENT $0000 loop till timer interrupt bit set
COMMENT $0000 pattern to OFF
COMMENT_LINE $0000 now play next sample
COMMENT $0000 load the next sample_byte to A
COMMENT $0000 store in reg A in 6522 (DAC)
COMMENT $0000 this sets the MUX of 6522 to PSG
COMMENT $0000 Clear shift regigster, why ???
COMMENT $0000 and disable the mux, so no junk will
COMMENT $0000 and go on with next vector
COMMENT $0000 load zero and timer interrupt bit
COMMENT $0000 loop till timer interrupt bit set
COMMENT $0000 pattern to OFF
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 not testing whether sample is active!
COMMENT_LINE $0000 output first line without testing for end
COMMENT $0000 load # of lines in this list
COMMENT $0000 Load Y, X to D
COMMENT $0000 put Y to DAC
COMMENT $0000 MUX Y
COMMENT $0000 un MUX (X allways set)
COMMENT $0000 put X to DAC
COMMENT $0000 set pattern
COMMENT $0000 start timer
COMMENT_LINE $0000 do some work in timer waiting
COMMENT $0000 if 0 - branch
COMMENT_LINE $0000 now digit stuff
COMMENT_LINE $0000 testing for timer...
COMMENT $0000 get timer
COMMENT $0000 and compare to next
COMMENT $0000 load zero and timer interrupt bit
COMMENT $0000 loop till timer interrupt bit set
COMMENT $0000 pattern to OFF
COMMENT $0000 and go on with next vector
COMMENT $0000 note:
COMMENT $0000 and store it
COMMENT $0000 load zero and timer interrupt bit
COMMENT $0000 loop till timer interrupt bit set
COMMENT $0000 pattern to OFF
COMMENT_LINE $0000 now play next sample
COMMENT $0000 load the next sample_byte to A
COMMENT $0000 store in reg A in 6522 (DAC)
COMMENT $0000 this sets the MUX of 6522 to PSG
COMMENT $0000 Clear shift regigster, why ???
COMMENT $0000 and disable the mux, so no junk will
COMMENT $0000 and go on with next vector
COMMENT $0000 load zero and timer interrupt bit
COMMENT $0000 loop till timer interrupt bit set
COMMENT $0000 pattern to OFF
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 Kills D
COMMENT_LINE $0000 must ALLWAYS have Y the position
COMMENT $0000 name of macro
COMMENT $0000 is there a digital sample to be played?
COMMENT $0000 no, than jump out of here
COMMENT $0000 otherwise we wait till the last played
COMMENT_LINE $0000 sample-byte is finnished
COMMENT $0000 load the next sample_byte to A
COMMENT $0000 with this sample, otherwise we continue further below
COMMENT $0000 is this sample a looping one?
COMMENT $0000 store it to is_playing
COMMENT $0000 if none looping... we are done
COMMENT_LINE $0000 JSR     switch_to_ym
COMMENT $0000 if none looping... we are done
COMMENT $0000 store new start position
COMMENT $0000 calculate end position
COMMENT $0000 and store it
COMMENT_LINE $0000 ok, for restart, we only change current position
COMMENT $0000 load the start position
COMMENT_LINE $0000 this is the end_position of the sample,
COMMENT_LINE $0000 since we go backwards
COMMENT $0000 next byte
COMMENT_LINE $0000 is played next round...
COMMENT_LINE $0000 and store it to the 6522 -> PSG
COMMENT $0000 store in reg A in 6522 (DAC)
COMMENT_LINE $0000 following must come after the above, or we
COMMENT_LINE $0000 put noise to the psg,
COMMENT_LINE $0000 likewise, before storing anything else to
COMMENT_LINE $0000 port A, we will disable the connection to PSG
COMMENT $0000 this sets the MUX of 6522 to PSG
COMMENT $0000 Clear shift regigster, why ???
COMMENT_LINE $0000 without it, the display 'wobbles' a bit???
COMMENT $0000 and disable the mux, so no junk will
COMMENT_LINE $0000 enter our PSG-DAC...
COMMENT $0000 end of macro
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 Kills D
COMMENT_LINE $0000 must ALLWAYS have Y the position
COMMENT $0000 name of macro
COMMENT $0000 is there a digital sample to be played?
COMMENT $0000 no, than jump out of here
COMMENT $0000 load the next sample_byte to A
COMMENT $0000 with this sample, otherwise we continue further below
COMMENT $0000 is this sample a looping one?
COMMENT $0000 store it to is_playing
COMMENT $0000 if none looping... we are done
COMMENT_LINE $0000 JSR     switch_to_ym
COMMENT $0000 if none looping... we are done
COMMENT $0000 store new start position
COMMENT $0000 calculate end position
COMMENT $0000 and store it
COMMENT_LINE $0000 ok, for restart, we only change current position
COMMENT $0000 load the start position
COMMENT_LINE $0000 this is the end_position of the sample,
COMMENT_LINE $0000 since we go backwards
COMMENT $0000 next byte
COMMENT_LINE $0000 is played next round...
COMMENT_LINE $0000 and store it to the 6522 -> PSG
COMMENT $0000 store in reg A in 6522 (DAC)
COMMENT_LINE $0000 following must come after the above, or we
COMMENT_LINE $0000 put noise to the psg,
COMMENT_LINE $0000 likewise, before storing anything else to
COMMENT_LINE $0000 port A, we will disable the connection to PSG
COMMENT $0000 this sets the MUX of 6522 to PSG
COMMENT $0000 Clear shift regigster, why ???
COMMENT_LINE $0000 without it, the display 'wobbles' a bit???
COMMENT $0000 and disable the mux, so no junk will
COMMENT_LINE $0000 enter our PSG-DAC...
COMMENT $0000 end of macro
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 uses 0 cycles
COMMENT_LINE $0000 (in relation to the last done digital output)
COMMENT_LINE $0000 a wait_recal routine for the sample... output
COMMENT $0000 go to waiting
COMMENT $0000 and store it
COMMENT $0000 play a sample directly, but with test
COMMENT $0000 load timer
COMMENT $0000 interrupt_miss
COMMENT $0000 otherwise look if we should play a sample
COMMENT $0000 yep... do it than
COMMENT $0000 otherwise... did an inerrupt occur?
COMMENT $0000 test for interrupt
COMMENT $0000 if no interrupt keep on testing
COMMENT $0000 Store refresh value
COMMENT $0000 into timer t2
COMMENT $0000 next sample output timer
COMMENT $0000 store it
COMMENT_LINE $0000 note: for low sample rates
COMMENT_LINE $0000 we could use a normal MOVE
COMMENT_LINE $0000 and save probably
COMMENT_LINE $0000 a thousand or more cycles!
COMMENT_LINE $0000 since THIS MOVE first
COMMENT_LINE $0000 outputs an sample!
COMMENT_LINE $0000 (which also means waiting for the sample)
COMMENT $0000 set the fixed scale factor we will use...
COMMENT $0000 move to time 1 lo, this means scaling
COMMENT $0000 load the next pos, super long saturation
COMMENT $0000 move to d -> must be achieved
COMMENT $0000 blank low and zero low
COMMENT $0000 load the next pos, super long saturation
COMMENT $0000 move to d -> must be achieved
COMMENT $0000 /BLANK low and /ZERO low
COMMENT $0000 mux=1, disable mux
COMMENT $0000 clear D/A register
COMMENT $0000 mux=1, enable mux
COMMENT $0000 do it again
COMMENT $0000 disable mux
COMMENT $0000 rethink our VIAB value
COMMENT $0000 and do one sample-byte
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 expects struct in X
COMMENT_LINE $0000 sets up Y register, this should under no circumstances be destroyed
COMMENT $0000 store new start position
COMMENT $0000 calculate end position
COMMENT $0000 and store it
COMMENT $0000 sound is playing is ON
COMMENT $0000 sound is playing
COMMENT $0000 calculate out first VIA B poke
COMMENT $0000 initialize Y to position in sample data
COMMENT $0000 Clear_Sound
COMMENT $0000 load timer
COMMENT $0000 and store it
COMMENT_LINE $0000 JSR     switch_to_digit
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 This can be used to test a position if a sample should be played
COMMENT_LINE $0000 or not. Comes handy to test if routines use aprox. to many
COMMENT_LINE $0000 cycles and to insert a 'play next digit' call...
COMMENT_LINE $0000 Kills D
COMMENT_LINE $0000 uses DVE special features
COMMENT $0000 name of macro
COMMENT $0000 is there a digital sample to be played?
COMMENT $0000 no, than jump out of here
COMMENT $0000 get timer
COMMENT $0000 and compare to next
COMMENT $0000 not yet? than test again
COMMENT $0000 end of macro
COMMENT $C9AC init via save
COMMENT $C9AD 1 = true, 0 = false
COMMENT $C9AE next timer cycle we should play next sample
COMMENT_LINE $C9B0 timer loaded for recalibration with
COMMENT_LINE $C9B0 30000 -> 50Hz update
COMMENT_LINE $C9B0 gets counted backword by VIA
COMMENT_LINE $C9B0 so after recalibration the next
COMMENT_LINE $C9B0 sample will be played
COMMENT_LINE $C9B0 at (30000 - T2_TIMER_PEROID_REAL)
COMMENT_LINE $C9B0 asking the timer about its value is
COMMENT_LINE $C9B0 done in WAIT_FOR_NEXT_DIGIT
COMMENT_LINE $C9B0 missing a few cycles doesn't really matter
COMMENT_LINE $C9B0 BAD is that VIA counter has different
COMMENT_LINE $C9B0 endianess, so we waste cycles EXGing...
COMMENT $C9B0 position of sample structure
COMMENT $C9B2 current position in sample structure
COMMENT $C9B4 this is the start position of the sample, since we play it backwards
COMMENT $C9B6 start position of samples
COMMENT_LINE $C9BA all stuff contained here is public domain (?)
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 done
COMMENT_LINE $0000 ***************************************************************************
COMMENT $0000 this divides d by 64
COMMENT $0000 result in A
COMMENT $0000 done
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $C9BA (the bigger the number, the faster one walks)
COMMENT_LINE $C9BA (the smaller the number, the further one can look)
COMMENT_LINE $C9BA (the bigger the number, the bigger the maze)
COMMENT_LINE $C9BA simple defintions
COMMENT_LINE $C9BA maze sizes, corresponding to data!!!
COMMENT_LINE $C9BA following MUST not be changed!!! (anymore)
COMMENT_LINE $C9BA since divide routines use binary arithmetic and assume
COMMENT_LINE $C9BA some sizes HARDCODED!!! (like WALL_SIZE, STEPS, DOUBLE_STEP...)
COMMENT_LINE $C9BA is easyly divideable by 16
COMMENT_LINE $C9BA $30 is not to small, but a multiple of 16
COMMENT_LINE $C9BA which is very good for sprite sizes for clipping!
COMMENT_LINE $C9BA due to 8 bit arithmetic (gets negative...)
COMMENT_LINE $C9BA -> Position must be SQUARE_SIZE, -SQUARE_SIZE
COMMENT_LINE $C9BA Wall MUST be smaller than Square
COMMENT_LINE $C9BA max = $7f due to 8 bit arithmetic (gets negative...)
COMMENT_LINE $C9BA ***************************************************************************
COMMENT_LINE $C9BA double step is 192
COMMENT_LINE $C9BA 192/2 = 96
COMMENT_LINE $C9BA 96 /2 = 48
COMMENT_LINE $C9BA 48 /2 = 24
COMMENT_LINE $C9BA 24 /2 = 12
COMMENT_LINE $C9BA 12 /2 = 6
COMMENT_LINE $C9BA 6 /2 = 3
COMMENT_LINE $C9BA using this macro instead of a regular DIV - > saves sometimes
COMMENT_LINE $C9BA (depending on div) per use up to 1000 cycles !!!
COMMENT $0000 UNSIGNED
COMMENT $0000 this is a divider 3
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $0000 roll in carry
COMMENT $C9BA calculated stepping in scale, precalculated
COMMENT_LINE $C9BB before maze is drawn
COMMENT $C9BB current intensity of maze frame,
COMMENT_LINE $C9BC decreases the further away from player
COMMENT $C9BC current frame-maze position while drawing the maze
COMMENT $C9BD the first frame is drawn a bit smaller,
COMMENT_LINE $C9BE otherwise we have bright corners in the display
COMMENT_LINE $C9BE this is just a flag to indicate we are drawing
COMMENT_LINE $C9BE the first frame
COMMENT $C9BE used in maze to calculate size of maze
COMMENT $C9C0 used in maze to store a shadow copy of scaling
COMMENT $C9C1 only 3 needed, but with four we can use ASL!
COMMENT_LINE $CA03 ********************************************************************
COMMENT_LINE $CA03 variables used in map displaying
COMMENT_LINE $CA03 ********************************************************************
COMMENT_LINE $CA03 these are redefines from clip_var.i!
COMMENT_LINE $CA03 -> must be AFER the above include,
COMMENT_LINE $CA03 otherwise the assembler doesn't work correctly
COMMENT_LINE $CA03 these are used in the MAP routines, therefor they'll never
COMMENT_LINE $CA03 collide with MAZE information
COMMENT $CA0A 16 Words
COMMENT_LINE $CA2A ********************************************************************
COMMENT $CA2A direction the player is facing
COMMENT_LINE $CA2B ********************************************************************
COMMENT_LINE $CA2B position of player in maze, in display coordinates
COMMENT_LINE $CA2B used in 'input' 'draw_maze'...
COMMENT_LINE $CA2B therefor we only have 'y' coordinates...
COMMENT_LINE $CA2D ********************************************************************
COMMENT_LINE $CA2D the translate_position() subroutines
COMMENT_LINE $CA2D sets the following variables
COMMENT_LINE $CA2D these are the postion in the maze in maze coordinates
COMMENT_LINE $CA2D not in 'display'-coordinates
COMMENT_LINE $CA2F offset in that current position
COMMENT_LINE $CA31 ********************************************************************
COMMENT_LINE $CA31 current 'level' pointer
COMMENT_LINE $CA33 all 'active' monsters in that level
COMMENT_LINE $CA4B only one monster is seen at any given time
COMMENT_LINE $CA4B this monsters attributes will be = here
COMMENT $CA4B 0 x,y, in view coordinates (x max 2), y direction dependent
COMMENT $CA4D 2 x,y_hi,y_lo offset
COMMENT $CA50 5 pointer to above list, only one monster/item is viewable at a time
COMMENT $CA52 7 near to player
COMMENT $CA53 8 movement in player axis
COMMENT $CA54 9 movement in player axis temp
COMMENT_LINE $CA55 these definitions MUST be placed in the source AFTER the
COMMENT_LINE $CA55 above!
COMMENT_LINE $CA55 for each checked monster the axis is calculated before knowing
COMMENT_LINE $CA55 if the monster is the one that is being shown
COMMENT_LINE $CA55 so -> we have to 'temp' the value :-(
COMMENT_LINE $CA55 V_MONSTER_MOVEMENT_AXIS
COMMENT_LINE $CA55 this entry is some cheat for a better/easier display for moving
COMMENT_LINE $CA55 monster is the labyrinth
COMMENT_LINE $CA55 if the movement axis of the monster is the same as the player heading
COMMENT_LINE $CA55 than the (view) x-koordinate (only in clipped right/left view) MUST
COMMENT_LINE $CA55 be = accordingly to the current offset of the monster,
COMMENT_LINE $CA55 otherwise the monster 'jumps' from maze cell to maze cell -> no
COMMENT_LINE $CA55 smooth moving. The clipped vector lists 'moves' in a diagonal along
COMMENT_LINE $CA55 the maze edges
COMMENT_LINE $CA55 on the other hand, if the axis is orthogonal to the player heading...
COMMENT_LINE $CA55 the vector list should be clipped as if the offset was '-STEPS', since
COMMENT_LINE $CA55 otherwise the vector would be clipped in 'empty' space, according
COMMENT_LINE $CA55 to the (now y) offset. The clipping would be done along the diagonal
COMMENT_LINE $CA55 of the maze cells. This looks stupid and wrong. The player
COMMENT_LINE $CA55 can 'sorta' watch till the outer edge of the maze cell -> therefor the
COMMENT_LINE $CA55 monster should also be seen to the outer edge of the maze cell.
COMMENT_LINE $CA55 I couldn't think of hand about an easy way to implement these to different
COMMENT_LINE $CA55 display-types... so I chose for now, to do just a hack and
COMMENT_LINE $CA55 have a switch, which kind of display is the current active one...
COMMENT_LINE $CA55 only one item is seen at any given time
COMMENT_LINE $CA55 this items attributes will be = here
COMMENT $CA55 x,y in view coordinates (x max 2), y direction dependent
COMMENT $CA57 x,y offset
COMMENT $CA59 pointer, only one item/monster is viewable at a time
COMMENT_LINE $0000 ***************************************************************************
COMMENT_LINE $0000 start of vectrex memory with cartridge name...
COMMENT $0000 'g' is copyright sign
COMMENT $000B music from the rom
COMMENT $000D hight, width, rel y, rel x (from 0,0)
COMMENT $0011 some game information, ending with $80
COMMENT $001F hight, width, rel y, rel x (from 0,0)
COMMENT $0023 some game information, ending with $80
COMMENT $002A end of game header
COMMENT_LINE $002B ***************************************************************************
COMMENT_LINE $002B here the cartridge program starts off
COMMENT $002B pretty for optimizing to use a makro :-)
COMMENT_LINE $002D ***************************************************************************
COMMENT $002E initialize game variables
FORCE_SYMBOL $002E init_vars
COMMENT $0031 startup screen
FORCE_SYMBOL $0031 init_screen
FORCE_SYMBOL $0034 SONG_DATA
FORCE_SYMBOL $0037 init_ym_sound
FORCE_SYMBOL $003A maze1
FORCE_SYMBOL $003D init_level
COMMENT_LINE $0040 conceptional thoughts
COMMENT_LINE $0040 two main routines, they do exactly the same, apart from
COMMENT_LINE $0040 -one is playing an ym file
COMMENT_LINE $0040 -the other plays a digital sample
FORCE_SYMBOL $0040 Read_Btns
FORCE_SYMBOL $0043 Wait_Recal
FORCE_SYMBOL $0046 handle_input
FORCE_SYMBOL $0049 digit_is_playing
FORCE_SYMBOL $0050 Vec_Buttons
COMMENT $0053 is a button pressed?
FORCE_NO_SYMBOL $0053
FORCE_SYMBOL $0059 translate_position
FORCE_SYMBOL $005C update_map
FORCE_SYMBOL $005F update_monsters
COMMENT $0062 also draws monster if one is viewable
FORCE_SYMBOL $0062 draw_maze
FORCE_SYMBOL $0065 do_ym_sound
COMMENT $0068 go back to main loop
FORCE_SYMBOL $006A Read_Btns
FORCE_SYMBOL $006D wait_recal_digit
FORCE_SYMBOL $0070 digit_is_playing
FORCE_SYMBOL $0075 handle_input_digit
FORCE_SYMBOL $0078 Vec_Buttons
COMMENT $007B is a button pressed?
FORCE_NO_SYMBOL $007B
FORCE_SYMBOL $0081 translate_position
FORCE_SYMBOL $0084 update_map
FORCE_SYMBOL $0087 update_monsters
COMMENT $008A also draws monster if one is viewable
FORCE_SYMBOL $008A draw_maze_digit
COMMENT $008D go back to main loop
COMMENT_LINE $008F ***************************************************************************
COMMENT $008F following code uses d0
COMMENT $008F Store Y in D/A register
FORCE_SYMBOL $008F VIA_port_a
COMMENT $0091 Blank low, zero high?
FORCE_NO_SYMBOL $0091
FORCE_SYMBOL $0093 VIA_cntl
COMMENT $0096 Enable mux
FORCE_SYMBOL $0096 VIA_port_b
COMMENT $0098 Clear shift regigster
FORCE_SYMBOL $0098 VIA_shift_reg
COMMENT $009A Disable mux
FORCE_SYMBOL $009A VIA_port_b
COMMENT $009C Store X in D/A register
FORCE_SYMBOL $009C VIA_port_a
COMMENT $009E enable timer
FORCE_SYMBOL $009E VIA_t1_cnt_hi
FORCE_NO_SYMBOL $00A0
FORCE_SYMBOL $00A2 VIA_int_flags
COMMENT_LINE $00A7 ***************************************************************************
COMMENT_LINE $00A7 update all monsters, according to their behavour
COMMENT_LINE $00A7 the neareast visible, will be = to be visible to the
COMMENT_LINE $00A7 player!
COMMENT_LINE $00A7 animation will be = accordingly
COMMENT_LINE $00A7 default is no view monster
FORCE_SYMBOL $00A7 NO_MONSTER
FORCE_SYMBOL $00AA V_MONSTER_POSITION
FORCE_SYMBOL $00AD FAR_AWAY
COMMENT $00AF first near is very big
FORCE_SYMBOL $00AF V_MONSTER_NEARNESS
COMMENT_LINE $00B2 go thru all monsters
FORCE_SYMBOL $00B2 current_monster_list
COMMENT $00B5 zero position denotes no monsters left
FORCE_SYMBOL $00B5 C_MONSTER_POSITION
COMMENT $00B7 jump outa here than
COMMENT $00BB movement type
FORCE_SYMBOL $00BB C_MONSTER_MOVEMENT_TYPE
COMMENT $00BD NOT_MOVING = 0
COMMENT_LINE $00BF todo
COMMENT $00BF only implemented moving type
FORCE_SYMBOL $00BF PATROLING_X
COMMENT_LINE $00C3 X Patroling
COMMENT_LINE $00C3 temporary calculate the movement axis
COMMENT_LINE $00C3 we don't know yet if this monster is the one
COMMENT_LINE $00C3 that is being shown :-(
COMMENT $00C3 looking west?
FORCE_SYMBOL $00C3 look_direction
COMMENT $00C6 checking for same or
FORCE_SYMBOL $00C6 WEST
COMMENT $00C8 orthogonal axis
COMMENT $00CA x == WEST and EAST
FORCE_SYMBOL $00CA EAST
COMMENT $00CC no? than not same axis
COMMENT $00CE something different than 0
FORCE_NO_SYMBOL $00CE
FORCE_SYMBOL $00D0 V_MONSTER_MOVEMENT_AXIS_TEMP
COMMENT $00D3 axis stuff done
COMMENT $00D5 not same axis -> == 0
FORCE_SYMBOL $00D5 V_MONSTER_MOVEMENT_AXIS_TEMP
COMMENT $00D8 get monster definition pointer
FORCE_SYMBOL $00D8 C_MONSTER_DEFINITION
COMMENT $00DA get the speed if it
FORCE_SYMBOL $00DA M_MONSTER_MOVEMENT_SPEED
COMMENT $00DC ... and its heading
FORCE_SYMBOL $00DC C_MONSTER_HEADING
COMMENT $00DE going positive (east)? yep? -> jump
COMMENT_LINE $00E0 negative heading
COMMENT $00E0 negate speed for heading west
COMMENT $00E1 calculate new X offset
FORCE_SYMBOL $00E1 C_MONSTER_X_OFFSET
COMMENT $00E3 moving to next maze cell?
COMMENT $00E5 no -> jump
COMMENT $00E7 offset to beginning of next cell
COMMENT $00EB and move to next cell
FORCE_SYMBOL $00EB C_MONSTER_X
COMMENT $00ED heading west -> decrease maze pointer
COMMENT $00EE patroling done in that direction?
FORCE_SYMBOL $00EE M_MONSTER_FROM_X
COMMENT $00F0 no -> jump
COMMENT $00F2 otherwise... reverse patroling direction (heading)
FORCE_SYMBOL $00F2 C_MONSTER_HEADING
COMMENT $00F4 and done with turning
FORCE_SYMBOL $00F6 C_MONSTER_X
COMMENT $00F8 and new offset also
FORCE_SYMBOL $00F8 C_MONSTER_X_OFFSET
COMMENT $00FA done with moving this monster
COMMENT_LINE $00FC in a speed to add to offset
COMMENT $00FC calculate new X offset
FORCE_SYMBOL $00FC C_MONSTER_X_OFFSET
COMMENT $00FE moving to next maze cell?
FORCE_SYMBOL $00FE STEPS
COMMENT $0100 no -> jump
COMMENT $0102 offset to beginning of next cell
COMMENT $0106 and move to next cell
FORCE_SYMBOL $0106 C_MONSTER_X
COMMENT $0108 heading east -> increase maze pointer
COMMENT $0109 patroling done in that direction?
FORCE_SYMBOL $0109 M_MONSTER_TO_X
COMMENT $010B no -> jump
COMMENT $010D otherwise... reverse patroling direction (heading)
FORCE_SYMBOL $010D C_MONSTER_HEADING
COMMENT $010F and done with turning
FORCE_SYMBOL $0111 C_MONSTER_X
COMMENT $0113 and new offset also
FORCE_SYMBOL $0113 C_MONSTER_X_OFFSET
COMMENT $0115 done with moving this monster
COMMENT_LINE $0117 moving not done yet
COMMENT $0117 done with all moving... (todo)
COMMENT_LINE $0119 look if monster is in display view
COMMENT_LINE $0119 that is only space allowed between player and monster
COMMENT $0119 looking west?
FORCE_SYMBOL $0119 look_direction
FORCE_SYMBOL $011C WEST
COMMENT $011E no->jump
COMMENT $0120 x position of monster
FORCE_SYMBOL $0120 C_MONSTER_X
COMMENT $0122 is it in front of us?
FORCE_SYMBOL $0122 pos_x
COMMENT $0125 no->jump
COMMENT $0129 y position of monster
FORCE_SYMBOL $0129 C_MONSTER_Y
COMMENT $012B is it -1, 0 , 1 from us?
FORCE_SYMBOL $012C pos_y
COMMENT $012F no, further away -> jump
FORCE_SYMBOL $0135 pos_y
COMMENT $0138 no, further away -> jump
COMMENT_LINE $013C monster is in front and in our view corridor
COMMENT_LINE $013C but is it nearer than last found monster?
FORCE_SYMBOL $013C pos_x
FORCE_SYMBOL $013F C_MONSTER_X
FORCE_SYMBOL $0141 V_MONSTER_NEARNESS
COMMENT $0144 no, not nearer -> jump
COMMENT_LINE $0148 now init view of monster
COMMENT_LINE $0148 translate its position to view position
COMMENT_LINE $0148 and store it
COMMENT $0148 view monster pointer
FORCE_SYMBOL $0148 view_monster
FORCE_SYMBOL $014B pos_y
COMMENT $014E view x pos
COMMENT $0150 x position of monster
FORCE_SYMBOL $0150 C_MONSTER_X
COMMENT $0155 view y pos
COMMENT $0157 x, y offset of monster
FORCE_SYMBOL $0157 C_MONSTER_OFFSET
COMMENT $015C view x offset
COMMENT $015F view y offset
COMMENT $0161 current structure information
FORCE_SYMBOL $0163 pos_x
FORCE_SYMBOL $0166 C_MONSTER_X
COMMENT $0168 near to player
FORCE_NO_SYMBOL $0168
FORCE_SYMBOL $016A V_MONSTER_MOVEMENT_AXIS_TEMP
FORCE_SYMBOL $016D V_MONSTER_MOVEMENT_AXIS
FORCE_SYMBOL $0170 this_monster_done
COMMENT $0173 facing east?
FORCE_SYMBOL $0173 EAST
COMMENT $0175 no - jump
COMMENT $0177 x position of monster
FORCE_SYMBOL $0177 C_MONSTER_X
COMMENT $0179 if monster behind or 'on' us
FORCE_SYMBOL $0179 pos_x
COMMENT $017C jump
COMMENT $0180 y position of monster
FORCE_SYMBOL $0180 C_MONSTER_Y
COMMENT $0182 is in up, here, or down space
COMMENT $0183 of vision?
FORCE_SYMBOL $0183 pos_y
COMMENT $0186 no goto next monster
FORCE_SYMBOL $018C pos_y
COMMENT $018F no goto next monster
COMMENT_LINE $0193 now init view of monster
COMMENT $0193 get monster position
FORCE_SYMBOL $0193 C_MONSTER_X
COMMENT $0195 and build abs 'difference'
FORCE_SYMBOL $0195 pos_x
COMMENT $0198 if 'nearer' accept new monster
FORCE_SYMBOL $0198 V_MONSTER_NEARNESS
COMMENT $019B otherwise go on looking
COMMENT_LINE $019F now init view of monster
COMMENT_LINE $019F translate its position to view position
COMMENT_LINE $019F and store it
COMMENT $019F x position of monster
FORCE_SYMBOL $019F C_MONSTER_X
FORCE_SYMBOL $01A1 view_monster
FORCE_SYMBOL $01A5 pos_y
COMMENT $01A8 view x pos
COMMENT $01AA view y pos
COMMENT $01AC x, y offset of monster
FORCE_SYMBOL $01AC C_MONSTER_OFFSET
COMMENT $01B0 view x offset
COMMENT $01B4 view y offset
FORCE_SYMBOL $01B8 pos_x
FORCE_SYMBOL $01BB C_MONSTER_X
COMMENT $01BD near to player
FORCE_NO_SYMBOL $01BD
FORCE_SYMBOL $01BF V_MONSTER_MOVEMENT_AXIS_TEMP
FORCE_SYMBOL $01C2 V_MONSTER_MOVEMENT_AXIS
FORCE_SYMBOL $01C5 this_monster_done
COMMENT $01C8 facing south?
FORCE_SYMBOL $01C8 SOUTH
COMMENT $01CA na->jump
COMMENT $01CC y position of monster
FORCE_SYMBOL $01CC C_MONSTER_Y
COMMENT $01CE is it behind us?
FORCE_SYMBOL $01CE pos_y
COMMENT $01D1 yep->jump
COMMENT_LINE $01D5 look if monster is in display view
COMMENT_LINE $01D5 that is only space allowed between player and monster
COMMENT $01D5 x position of monster
FORCE_SYMBOL $01D5 C_MONSTER_X
COMMENT $01D7 checking for +-1 view corridor
COMMENT $01D8 (-1)
FORCE_SYMBOL $01D8 pos_x
COMMENT $01DB not it corridor->jump
COMMENT $01DE (+1)
FORCE_SYMBOL $01DF pos_x
COMMENT $01E2 not it corridor->jump
COMMENT_LINE $01E4 now init view of monster
COMMENT $01E4 get monster position
FORCE_SYMBOL $01E4 C_MONSTER_Y
COMMENT $01E6 and build abs 'difference'
FORCE_SYMBOL $01E6 pos_y
COMMENT $01E9 if 'nearer' accept new monster
FORCE_SYMBOL $01E9 V_MONSTER_NEARNESS
COMMENT $01EC otherwise go on looking
COMMENT_LINE $01EE now init view of monster
COMMENT_LINE $01EE translate its position to view position
COMMENT_LINE $01EE and store it
COMMENT $01EE y position of monster
FORCE_SYMBOL $01EE C_MONSTER_Y
FORCE_SYMBOL $01F0 view_monster
FORCE_SYMBOL $01F3 pos_x
COMMENT $01F6 view x pos
COMMENT $01F8 view y pos
COMMENT $01FA x, y offset of monster
FORCE_SYMBOL $01FA C_MONSTER_OFFSET
COMMENT $01FD view x offset
COMMENT $0200 view y offset
FORCE_SYMBOL $0204 C_MONSTER_Y
FORCE_SYMBOL $0206 pos_y
COMMENT $0209 near to player
FORCE_NO_SYMBOL $0209
FORCE_SYMBOL $020B V_MONSTER_MOVEMENT_AXIS_TEMP
FORCE_SYMBOL $020E V_MONSTER_MOVEMENT_AXIS
COMMENT $0213 y position of monster
FORCE_SYMBOL $0213 C_MONSTER_Y
COMMENT $0215 is monster behind us?
FORCE_SYMBOL $0215 pos_y
COMMENT $0218 yep->jump
COMMENT_LINE $021A look if monster is in display view
COMMENT_LINE $021A that is only space allowed between player and monster
COMMENT $021A x position of monster
FORCE_SYMBOL $021A C_MONSTER_X
COMMENT $021C checking for +-1 view corridor
COMMENT $021D (+1)
FORCE_SYMBOL $021D pos_x
COMMENT $0220 not it corridor->jump
COMMENT $0223 (-1)
FORCE_SYMBOL $0224 pos_x
COMMENT $0227 not it corridor->jump
COMMENT $0229 get monster position
FORCE_SYMBOL $0229 pos_y
COMMENT $022C and build abs 'difference'
FORCE_SYMBOL $022C C_MONSTER_Y
COMMENT $022E if 'nearer' accept new monster
FORCE_SYMBOL $022E V_MONSTER_NEARNESS
COMMENT $0231 otherwise go on looking
COMMENT $0233 y position of monster
FORCE_SYMBOL $0233 C_MONSTER_Y
COMMENT_LINE $0235 now init view of monster
COMMENT_LINE $0235 translate its position to view position
COMMENT_LINE $0235 and store it
FORCE_SYMBOL $0235 view_monster
FORCE_SYMBOL $0239 pos_x
COMMENT $023C view x pos
COMMENT $0241 view y pos
COMMENT $0243 x, y offset of monster
FORCE_SYMBOL $0243 C_MONSTER_OFFSET
COMMENT $0245 view x offset
COMMENT $0249 view y offset
FORCE_SYMBOL $024D pos_y
FORCE_SYMBOL $0250 C_MONSTER_Y
COMMENT $0252 near to player
FORCE_NO_SYMBOL $0252
FORCE_SYMBOL $0254 V_MONSTER_MOVEMENT_AXIS_TEMP
FORCE_SYMBOL $0257 V_MONSTER_MOVEMENT_AXIS
FORCE_SYMBOL $025A C_MONSTER_SIZE
FORCE_SYMBOL $025C next_monster
COMMENT_LINE $025F ;;;;;;;;;;;;;
COMMENT_LINE $025F test whether there is a current display monster
FORCE_SYMBOL $025F V_MONSTER_POSITION
FORCE_SYMBOL $0262 NO_MONSTER
COMMENT_LINE $0268 yes, there is
COMMENT_LINE $0268 check what type of 'visual monster'
COMMENT $0268 get pointer to maze monster
FORCE_SYMBOL $0268 V_MONSTER_POINTER
COMMENT $026B get maze monster definition
FORCE_SYMBOL $026B C_MONSTER_DEFINITION
COMMENT $026D get monster structure
FORCE_SYMBOL $026D M_MONSTER_STRUCT
COMMENT $026F get animation struct
FORCE_SYMBOL $026F MONSTER_ANIM_STRUCT
COMMENT $0271 get type of animtion
FORCE_SYMBOL $0271 ANIMATION_TYPE
COMMENT $0273 is type animation?
FORCE_SYMBOL $0273 ANIMATION
COMMENT $0275 no - jump
COMMENT_LINE $0277 in U now pointer to animation struct
COMMENT_LINE $0277 in X now pointer to current monster (not view monster)
COMMENT $0277 decrease animation delay counter
FORCE_SYMBOL $0277 C_MONSTER_ANIM_COUNTER
COMMENT $0279 if not zero... nothing changes->jump
COMMENT $027B get animation delay value
FORCE_SYMBOL $027B ANIMATION_DELAY
COMMENT $027D an store it as new delay
FORCE_SYMBOL $027D C_MONSTER_ANIM_COUNTER
COMMENT $027F increase
FORCE_SYMBOL $027F C_MONSTER_GRAPHIC_COUNTER
COMMENT $0281 and load current graphic index
FORCE_SYMBOL $0281 C_MONSTER_GRAPHIC_COUNTER
COMMENT $0283 increase one, since we are intersted
COMMENT_LINE $0284 in the next vector list not the current
COMMENT $0284 double it, since it is a 'word pointer'
COMMENT $0285 ... if not last... (last is filled with 0,0)
COMMENT $0287 not last->jump
COMMENT $0289 otherwise reset index
FORCE_SYMBOL $0289 C_MONSTER_GRAPHIC_COUNTER
COMMENT $028B and use first graphic
FORCE_SYMBOL $028B ANIMATION_GRAPHIC_START
COMMENT $028D store graphic pointer as current
FORCE_SYMBOL $028D C_MONSTER_GRAPHIC
COMMENT_LINE $0291 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0292 ***************************************************************************
COMMENT $0292 following code uses d0
COMMENT_LINE $0292 ***************************************************************************
COMMENT $0292 get button status once, since only
FORCE_SYMBOL $0292 Read_Btns
COMMENT $0295 is a button pressed?
FORCE_NO_SYMBOL $0295
COMMENT_LINE $0299 center map on player
FORCE_SYMBOL $0299 pos
FORCE_NO_SYMBOL $029C
FORCE_NO_SYMBOL $02A0
FORCE_SYMBOL $02A2 _yo
FORCE_SYMBOL $02AB _yo
FORCE_SYMBOL $02B0 _yo
FORCE_NO_SYMBOL $02B3
FORCE_NO_SYMBOL $02B7
FORCE_SYMBOL $02B9 _xo
FORCE_SYMBOL $02C2 _xo
FORCE_SYMBOL $02C7 _xo
FORCE_SYMBOL $02CA do_ym_sound
COMMENT $02CD sets dp to d0, and pos at 0, 0
FORCE_SYMBOL $02CD Wait_Recal
FORCE_SYMBOL $02D0 Intensity_7F
COMMENT $02D3 read joystick positions
FORCE_SYMBOL $02D3 Joy_Digital
COMMENT $02D6 load joystick 1 position Y to A
FORCE_SYMBOL $02D6 Vec_Joy_1_Y
FORCE_SYMBOL $02DD _yo
FORCE_SYMBOL $02E4 _yo
FORCE_SYMBOL $02E9 _yo
FORCE_SYMBOL $02EE _yo
COMMENT $02F1 load joystick 1 position Y to A
FORCE_SYMBOL $02F1 Vec_Joy_1_X
FORCE_SYMBOL $02F8 _xo
FORCE_SYMBOL $02FF _xo
FORCE_SYMBOL $0304 _xo
FORCE_SYMBOL $0309 _xo
FORCE_SYMBOL $030C _yo
FORCE_SYMBOL $030F MAZE_X
FORCE_SYMBOL $0312 map_offset
FORCE_SYMBOL $0315 _xo
FORCE_SYMBOL $0319 map_offset
FORCE_SYMBOL $031C map_offset
FORCE_SYMBOL $031F map_bits
FORCE_SYMBOL $0322 _yo
COMMENT $0327 address of current check
FORCE_SYMBOL $0329 map_address
FORCE_NO_SYMBOL $032C
FORCE_SYMBOL $032E map_worker
FORCE_SYMBOL $0331 _xo
FORCE_SYMBOL $0338 map_worker
FORCE_SYMBOL $033D map_worker
FORCE_NO_SYMBOL $0345
COMMENT $0347 move to time 1 lo, this means scaling
FORCE_SYMBOL $0347 VIA_t1_cnt_lo
FORCE_NO_SYMBOL $0349
FORCE_SYMBOL $034D map_helper
COMMENT $0350 following code uses d0
COMMENT $0350 Store Y in D/A register
FORCE_SYMBOL $0350 VIA_port_a
COMMENT $0352 Blank low, zero high?
FORCE_NO_SYMBOL $0352
FORCE_SYMBOL $0354 VIA_cntl
COMMENT $0357 Enable mux
FORCE_SYMBOL $0357 VIA_port_b
COMMENT $0359 Clear shift regigster
FORCE_SYMBOL $0359 VIA_shift_reg
COMMENT $035B Disable mux
FORCE_SYMBOL $035B VIA_port_b
COMMENT $035D Store X in D/A register
FORCE_SYMBOL $035D VIA_port_a
COMMENT $035F enable timer
FORCE_SYMBOL $035F VIA_t1_cnt_hi
FORCE_NO_SYMBOL $0361
FORCE_SYMBOL $0363 VIA_int_flags
COMMENT_LINE $0367 JSR     Moveto_d
FORCE_NO_SYMBOL $0367
COMMENT $0369 move to time 1 lo, this means scaling
FORCE_SYMBOL $0369 VIA_t1_cnt_lo
FORCE_SYMBOL $036B map_bits
FORCE_SYMBOL $036E maze1
FORCE_SYMBOL $0371 map_offset
FORCE_SYMBOL $0376 _y
FORCE_SYMBOL $0379 _yo
FORCE_SYMBOL $037C my
FORCE_SYMBOL $037F _x
FORCE_SYMBOL $0382 _xo
FORCE_SYMBOL $0385 mx
FORCE_SYMBOL $0388 map_worker
FORCE_SYMBOL $038F map_worker
FORCE_SYMBOL $0399 _x
COMMENT_LINE $039E jsr     DRAW_TILE_A
FORCE_SYMBOL $03A2 tile0v
FORCE_SYMBOL $03A8 pos
FORCE_SYMBOL $03AB my
FORCE_SYMBOL $03B1 look_direction
FORCE_SYMBOL $03B4 SOUTH
FORCE_SYMBOL $03B8 player_south_tile
FORCE_SYMBOL $03BD NORTH
FORCE_SYMBOL $03C1 player_north_tile
FORCE_SYMBOL $03C6 EAST
FORCE_SYMBOL $03CA player_east_tile
FORCE_SYMBOL $03CF player_west_tile
FORCE_SYMBOL $03D4 tile11v
COMMENT $03D7 following code uses d0
FORCE_NO_SYMBOL $03D7
FORCE_SYMBOL $03D9 VIA_port_a
FORCE_SYMBOL $03DB VIA_port_b
FORCE_NO_SYMBOL $03DD
FORCE_SYMBOL $03DF VIA_port_b
FORCE_SYMBOL $03E1 VIA_port_a
FORCE_SYMBOL $03E3 VIA_shift_reg
FORCE_SYMBOL $03E5 VIA_t1_cnt_hi
FORCE_NO_SYMBOL $03E7
FORCE_NO_SYMBOL $03E9
FORCE_NO_SYMBOL $03ED
FORCE_SYMBOL $03F0 VIA_int_flags
FORCE_SYMBOL $03F4 VIA_shift_reg
FORCE_NO_SYMBOL $03F8
FORCE_SYMBOL $03FB VIA_int_flags
FORCE_SYMBOL $03FF VIA_shift_reg
COMMENT_LINE $0401 JSR     Draw_VLp
FORCE_SYMBOL $0401 _x
FORCE_SYMBOL $0404 mx
FORCE_SYMBOL $0407 _x
COMMENT $040A MAZE_X
FORCE_NO_SYMBOL $040A
FORCE_SYMBOL $0410 MAZE_X
FORCE_SYMBOL $0413 _y
FORCE_SYMBOL $0416 _y
COMMENT $0419 MAZE_Y
FORCE_NO_SYMBOL $0419
FORCE_NO_SYMBOL $041D
COMMENT $041F /BLANK low and /ZERO low
FORCE_SYMBOL $041F VIA_cntl
FORCE_NO_SYMBOL $0421
COMMENT $0423 move to time 1 lo, this means scaling
FORCE_SYMBOL $0423 VIA_t1_cnt_lo
FORCE_SYMBOL $0425 map_helper
FORCE_NO_SYMBOL $0428
FORCE_SYMBOL $042A map_helper
COMMENT_LINE $042D JSR     Moveto_d
COMMENT $042D following code uses d0
COMMENT $042D Store Y in D/A register
FORCE_SYMBOL $042D VIA_port_a
COMMENT $042F Blank low, zero high?
FORCE_NO_SYMBOL $042F
FORCE_SYMBOL $0431 VIA_cntl
COMMENT $0434 Enable mux
FORCE_SYMBOL $0434 VIA_port_b
COMMENT $0436 Clear shift regigster
FORCE_SYMBOL $0436 VIA_shift_reg
COMMENT $0438 Disable mux
FORCE_SYMBOL $0438 VIA_port_b
COMMENT $043A Store X in D/A register
FORCE_SYMBOL $043A VIA_port_a
COMMENT $043C enable timer
FORCE_SYMBOL $043C VIA_t1_cnt_hi
FORCE_NO_SYMBOL $043E
FORCE_SYMBOL $0440 VIA_int_flags
FORCE_NO_SYMBOL $0444
COMMENT $0446 move to time 1 lo, this means scaling
FORCE_SYMBOL $0446 VIA_t1_cnt_lo
FORCE_SYMBOL $0448 my
FORCE_SYMBOL $044B map_address
FORCE_NO_SYMBOL $044E
FORCE_SYMBOL $0450 map_address
FORCE_NO_SYMBOL $0453
FORCE_SYMBOL $0455 map_worker
FORCE_SYMBOL $0458 _xo
FORCE_SYMBOL $045F map_worker
FORCE_SYMBOL $0464 map_worker
FORCE_SYMBOL $046C draw_next_line
COMMENT $046F get button status once, since only
FORCE_SYMBOL $046F Read_Btns
COMMENT $0472 is a button pressed?
FORCE_NO_SYMBOL $0472
COMMENT $0474 go back to main loop
FORCE_SYMBOL $0478 main_loop_1
COMMENT_LINE $047B ***************************************************************************
FORCE_SYMBOL $047B pos_y
FORCE_SYMBOL $047E map_bits
FORCE_SYMBOL $0485 pos_x
FORCE_SYMBOL $0488 map_helper
COMMENT $048B 0111 bits
FORCE_NO_SYMBOL $048B
FORCE_SYMBOL $048D map_helper
COMMENT $0492 LSR A
COMMENT $0493 LSR B
COMMENT $0494 if no carry, than exit
FORCE_NO_SYMBOL $049B
FORCE_NO_SYMBOL $049D
FORCE_NO_SYMBOL $049F
FORCE_NO_SYMBOL $04AB
FORCE_NO_SYMBOL $04AD
FORCE_NO_SYMBOL $04AF
COMMENT_LINE $04B4 ***************************************************************************
COMMENT_LINE $04B6 ***************************************************************************
FORCE_SYMBOL $04B6 translate_position
FORCE_SYMBOL $04B9 look_direction
FORCE_SYMBOL $04BC look_direction
FORCE_SYMBOL $04BF look_direction
FORCE_NO_SYMBOL $04C2
FORCE_SYMBOL $04C6 look_direction
FORCE_SYMBOL $04CA WEST
FORCE_SYMBOL $04CE init_looking_west
FORCE_SYMBOL $04D1 west_sample_struct
FORCE_SYMBOL $04D6 EAST
FORCE_SYMBOL $04DA init_looking_east
FORCE_SYMBOL $04DD east_sample_struct
FORCE_SYMBOL $04E2 SOUTH
FORCE_SYMBOL $04E6 init_looking_south
FORCE_SYMBOL $04E9 south_sample_struct
FORCE_SYMBOL $04EE init_looking_north
FORCE_SYMBOL $04F1 north_sample_struct
FORCE_SYMBOL $04F4 init_digit_sound
COMMENT_LINE $04F8 ***************************************************************************
FORCE_SYMBOL $04F8 translate_position
FORCE_SYMBOL $04FB look_direction
FORCE_SYMBOL $04FE look_direction
FORCE_SYMBOL $0501 look_direction
FORCE_SYMBOL $0508 EAST
FORCE_SYMBOL $050A look_direction
COMMENT_LINE $050F ***************************************************************************
COMMENT_LINE $050F translates maze view position to player (pos) position
FORCE_SYMBOL $050F look_direction
FORCE_SYMBOL $0512 SOUTH
FORCE_SYMBOL $0516 EAST
FORCE_SYMBOL $051A NORTH
FORCE_SYMBOL $0520 maze_draw_y
FORCE_SYMBOL $0523 pos_x
FORCE_SYMBOL $0526 move_offset_y
FORCE_SYMBOL $052A pos_offset_x
FORCE_SYMBOL $0530 maze_draw_y
FORCE_SYMBOL $0533 pos_y
FORCE_SYMBOL $0536 move_offset_y
FORCE_SYMBOL $053A pos_offset_y
FORCE_SYMBOL $053E maze_draw_y
FORCE_SYMBOL $0541 pos_y
FORCE_SYMBOL $0544 move_offset_y
FORCE_SYMBOL $0547 pos_offset_y
FORCE_SYMBOL $054B maze_draw_y
FORCE_SYMBOL $054E pos_x
FORCE_SYMBOL $0551 move_offset_y
FORCE_SYMBOL $0554 pos_offset_x
COMMENT_LINE $0558 ***************************************************************************
COMMENT_LINE $0558 this routine initializes the game variables
COMMENT_LINE $0558 nothing is expected and nothing is returned
COMMENT_LINE $0558 leaves DP to C8
FORCE_NO_SYMBOL $0558
COMMENT $055C pretty for optimizing to use a makro :-)
COMMENT $055C these set up the joystick
FORCE_NO_SYMBOL $055C
COMMENT $055E enquiries
FORCE_SYMBOL $055E Vec_Joy_Mux_1_X
COMMENT $0560 allowing only all directions for
FORCE_NO_SYMBOL $0560
COMMENT $0562 for joystick one
FORCE_SYMBOL $0562 Vec_Joy_Mux_1_Y
COMMENT $0564 this setting up saves a few hundred
FORCE_NO_SYMBOL $0564
COMMENT $0566 cycles
FORCE_SYMBOL $0566 Vec_Joy_Mux_2_X
COMMENT $0568 don't miss it, if you don't need the
FORCE_SYMBOL $0568 Vec_Joy_Mux_2_Y
COMMENT_LINE $056A second joystick!
FORCE_NO_SYMBOL $056B
FORCE_NO_SYMBOL $0570
FORCE_SYMBOL $0575 digit_is_playing
COMMENT $0578 sets dp to d0, and pos at 0, 0
FORCE_SYMBOL $0578 Wait_Recal
COMMENT $057B pretty for optimizing to use a makro :-)
FORCE_SYMBOL $057B Read_Btns
COMMENT_LINE $057E JSR    switch_to_ym
COMMENT_LINE $057F ***************************************************************************
COMMENT_LINE $0580 ***************************************************************************
FORCE_SYMBOL $0580 maze1
FORCE_SYMBOL $0583 current_maze
FORCE_SYMBOL $0586 MAZE_PLAYER_START
FORCE_SYMBOL $058A pos
FORCE_SYMBOL $058D MAZE_PLAYER_DIRECTION
FORCE_SYMBOL $0591 look_direction
FORCE_SYMBOL $0594 SOUTH
FORCE_SYMBOL $0598 init_looking_south
FORCE_SYMBOL $059D NORTH
FORCE_SYMBOL $05A1 init_looking_north
FORCE_SYMBOL $05A6 EAST
FORCE_SYMBOL $05AA init_looking_east
FORCE_SYMBOL $05AF init_looking_west
FORCE_SYMBOL $05B2 current_maze
COMMENT $05B5 start of monster info DATA for maze
FORCE_SYMBOL $05B5 MAZE_MONSTER_START
COMMENT_LINE $05B9 init monster info
FORCE_SYMBOL $05B9 current_monster_list
COMMENT $05BC position in lab
FORCE_SYMBOL $05BC M_MONSTER_POSITION
COMMENT $05C2 offset at position
FORCE_SYMBOL $05C2 M_MONSTER_OFFSET
COMMENT $05C6 movement type
FORCE_SYMBOL $05C6 M_MONSTER_MOVEMENT_TYPE
COMMENT $05CA level monster information
COMMENT $05CC get monster structure
FORCE_SYMBOL $05CC M_MONSTER_STRUCT
COMMENT $05CF get animation struct
FORCE_SYMBOL $05CF MONSTER_ANIM_STRUCT
COMMENT $05D2 get animation delay value
FORCE_SYMBOL $05D2 ANIMATION_DELAY
COMMENT $05D6 get first Vectorlist of Monster in animation
FORCE_SYMBOL $05D6 ANIMATION_GRAPHIC_START
COMMENT $05DA currently used vector list is number 0
COMMENT $05DC heading is positive
FORCE_NO_SYMBOL $05DC
COMMENT $05DE currently used vector list is number 0
FORCE_SYMBOL $05E0 MAZE_MONSTER_LEN
FORCE_SYMBOL $05E9 move_offset_y_big
COMMENT_LINE $05ED ***************************************************************************
COMMENT_LINE $05ED ***************************************************************************
COMMENT_LINE $05ED D = clipping place (in scale of added strengths of vector X positions)
COMMENT_LINE $05ED X = Vector list
COMMENT_LINE $05ED returns new vector list pointer in X
COMMENT_LINE $05ED result list has following format
COMMENT_LINE $05ED DB pattern, y, x
COMMENT_LINE $05ED DB pattern, y, x
COMMENT_LINE $05ED DB ... (till counter is 1)
COMMENT_LINE $05ED result in DrawVLp type Vector list
COMMENT_LINE $05ED clip vectors EXACTLY!
COMMENT_LINE $05ED note:
COMMENT_LINE $05ED Due to DIVs and MULs, this function does take some time
COMMENT_LINE $05ED maybe a few thousand cycles for LARGE VLISTs.
COMMENT_LINE $05ED Therefor do zeroing + positioning AFTER calling this functions
COMMENT_LINE $05ED otherwise vectrex beam drifts away a bit!
COMMENT_LINE $05ED Noticeable on a real vectrex or in DVE when Drift is
COMMENT_LINE $05ED = to something different than 0 (in *.ini)
COMMENT_LINE $05ED note:
COMMENT_LINE $05ED Expects now VLists, that have X vector strength of 16, 32, or 64
COMMENT_LINE $05ED Gabage will produced else...
COMMENT_LINE $05ED note:
COMMENT_LINE $05ED using Y as shown in ';' saves a couple of cycles.
COMMENT $05ED but here the code still uses c8
COMMENT $05ED remember clipping edge
FORCE_SYMBOL $05ED clip_test
FORCE_NO_SYMBOL $05F0
COMMENT $05F4 pretty for optimizing to use a makro :-)
COMMENT $05F4 address of result list
FORCE_SYMBOL $05F4 clipped_vector_list
FORCE_NO_SYMBOL $05F7
COMMENT $05FA clip starts at 0
FORCE_SYMBOL $05FA clip_counter
COMMENT_LINE $05FC we add to this each strength
COMMENT_LINE $05FC of a vector
COMMENT $05FC when first vector will be invisible
COMMENT $05FE default pattern is 0, invisible
FORCE_SYMBOL $05FE clip_pattern
COMMENT $0600 compare current 'place'
FORCE_SYMBOL $0600 clip_counter
COMMENT $0602 with clipping edge
FORCE_SYMBOL $0602 clip_test
COMMENT $0605 if higher... the start of this
COMMENT_LINE $0607 current vector is visible -> branch
COMMENT_LINE $0607 otherwise the start was not visible
FORCE_NO_SYMBOL $0607
COMMENT $0609 get current Vector strength
COMMENT $060B remember it as v0
FORCE_SYMBOL $060B v0
COMMENT $060D extend it X part
COMMENT $060E and adjust clip_counter
FORCE_SYMBOL $060E clip_counter
COMMENT $0610 store it
FORCE_SYMBOL $0610 clip_counter
COMMENT_LINE $0612 clip counter has vector
COMMENT_LINE $0612 'position' at the end
COMMENT_LINE $0612 of current vector
COMMENT $0612 test for clipping edge
FORCE_SYMBOL $0612 clip_test
COMMENT $061D one invisible the other visible? -> branch
COMMENT_LINE $061F both vector ends are invisible
COMMENT $0623 pattern is 0
COMMENT $0625 load current Vector
FORCE_SYMBOL $0625 v0
COMMENT $0627 store it also
COMMENT $062B pattern = 1 ends VList
FORCE_NO_SYMBOL $062B
COMMENT $062D store it
FORCE_NO_SYMBOL $062D
COMMENT $062F load X with correct VLp
FORCE_SYMBOL $062F clipped_vector_list
COMMENT $0632 reset dp to d0
FORCE_NO_SYMBOL $0632
COMMENT $0636 pretty for optimizing to use a makro :-)
COMMENT $0636 but here the code still uses c8
COMMENT $0636 return
COMMENT $0637 pattern is 0
COMMENT $0639 load current Vector
FORCE_SYMBOL $0639 v0
COMMENT $063B store it also
COMMENT_LINE $063D BRA     was_visible_vlp
FORCE_NO_SYMBOL $063D
COMMENT $063F get current Vector
COMMENT $0641 remember it as v0
FORCE_SYMBOL $0641 v0
COMMENT $0643 extend it x0 part
COMMENT $0644 and adjuct clip_counter
FORCE_SYMBOL $0644 clip_counter
COMMENT $0646 store it
FORCE_SYMBOL $0646 clip_counter
COMMENT_LINE $0648 clip counter has vector
COMMENT_LINE $0648 'position' at the end
COMMENT_LINE $0648 of current vector
COMMENT $064E test for clipping edge
FORCE_SYMBOL $064E clip_test
COMMENT $0651 if the whole is visible -> branch
COMMENT $0653 use full pattern
FORCE_NO_SYMBOL $0653
COMMENT $0655 store in vlist
COMMENT $0657 load current Vector
FORCE_SYMBOL $0657 v0
COMMENT $0659 store it also
COMMENT $065B no? -> branch
FORCE_SYMBOL $065D clip_pattern
COMMENT $065F leaves with v1 and v2 calculated
COMMENT_LINE $065F first setup x1 and x2 according to clipping
COMMENT_LINE $065F information
FORCE_SYMBOL $065F clip_test
COMMENT $0661 part of vector that is visible (or vice versa)
FORCE_SYMBOL $0661 x2
FORCE_SYMBOL $0663 x0
COMMENT $0666 part of vector that is invisible (or vice versa)
FORCE_SYMBOL $0666 x1
COMMENT_LINE $0668 now we have to calculate the Y part of the two
COMMENT_LINE $0668 halves
COMMENT_LINE $0668 Y1/X1 and Y2/X2 should be like Y0/X0
COMMENT_LINE $0668 X0 = original length
COMMENT_LINE $0668 than Y1 = Y0*X1/X0
COMMENT_LINE $0668 than Y2 = Y0*X2/X0
COMMENT_LINE $0668 but we know that Y1 + Y2 = Y0
COMMENT_LINE $0668 -> Y2 = Y0 - Y1
COMMENT_LINE $0668 div cycles depend on size of tmp1
COMMENT_LINE $0668 the bigger tmp1 the faster div
COMMENT_LINE $0668 we do div and mul unsigned
COMMENT_LINE $0668 so check for signness here
COMMENT_LINE $0668 and adjust later
FORCE_SYMBOL $0669 neggi
FORCE_SYMBOL $066B x0
FORCE_SYMBOL $066F neggi
FORCE_NO_SYMBOL $0672
FORCE_NO_SYMBOL $0676
FORCE_SYMBOL $067A y0
FORCE_SYMBOL $067E neggi
FORCE_SYMBOL $0681 x1
FORCE_SYMBOL $0685 neggi
COMMENT $0689 this divides d by 64
COMMENT $068A result in A
FORCE_SYMBOL $068D neggi
COMMENT $0692 store y1
FORCE_SYMBOL $0692 y1
COMMENT $0694 -y1 + y0 = y0 - y1 = y2
FORCE_SYMBOL $0695 y0
COMMENT $0697 store y2
FORCE_SYMBOL $0697 y2
FORCE_SYMBOL $069B y0
FORCE_SYMBOL $069F neggi
FORCE_SYMBOL $06A2 x1
FORCE_SYMBOL $06A6 neggi
FORCE_SYMBOL $06AC y0
FORCE_SYMBOL $06B0 neggi
FORCE_SYMBOL $06B3 x1
FORCE_SYMBOL $06B7 neggi
FORCE_SYMBOL $06C5 neggi
COMMENT $06CA store y1
FORCE_SYMBOL $06CA y1
COMMENT $06CC -y1 + y0 = y0 - y1 = y2
FORCE_SYMBOL $06CD y0
COMMENT $06CF store y2
FORCE_SYMBOL $06CF y2
COMMENT $06D1 get pattern
FORCE_SYMBOL $06D1 clip_pattern
COMMENT $06D3 store it
COMMENT $06D5 build vector from X1 and Y1
FORCE_SYMBOL $06D5 v1
COMMENT $06D7 store it to list
COMMENT $06D9 get pattern and
FORCE_SYMBOL $06D9 clip_pattern
COMMENT $06DB reverse it
COMMENT $06DC store it
COMMENT $06DE build vector from X2 and Y2
FORCE_SYMBOL $06DE v2
COMMENT $06E0 store it to list
COMMENT $06E2 do next
FORCE_SYMBOL $06E2 do_next_vector_vlp
COMMENT_LINE $06E5 ***************************************************************************
COMMENT_LINE $06E5 D = clipping place (in scale of added strengths of vector X positions)
COMMENT_LINE $06E5 X = Vector list
COMMENT_LINE $06E5 returns new vector list pointer in X
COMMENT_LINE $06E5 result list has following format
COMMENT_LINE $06E5 DB pattern, y, x
COMMENT_LINE $06E5 DB pattern, y, x
COMMENT_LINE $06E5 DB ... (till counter is 1)
COMMENT_LINE $06E5 result in DrawVLp type Vector list
COMMENT_LINE $06E5 clip vectors EXACTLY!
COMMENT_LINE $06E5 note:
COMMENT_LINE $06E5 Due to DIVs and MULs, this function does take some time
COMMENT_LINE $06E5 maybe a few thousand cycles for LARGE VLISTs.
COMMENT_LINE $06E5 Therefor do zeroing + positioning AFTER calling this functions
COMMENT_LINE $06E5 otherwise vectrex beam drifts away a bit!
COMMENT_LINE $06E5 Noticeable on a real vectrex or in DVE when Drift is
COMMENT_LINE $06E5 = to something different than 0 (in *.ini)
COMMENT_LINE $06E5 note:
COMMENT_LINE $06E5 Expects now VLists, that have X vector strength of 16, 32, or 64
COMMENT_LINE $06E5 Gabage will produced else...
COMMENT $06E5 but here the code still uses c8
COMMENT $06E5 remember clipping edge
FORCE_SYMBOL $06E5 clip_test
FORCE_NO_SYMBOL $06E8
COMMENT $06EC pretty for optimizing to use a makro :-)
FORCE_SYMBOL $06EC DIGIT_VLP_RELOAD
FORCE_SYMBOL $06EE clip_line_counter
COMMENT $06F0 address of result list
FORCE_SYMBOL $06F0 clipped_vector_list
FORCE_NO_SYMBOL $06F3
COMMENT $06F6 clip starts at 0
FORCE_SYMBOL $06F6 clip_counter
COMMENT_LINE $06F8 we add to this each strength
COMMENT_LINE $06F8 of a vector
COMMENT $06F8 when first vector will be invisible
COMMENT $06FA default pattern is 0, invisible
FORCE_SYMBOL $06FA clip_pattern
COMMENT $06FC compare current 'place'
FORCE_SYMBOL $06FC clip_counter
COMMENT $06FE with clipping edge
FORCE_SYMBOL $06FE clip_test
COMMENT $0701 if higher... the start of this
COMMENT_LINE $0703 current vector is visible -> branch
FORCE_SYMBOL $0703 clip_line_counter
FORCE_SYMBOL $0707 DIGIT_VLP_RELOAD
FORCE_SYMBOL $0709 clip_line_counter
COMMENT $070B get timer
FORCE_SYMBOL $070B VIA_t2_hi
FORCE_SYMBOL $070E T2_TIMER_PEROID_REAL
COMMENT $0710 and store it
FORCE_SYMBOL $0710 digit_next_digit_cycle
COMMENT $0713 load the next sample_byte to A
COMMENT $0715 store in reg A in 6522 (DAC)
FORCE_SYMBOL $0715 VIA_port_a
COMMENT $0718 this sets the MUX of 6522 to PSG
COMMENT $0718 load the calculated VIA B
FORCE_SYMBOL $0718 via_b_start
COMMENT $071B write back to reg B in 6522
FORCE_SYMBOL $071B VIA_port_b
COMMENT $071E Clear shift regigster, why ???
FORCE_SYMBOL $071E VIA_shift_reg
COMMENT $0721 and disable the mux, so no junk will
FORCE_SYMBOL $0721 VIA_port_b
COMMENT_LINE $0724 otherwise the start was not visible
FORCE_NO_SYMBOL $0724
COMMENT $0726 get current Vector strength
COMMENT $0728 remember it as v0
FORCE_SYMBOL $0728 v0
COMMENT $072A extend it X part
COMMENT $072B and adjust clip_counter
FORCE_SYMBOL $072B clip_counter
COMMENT $072D store it
FORCE_SYMBOL $072D clip_counter
COMMENT_LINE $072F clip counter has vector
COMMENT_LINE $072F 'position' at the end
COMMENT_LINE $072F of current vector
COMMENT $072F test for clipping edge
FORCE_SYMBOL $072F clip_test
COMMENT $073A one invisible the other visible? -> branch
COMMENT_LINE $073C both vector ends are invisible
COMMENT $0740 pattern is 0
COMMENT $0742 load current Vector
FORCE_SYMBOL $0742 v0
COMMENT $0744 store it also
FORCE_SYMBOL $0746 clip_line_counter
COMMENT $074A pattern = 1 ends VList
FORCE_NO_SYMBOL $074A
COMMENT $074C store it
FORCE_NO_SYMBOL $074C
COMMENT $074E load X with correct VLp
FORCE_SYMBOL $074E clipped_vector_list
COMMENT $0751 reset dp to d0
FORCE_NO_SYMBOL $0751
COMMENT $0755 pretty for optimizing to use a makro :-)
COMMENT $0755 but here the code still uses c8
COMMENT $0755 return
COMMENT $0756 pattern is 0
COMMENT $0758 load current Vector
FORCE_SYMBOL $0758 v0
COMMENT $075A store it also
COMMENT_LINE $075C BRA     was_visible_vlpd
FORCE_SYMBOL $075C clip_line_counter
FORCE_SYMBOL $0760 DIGIT_VLP_RELOAD
FORCE_SYMBOL $0762 clip_line_counter
COMMENT $0764 get timer
FORCE_SYMBOL $0764 VIA_t2_hi
FORCE_SYMBOL $0767 T2_TIMER_PEROID_REAL
COMMENT $0769 and store it
FORCE_SYMBOL $0769 digit_next_digit_cycle
COMMENT $076C load the next sample_byte to A
COMMENT $076E store in reg A in 6522 (DAC)
FORCE_SYMBOL $076E VIA_port_a
COMMENT $0771 this sets the MUX of 6522 to PSG
COMMENT $0771 load the calculated VIA B
FORCE_SYMBOL $0771 via_b_start
COMMENT $0774 write back to reg B in 6522
FORCE_SYMBOL $0774 VIA_port_b
COMMENT $0777 Clear shift regigster, why ???
FORCE_SYMBOL $0777 VIA_shift_reg
COMMENT $077A and disable the mux, so no junk will
FORCE_SYMBOL $077A VIA_port_b
FORCE_NO_SYMBOL $077D
COMMENT $077F get current Vector
COMMENT $0781 remember it as v0
FORCE_SYMBOL $0781 v0
COMMENT $0783 extend it x0 part
COMMENT $0784 and adjuct clip_counter
FORCE_SYMBOL $0784 clip_counter
COMMENT $0786 store it
FORCE_SYMBOL $0786 clip_counter
COMMENT_LINE $0788 clip counter has vector
COMMENT_LINE $0788 'position' at the end
COMMENT_LINE $0788 of current vector
COMMENT $078E test for clipping edge
FORCE_SYMBOL $078E clip_test
COMMENT $0791 if the whole is visible -> branch
COMMENT $0793 use full pattern
FORCE_NO_SYMBOL $0793
COMMENT $0795 store in vlist
COMMENT $0797 load current Vector
FORCE_SYMBOL $0797 v0
COMMENT $0799 store it also
FORCE_SYMBOL $079B clip_line_counter
COMMENT $079D no? -> branch
FORCE_SYMBOL $079F clip_pattern
COMMENT $07A1 leaves with v1 and v2 calculated
COMMENT_LINE $07A1 first setup x1 and x2 according to clipping
COMMENT_LINE $07A1 information
FORCE_SYMBOL $07A1 clip_test
COMMENT $07A3 part of vector that is visible (or vice versa)
FORCE_SYMBOL $07A3 x2
FORCE_SYMBOL $07A5 x0
COMMENT $07A8 part of vector that is invisible (or vice versa)
FORCE_SYMBOL $07A8 x1
COMMENT_LINE $07AA now we have to calculate the Y part of the two
COMMENT_LINE $07AA halves
COMMENT_LINE $07AA Y1/X1 and Y2/X2 should be like Y0/X0
COMMENT_LINE $07AA X0 = original length
COMMENT_LINE $07AA than Y1 = Y0*X1/X0
COMMENT_LINE $07AA than Y2 = Y0*X2/X0
COMMENT_LINE $07AA but we know that Y1 + Y2 = Y0
COMMENT_LINE $07AA -> Y2 = Y0 - Y1
COMMENT_LINE $07AA div cycles depend on size of tmp1
COMMENT_LINE $07AA the bigger tmp1 the faster div
COMMENT_LINE $07AA we do div and mul unsigned
COMMENT_LINE $07AA so check for signness here
COMMENT_LINE $07AA and adjust later
FORCE_SYMBOL $07AB neggi
FORCE_SYMBOL $07AD x0
FORCE_SYMBOL $07B1 neggi
FORCE_NO_SYMBOL $07B4
FORCE_NO_SYMBOL $07B8
FORCE_SYMBOL $07BC y0
FORCE_SYMBOL $07C0 neggi
FORCE_SYMBOL $07C3 x1
FORCE_SYMBOL $07C7 neggi
COMMENT $07CB this divides d by 64
COMMENT $07CC result in A
FORCE_SYMBOL $07CF neggi
COMMENT $07D4 store y1
FORCE_SYMBOL $07D4 y1
COMMENT $07D6 -y1 + y0 = y0 - y1 = y2
FORCE_SYMBOL $07D7 y0
COMMENT $07D9 store y2
FORCE_SYMBOL $07D9 y2
FORCE_SYMBOL $07DD y0
FORCE_SYMBOL $07E1 neggi
FORCE_SYMBOL $07E4 x1
FORCE_SYMBOL $07E8 neggi
FORCE_SYMBOL $07EE y0
FORCE_SYMBOL $07F2 neggi
FORCE_SYMBOL $07F5 x1
FORCE_SYMBOL $07F9 neggi
FORCE_SYMBOL $0807 neggi
COMMENT $080C store y1
FORCE_SYMBOL $080C y1
COMMENT $080E -y1 + y0 = y0 - y1 = y2
FORCE_SYMBOL $080F y0
COMMENT $0811 store y2
FORCE_SYMBOL $0811 y2
COMMENT $0813 get pattern
FORCE_SYMBOL $0813 clip_pattern
COMMENT $0815 store it
COMMENT $0817 build vector from X1 and Y1
FORCE_SYMBOL $0817 v1
COMMENT $0819 store it to list
COMMENT $081B get pattern and
FORCE_SYMBOL $081B clip_pattern
COMMENT $081D reverse it
COMMENT $081E store it
COMMENT $0820 build vector from X2 and Y2
FORCE_SYMBOL $0820 v2
COMMENT $0822 store it to list
FORCE_SYMBOL $0824 clip_line_counter
FORCE_SYMBOL $0826 clip_line_counter
FORCE_SYMBOL $0828 clip_line_counter
COMMENT $082A do next
FORCE_SYMBOL $082A do_next_vector_vlpd
COMMENT_LINE $082D ***************************************************************************
COMMENT_LINE $082D D = clipping place (in scale of added strengths of vector X positions)
COMMENT_LINE $082D X = Vector list
COMMENT_LINE $082D returns new vector list pointer in X
COMMENT_LINE $082D result list has following format
COMMENT_LINE $082D DB pattern, y, x
COMMENT_LINE $082D DB pattern, y, x
COMMENT_LINE $082D DB ... (till counter is 1)
COMMENT_LINE $082D result in DrawVLp type Vector list
COMMENT_LINE $082D clip vectors EXACTLY!
COMMENT_LINE $082D note:
COMMENT_LINE $082D Due to DIVs and MULs, this function does take some time
COMMENT_LINE $082D maybe a few thousand cycles for LARGE VLISTs.
COMMENT_LINE $082D Therefor do zeroing + positioning AFTER calling this functions
COMMENT_LINE $082D otherwise vectrex beam drifts away a bit!
COMMENT_LINE $082D Noticeable on a real vectrex or in DVE when Drift is
COMMENT_LINE $082D = to something different than 0 (in *.ini)
COMMENT_LINE $082D note:
COMMENT_LINE $082D Expects now VLists, that have X vector strength of 16, 32, or 64
COMMENT_LINE $082D Gabage will produced else...
COMMENT_LINE $082D note:
COMMENT_LINE $082D using Y as shown in ';' saves a couple of cycles.
COMMENT $082D but here the code still uses c8
COMMENT $082D remember clipping edge
FORCE_SYMBOL $082D clip_test
FORCE_NO_SYMBOL $0830
COMMENT $0834 pretty for optimizing to use a makro :-)
COMMENT $0834 address of result list
FORCE_SYMBOL $0834 clipped_vector_list
FORCE_NO_SYMBOL $0837
COMMENT $083A clip starts at 0
FORCE_SYMBOL $083A clip_counter
COMMENT_LINE $083C we add to this each strength
COMMENT_LINE $083C of a vector
COMMENT $083C when first vector will be invisible
COMMENT $083E default pattern is 0, invisible
FORCE_SYMBOL $083E clip_pattern
COMMENT $0840 compare current 'place'
FORCE_SYMBOL $0840 clip_counter
COMMENT $0842 with clipping edge
FORCE_SYMBOL $0842 clip_test
COMMENT $0845 if lower... the start of this
COMMENT_LINE $0847 current vector is visible -> branch
COMMENT_LINE $0847 otherwise the start was not visible
FORCE_NO_SYMBOL $0847
COMMENT $0849 get current Vector strength
COMMENT $084B remember it as v0
FORCE_SYMBOL $084B v0
COMMENT $084D extend it X part
COMMENT $084E and adjust clip_counter
FORCE_SYMBOL $084E clip_counter
COMMENT $0850 store it
FORCE_SYMBOL $0850 clip_counter
COMMENT_LINE $0852 clip counter has vector
COMMENT_LINE $0852 'position' at the end
COMMENT_LINE $0852 of current vector
COMMENT $0852 test for clipping edge
FORCE_SYMBOL $0852 clip_test
COMMENT $085D one invisible the other visible? -> branch
COMMENT_LINE $085F both vector ends are invisible
COMMENT $0863 pattern is 0
COMMENT $0865 load current Vector
FORCE_SYMBOL $0865 v0
COMMENT $0867 store it also
COMMENT $086B pattern = 1 ends VList
FORCE_NO_SYMBOL $086B
COMMENT $086D store it
FORCE_NO_SYMBOL $086D
COMMENT $086F load X with correct vlpr
FORCE_SYMBOL $086F clipped_vector_list
COMMENT $0872 reset dp to d0
FORCE_NO_SYMBOL $0872
COMMENT $0876 pretty for optimizing to use a makro :-)
COMMENT $0876 but here the code still uses c8
COMMENT $0876 return
COMMENT $0877 test for clipping edge
FORCE_SYMBOL $0877 clip_test
COMMENT $087C pattern is 0
COMMENT $087E load current Vector
FORCE_SYMBOL $087E v0
COMMENT $0880 store it also
COMMENT_LINE $0882 BRA     was_visible_vlpr
FORCE_NO_SYMBOL $0882
COMMENT $0884 get current Vector
COMMENT $0886 remember it as v0
FORCE_SYMBOL $0886 v0
COMMENT $0888 extend it x0 part
COMMENT $0889 and adjuct clip_counter
FORCE_SYMBOL $0889 clip_counter
COMMENT $088B store it
FORCE_SYMBOL $088B clip_counter
COMMENT_LINE $088D clip counter has vector
COMMENT_LINE $088D 'position' at the end
COMMENT_LINE $088D of current vector
COMMENT $0893 test for clipping edge
FORCE_SYMBOL $0893 clip_test
COMMENT $0896 if the whole is visible -> branch
COMMENT $0898 use full pattern
FORCE_NO_SYMBOL $0898
COMMENT $089A store in vlist
COMMENT $089C load current Vector
FORCE_SYMBOL $089C v0
COMMENT $089E store it also
COMMENT $08A0 no? -> branch
FORCE_SYMBOL $08A2 clip_pattern
COMMENT $08A4 leaves with v1 and v2 calculated
COMMENT_LINE $08A4 first setup x1 and x2 according to clipping
COMMENT_LINE $08A4 information
FORCE_SYMBOL $08A4 clip_test
COMMENT $08A6 part of vector that is visible (or vice versa)
FORCE_SYMBOL $08A6 x2
FORCE_SYMBOL $08A8 x0
COMMENT $08AB part of vector that is invisible (or vice versa)
FORCE_SYMBOL $08AB x1
COMMENT_LINE $08AD now we have to calculate the Y part of the two
COMMENT_LINE $08AD halves
COMMENT_LINE $08AD Y1/X1 and Y2/X2 should be like Y0/X0
COMMENT_LINE $08AD X0 = original length
COMMENT_LINE $08AD than Y1 = Y0*X1/X0
COMMENT_LINE $08AD than Y2 = Y0*X2/X0
COMMENT_LINE $08AD but we know that Y1 + Y2 = Y0
COMMENT_LINE $08AD -> Y2 = Y0 - Y1
COMMENT_LINE $08AD div cycles depend on size of tmp1
COMMENT_LINE $08AD the bigger tmp1 the faster div
COMMENT_LINE $08AD we do div and mul unsigned
COMMENT_LINE $08AD so check for signness here
COMMENT_LINE $08AD and adjust later
FORCE_SYMBOL $08AE neggi
FORCE_SYMBOL $08B0 x0
FORCE_SYMBOL $08B4 neggi
FORCE_NO_SYMBOL $08B7
FORCE_NO_SYMBOL $08BB
FORCE_SYMBOL $08BF y0
FORCE_SYMBOL $08C3 neggi
FORCE_SYMBOL $08C6 x1
FORCE_SYMBOL $08CA neggi
COMMENT $08CE this divides d by 64
COMMENT $08CF result in A
FORCE_SYMBOL $08D2 neggi
COMMENT $08D7 store y1
FORCE_SYMBOL $08D7 y1
COMMENT $08D9 -y1 + y0 = y0 - y1 = y2
FORCE_SYMBOL $08DA y0
COMMENT $08DC store y2
FORCE_SYMBOL $08DC y2
FORCE_SYMBOL $08E0 y0
FORCE_SYMBOL $08E4 neggi
FORCE_SYMBOL $08E7 x1
FORCE_SYMBOL $08EB neggi
FORCE_SYMBOL $08F1 y0
FORCE_SYMBOL $08F5 neggi
FORCE_SYMBOL $08F8 x1
FORCE_SYMBOL $08FC neggi
FORCE_SYMBOL $090A neggi
COMMENT $090F store y1
FORCE_SYMBOL $090F y1
COMMENT $0911 -y1 + y0 = y0 - y1 = y2
FORCE_SYMBOL $0912 y0
COMMENT $0914 store y2
FORCE_SYMBOL $0914 y2
COMMENT $0916 get pattern
FORCE_SYMBOL $0916 clip_pattern
COMMENT $0918 store it
COMMENT $091A build vector from X1 and Y1
FORCE_SYMBOL $091A v1
COMMENT $091C store it to list
COMMENT $091E get pattern and
FORCE_SYMBOL $091E clip_pattern
COMMENT $0920 reverse it
COMMENT $0921 store it
COMMENT $0923 build vector from X2 and Y2
FORCE_SYMBOL $0923 v2
COMMENT $0925 store it to list
COMMENT $0927 do next
FORCE_SYMBOL $0927 do_next_vector_vlpr
COMMENT_LINE $092A ***************************************************************************
COMMENT_LINE $092A D = clipping place (in scale of added strengths of vector X positions)
COMMENT_LINE $092A X = Vector list
COMMENT_LINE $092A returns new vector list pointer in X
COMMENT_LINE $092A result list has following format
COMMENT_LINE $092A DB pattern, y, x
COMMENT_LINE $092A DB pattern, y, x
COMMENT_LINE $092A DB ... (till counter is 1)
COMMENT_LINE $092A result in Drawvlpr type Vector list
COMMENT_LINE $092A clip vectors EXACTLY!
COMMENT_LINE $092A note:
COMMENT_LINE $092A Due to DIVs and MULs, this function does take some time
COMMENT_LINE $092A maybe a few thousand cycles for LARGE VLISTs.
COMMENT_LINE $092A Therefor do zeroing + positioning AFTER calling this functions
COMMENT_LINE $092A otherwise vectrex beam drifts away a bit!
COMMENT_LINE $092A Noticeable on a real vectrex or in DVE when Drift is
COMMENT_LINE $092A = to something different than 0 (in *.ini)
COMMENT_LINE $092A note:
COMMENT_LINE $092A Expects now VLists, that have X vector strength of 16, 32, or 64
COMMENT_LINE $092A Gabage will produced else...
COMMENT $092A but here the code still uses c8
COMMENT $092A remember clipping edge
FORCE_SYMBOL $092A clip_test
FORCE_NO_SYMBOL $092D
COMMENT $0931 pretty for optimizing to use a makro :-)
FORCE_SYMBOL $0931 DIGIT_VLP_RELOAD
FORCE_SYMBOL $0933 clip_line_counter
COMMENT $0935 address of result list
FORCE_SYMBOL $0935 clipped_vector_list
FORCE_NO_SYMBOL $0938
COMMENT $093B clip starts at 0
FORCE_SYMBOL $093B clip_counter
COMMENT_LINE $093D we add to this each strength
COMMENT_LINE $093D of a vector
COMMENT $093D when first vector will be invisible
COMMENT $093F default pattern is 0, invisible
FORCE_SYMBOL $093F clip_pattern
COMMENT $0941 compare current 'place'
FORCE_SYMBOL $0941 clip_counter
COMMENT $0943 with clipping edge
FORCE_SYMBOL $0943 clip_test
COMMENT $0946 if higher... the start of this
COMMENT_LINE $0948 current vector is visible -> branch
FORCE_SYMBOL $0948 clip_line_counter
FORCE_SYMBOL $094C DIGIT_VLP_RELOAD
FORCE_SYMBOL $094E clip_line_counter
COMMENT $0950 get timer
FORCE_SYMBOL $0950 VIA_t2_hi
FORCE_SYMBOL $0953 T2_TIMER_PEROID_REAL
COMMENT $0955 and store it
FORCE_SYMBOL $0955 digit_next_digit_cycle
COMMENT $0958 load the next sample_byte to A
COMMENT $095A store in reg A in 6522 (DAC)
FORCE_SYMBOL $095A VIA_port_a
COMMENT $095D this sets the MUX of 6522 to PSG
COMMENT $095D load the calculated VIA B
FORCE_SYMBOL $095D via_b_start
COMMENT $0960 write back to reg B in 6522
FORCE_SYMBOL $0960 VIA_port_b
COMMENT $0963 Clear shift regigster, why ???
FORCE_SYMBOL $0963 VIA_shift_reg
COMMENT $0966 and disable the mux, so no junk will
FORCE_SYMBOL $0966 VIA_port_b
COMMENT_LINE $0969 otherwise the start was not visible
FORCE_NO_SYMBOL $0969
COMMENT $096B get current Vector strength
COMMENT $096D remember it as v0
FORCE_SYMBOL $096D v0
COMMENT $096F extend it X part
COMMENT $0970 and adjust clip_counter
FORCE_SYMBOL $0970 clip_counter
COMMENT $0972 store it
FORCE_SYMBOL $0972 clip_counter
COMMENT_LINE $0974 clip counter has vector
COMMENT_LINE $0974 'position' at the end
COMMENT_LINE $0974 of current vector
COMMENT $0974 test for clipping edge
FORCE_SYMBOL $0974 clip_test
COMMENT $097F one invisible the other visible? -> branch
COMMENT_LINE $0981 both vector ends are invisible
COMMENT $0985 pattern is 0
COMMENT $0987 load current Vector
FORCE_SYMBOL $0987 v0
COMMENT $0989 store it also
FORCE_SYMBOL $098B clip_line_counter
COMMENT $098F pattern = 1 ends VList
FORCE_NO_SYMBOL $098F
COMMENT $0991 store it
FORCE_NO_SYMBOL $0991
COMMENT $0993 load X with correct vlpr
FORCE_SYMBOL $0993 clipped_vector_list
COMMENT $0996 reset dp to d0
FORCE_NO_SYMBOL $0996
COMMENT $099A pretty for optimizing to use a makro :-)
COMMENT $099A but here the code still uses c8
COMMENT $099A return
COMMENT $099B test for clipping edge
FORCE_SYMBOL $099B clip_test
COMMENT $09A0 pattern is 0
COMMENT $09A2 load current Vector
FORCE_SYMBOL $09A2 v0
COMMENT $09A4 store it also
COMMENT_LINE $09A6 BRA     was_visible_vlprd
FORCE_SYMBOL $09A6 clip_line_counter
FORCE_SYMBOL $09AA DIGIT_VLP_RELOAD
FORCE_SYMBOL $09AC clip_line_counter
COMMENT $09AE get timer
FORCE_SYMBOL $09AE VIA_t2_hi
FORCE_SYMBOL $09B1 T2_TIMER_PEROID_REAL
COMMENT $09B3 and store it
FORCE_SYMBOL $09B3 digit_next_digit_cycle
COMMENT $09B6 load the next sample_byte to A
COMMENT $09B8 store in reg A in 6522 (DAC)
FORCE_SYMBOL $09B8 VIA_port_a
COMMENT $09BB this sets the MUX of 6522 to PSG
COMMENT $09BB load the calculated VIA B
FORCE_SYMBOL $09BB via_b_start
COMMENT $09BE write back to reg B in 6522
FORCE_SYMBOL $09BE VIA_port_b
COMMENT $09C1 Clear shift regigster, why ???
FORCE_SYMBOL $09C1 VIA_shift_reg
COMMENT $09C4 and disable the mux, so no junk will
FORCE_SYMBOL $09C4 VIA_port_b
FORCE_NO_SYMBOL $09C7
COMMENT $09C9 get current Vector
COMMENT $09CB remember it as v0
FORCE_SYMBOL $09CB v0
COMMENT $09CD extend it x0 part
COMMENT $09CE and adjuct clip_counter
FORCE_SYMBOL $09CE clip_counter
COMMENT $09D0 store it
FORCE_SYMBOL $09D0 clip_counter
COMMENT_LINE $09D2 clip counter has vector
COMMENT_LINE $09D2 'position' at the end
COMMENT_LINE $09D2 of current vector
COMMENT $09D8 test for clipping edge
FORCE_SYMBOL $09D8 clip_test
COMMENT $09DB if the whole is visible -> branch
COMMENT $09DD use full pattern
FORCE_NO_SYMBOL $09DD
COMMENT $09DF store in vlist
COMMENT $09E1 load current Vector
FORCE_SYMBOL $09E1 v0
COMMENT $09E3 store it also
FORCE_SYMBOL $09E5 clip_line_counter
COMMENT $09E7 no? -> branch
FORCE_SYMBOL $09E9 clip_pattern
COMMENT $09EB leaves with v1 and v2 calculated
COMMENT_LINE $09EB first setup x1 and x2 according to clipping
COMMENT_LINE $09EB information
FORCE_SYMBOL $09EB clip_test
COMMENT $09ED part of vector that is visible (or vice versa)
FORCE_SYMBOL $09ED x2
FORCE_SYMBOL $09EF x0
COMMENT $09F2 part of vector that is invisible (or vice versa)
FORCE_SYMBOL $09F2 x1
COMMENT_LINE $09F4 now we have to calculate the Y part of the two
COMMENT_LINE $09F4 halves
COMMENT_LINE $09F4 Y1/X1 and Y2/X2 should be like Y0/X0
COMMENT_LINE $09F4 X0 = original length
COMMENT_LINE $09F4 than Y1 = Y0*X1/X0
COMMENT_LINE $09F4 than Y2 = Y0*X2/X0
COMMENT_LINE $09F4 but we know that Y1 + Y2 = Y0
COMMENT_LINE $09F4 -> Y2 = Y0 - Y1
COMMENT_LINE $09F4 div cycles depend on size of tmp1
COMMENT_LINE $09F4 the bigger tmp1 the faster div
COMMENT_LINE $09F4 we do div and mul unsigned
COMMENT_LINE $09F4 so check for signness here
COMMENT_LINE $09F4 and adjust later
FORCE_SYMBOL $09F5 neggi
FORCE_SYMBOL $09F7 x0
FORCE_SYMBOL $09FB neggi
FORCE_NO_SYMBOL $09FE
FORCE_NO_SYMBOL $0A02
FORCE_SYMBOL $0A06 y0
FORCE_SYMBOL $0A0A neggi
FORCE_SYMBOL $0A0D x1
FORCE_SYMBOL $0A11 neggi
COMMENT $0A15 this divides d by 64
COMMENT $0A16 result in A
FORCE_SYMBOL $0A19 neggi
COMMENT $0A1E store y1
FORCE_SYMBOL $0A1E y1
COMMENT $0A20 -y1 + y0 = y0 - y1 = y2
FORCE_SYMBOL $0A21 y0
COMMENT $0A23 store y2
FORCE_SYMBOL $0A23 y2
FORCE_SYMBOL $0A27 y0
FORCE_SYMBOL $0A2B neggi
FORCE_SYMBOL $0A2E x1
FORCE_SYMBOL $0A32 neggi
FORCE_SYMBOL $0A38 y0
FORCE_SYMBOL $0A3C neggi
FORCE_SYMBOL $0A3F x1
FORCE_SYMBOL $0A43 neggi
FORCE_SYMBOL $0A51 neggi
COMMENT $0A56 store y1
FORCE_SYMBOL $0A56 y1
COMMENT $0A58 -y1 + y0 = y0 - y1 = y2
FORCE_SYMBOL $0A59 y0
COMMENT $0A5B store y2
FORCE_SYMBOL $0A5B y2
COMMENT $0A5D get pattern
FORCE_SYMBOL $0A5D clip_pattern
COMMENT $0A5F store it
COMMENT $0A61 build vector from X1 and Y1
FORCE_SYMBOL $0A61 v1
COMMENT $0A63 store it to list
COMMENT $0A65 get pattern and
FORCE_SYMBOL $0A65 clip_pattern
COMMENT $0A67 reverse it
COMMENT $0A68 store it
COMMENT $0A6A build vector from X2 and Y2
FORCE_SYMBOL $0A6A v2
COMMENT $0A6C store it to list
FORCE_SYMBOL $0A6E clip_line_counter
FORCE_SYMBOL $0A70 clip_line_counter
FORCE_SYMBOL $0A72 clip_line_counter
COMMENT $0A74 do next
FORCE_SYMBOL $0A74 do_next_vector_vlprd
COMMENT_LINE $0A77 ***************************************************************************
COMMENT $0A77 following code uses d0
COMMENT_LINE $0A77 ***************************************************************************
FORCE_SYMBOL $0A77 ym_data_current
FORCE_NO_SYMBOL $0A7C
FORCE_SYMBOL $0A7F ym_data_current
FORCE_SYMBOL $0A83 current_register
FORCE_SYMBOL $0A86 ym_data_start
FORCE_SYMBOL $0A89 get_current_byte
FORCE_SYMBOL $0A8C current_register
COMMENT_LINE $0A8F A PSG reg
COMMENT_LINE $0A8F B data
FORCE_SYMBOL $0A8F Sound_Byte
FORCE_SYMBOL $0A92 STRUCTURE_LENGTH
FORCE_SYMBOL $0A94 current_register
FORCE_SYMBOL $0A97 current_register
FORCE_NO_SYMBOL $0A9A
COMMENT_LINE $0A9F no we must look at the bits
COMMENT_LINE $0A9F a will be our bit register
COMMENT_LINE $0A9F ;;;;;;;;;;;;;;;;;; GET_BIT START
FORCE_SYMBOL $0A9F BIT_POSITION
COMMENT_LINE $0AA3 load a new byte
FORCE_SYMBOL $0AA3 BYTE_POSITION
FORCE_SYMBOL $0AA7 CURRENT_BYTE
FORCE_SYMBOL $0AA9 BYTE_POSITION
FORCE_NO_SYMBOL $0AAB
FORCE_SYMBOL $0AAD BIT_POSITION
COMMENT_LINE $0AAF bit position correct here
COMMENT_LINE $0AAF remember we use one bit now!
FORCE_SYMBOL $0AAF BIT_POSITION
COMMENT_LINE $0AB1 is the bit at the current position set?
FORCE_SYMBOL $0AB1 CURRENT_BYTE
COMMENT_LINE $0AB3 ;;;;;;;;;;;;;;;;;; GET_BIT END
COMMENT_LINE $0AB3 zero flag show bit
COMMENT_LINE $0AB3 A is 1 or zero
COMMENT_LINE $0AB7 must be zero
COMMENT_LINE $0AB7 1 is allways only 8 bit...
FORCE_SYMBOL $0AB9 calc_bits
FORCE_SYMBOL $0ABC calc_coder
FORCE_SYMBOL $0ABF calc_coder
COMMENT $0AC2 increase used bits
FORCE_SYMBOL $0AC2 calc_bits
COMMENT_LINE $0AC5 ;;;;;;;;;;; GET_BIT_START
FORCE_SYMBOL $0AC5 BIT_POSITION
COMMENT_LINE $0AC9 load a new byte
FORCE_SYMBOL $0AC9 BYTE_POSITION
FORCE_SYMBOL $0ACD CURRENT_BYTE
FORCE_SYMBOL $0ACF BYTE_POSITION
FORCE_NO_SYMBOL $0AD1
FORCE_SYMBOL $0AD3 BIT_POSITION
COMMENT_LINE $0AD5 bit position correct here
COMMENT_LINE $0AD5 remember we use one bit now!
FORCE_SYMBOL $0AD5 BIT_POSITION
COMMENT_LINE $0AD7 is the bit at the current position set?
FORCE_SYMBOL $0AD7 CURRENT_BYTE
COMMENT $0AD9 and if non zero
FORCE_SYMBOL $0ADB calc_coder
COMMENT_LINE $0ADE ;;;;;;;;;;; GET_BIT_END
COMMENT_LINE $0ADE we load one complete = of mapper index, bits, coder, map-value
FORCE_SYMBOL $0ADE CURRENT_RLE_MAPPER
FORCE_NO_SYMBOL $0AE0
COMMENT $0AE2 load bits from map
FORCE_NO_SYMBOL $0AE2
COMMENT $0AE4 map out phrases
FORCE_NO_SYMBOL $0AE4
COMMENT $0AE6 neu
FORCE_SYMBOL $0AE6 calc_bits
COMMENT $0AE9 neu
COMMENT $0AED load coder-byte
FORCE_NO_SYMBOL $0AED
FORCE_SYMBOL $0AEF calc_coder
COMMENT $0AF4 load current mapped byte!
FORCE_NO_SYMBOL $0AF4
COMMENT_LINE $0AF6 in b is the byte value we sought
COMMENT_LINE $0AF6 test for phrase
COMMENT $0AF6 load bits from map
FORCE_NO_SYMBOL $0AF6
COMMENT $0AF8 map in phrases only
FORCE_NO_SYMBOL $0AF8
COMMENT_LINE $0AFC if phrase, than in b the count of the phrase used
FORCE_SYMBOL $0AFC CURRENT_PHRASE_START
FORCE_SYMBOL $0B08 CURRENT_IS_PHRASE
FORCE_SYMBOL $0B0A CURRENT_PHRASE_BYTE
FORCE_SYMBOL $0B0E CURRENT_IS_PHRASE
FORCE_SYMBOL $0B12 CURRENT_UNPACKED_BYTE
COMMENT_LINE $0B14 U pointer to data structure
COMMENT_LINE $0B14 A number of register
COMMENT_LINE $0B14 do we have a byte that is valid?
FORCE_SYMBOL $0B14 CURRENT_RLE_COUNTER
COMMENT_LINE $0B18 yep... use current byte
FORCE_SYMBOL $0B18 CURRENT_IS_PHRASE
COMMENT $0B1C length of phrase
FORCE_SYMBOL $0B1E CURRENT_PHRASE_BYTE
COMMENT $0B20 this is the current byte
FORCE_SYMBOL $0B22 CURRENT_UNPACKED_BYTE
FORCE_SYMBOL $0B24 CURRENT_PHRASE_BYTE
FORCE_SYMBOL $0B26 CURRENT_PHRASE_BYTE
FORCE_SYMBOL $0B2A CURRENT_PHRASE_BYTE
FORCE_SYMBOL $0B2C CURRENT_RLE_COUNTER
FORCE_NO_SYMBOL $0B2E
FORCE_SYMBOL $0B31 CURRENT_RLE_COUNTER
FORCE_SYMBOL $0B33 CURRENT_UNPACKED_BYTE
COMMENT_LINE $0B36 non single byte here... must decode
COMMENT_LINE $0B36 first we look for how many bits the RLE counter spreads
COMMENT_LINE $0B36 we already encountered a 1
COMMENT_LINE $0B36 and we allways use + 2
FORCE_NO_SYMBOL $0B36
FORCE_SYMBOL $0B38 temp
FORCE_SYMBOL $0B3B temp
COMMENT_LINE $0B3E ;;;;;;;;;;;;;;;;;; GET_BIT START
FORCE_SYMBOL $0B3E BIT_POSITION
COMMENT_LINE $0B42 load a new byte
FORCE_SYMBOL $0B42 BYTE_POSITION
FORCE_SYMBOL $0B46 CURRENT_BYTE
FORCE_SYMBOL $0B48 BYTE_POSITION
FORCE_NO_SYMBOL $0B4A
FORCE_SYMBOL $0B4C BIT_POSITION
COMMENT_LINE $0B4E bit position correct here
COMMENT_LINE $0B4E remember we use one bit now!
FORCE_SYMBOL $0B4E BIT_POSITION
COMMENT_LINE $0B50 is the bit at the current position set?
FORCE_SYMBOL $0B50 CURRENT_BYTE
COMMENT_LINE $0B52 ;;;;;;;;;;;;;;;;;; GET_BIT END
COMMENT_LINE $0B54 in temp is the # of bits for the counter
COMMENT_LINE $0B54 the following '#temp' bits represent the RLE count
COMMENT_LINE $0B54 lsb first
COMMENT $0B54 we start at 1, since zero is an
COMMENT_LINE $0B55 'own' 'subroutine',
COMMENT_LINE $0B55 which doesn't manipulate the temps
COMMENT $0B55 bit counter for shifting
FORCE_SYMBOL $0B55 temp2
COMMENT $0B58 bit counter for shifting
FORCE_SYMBOL $0B58 temp3
COMMENT_LINE $0B5B ;;;;;;;;;;;;;;;;;; GET_BIT START
FORCE_SYMBOL $0B5B BIT_POSITION
COMMENT_LINE $0B5F load a new byte
FORCE_SYMBOL $0B5F BYTE_POSITION
FORCE_SYMBOL $0B63 CURRENT_BYTE
FORCE_SYMBOL $0B65 BYTE_POSITION
FORCE_NO_SYMBOL $0B67
FORCE_SYMBOL $0B69 BIT_POSITION
COMMENT_LINE $0B6B bit position correct here
COMMENT_LINE $0B6B remember we use one bit now!
FORCE_SYMBOL $0B6B BIT_POSITION
COMMENT_LINE $0B6D is the bit at the current position set?
FORCE_SYMBOL $0B6D CURRENT_BYTE
COMMENT_LINE $0B71 return 1
FORCE_NO_SYMBOL $0B71
COMMENT_LINE $0B73 ;;;;;;;;;;;;;;;;;; GET_BIT END
COMMENT_LINE $0B73 in D now one bit at the right position for the RLE counter
COMMENT_LINE $0B75 the first 3 (here only the first one) rounds
COMMENT_LINE $0B75 we need not check for temp, since it is at least 3...
COMMENT_LINE $0B75 ;;;;;;;;;;;;;;;;;; GET_BIT START
FORCE_SYMBOL $0B75 BIT_POSITION
COMMENT_LINE $0B79 load a new byte
FORCE_SYMBOL $0B79 BYTE_POSITION
FORCE_SYMBOL $0B7D CURRENT_BYTE
FORCE_SYMBOL $0B7F BYTE_POSITION
FORCE_NO_SYMBOL $0B81
FORCE_SYMBOL $0B83 BIT_POSITION
COMMENT_LINE $0B85 bit position correct here
COMMENT_LINE $0B85 remember we use one bit now!
FORCE_SYMBOL $0B85 BIT_POSITION
COMMENT_LINE $0B87 is the bit at the current position set?
FORCE_SYMBOL $0B87 CURRENT_BYTE
COMMENT_LINE $0B8B return 1
FORCE_NO_SYMBOL $0B8B
COMMENT $0B8E LSR A
COMMENT $0B8F LSR B
COMMENT $0B90 if no carry, than exit
COMMENT $0B92 otherwise underflow from A to 7bit of B
FORCE_NO_SYMBOL $0B92
FORCE_SYMBOL $0B94 temp3
COMMENT_LINE $0B99 in D now one bit at the right position for the RLE counter
FORCE_SYMBOL $0B99 CURRENT_RLE_COUNTER
FORCE_SYMBOL $0B9B CURRENT_RLE_COUNTER
FORCE_SYMBOL $0B9D temp2
FORCE_SYMBOL $0BA0 temp2
FORCE_SYMBOL $0BA3 temp3
FORCE_SYMBOL $0BA6 temp
COMMENT_LINE $0BAB now the current counter should be set
COMMENT_LINE $0BAB we still need to dechifer the following byte...
FORCE_SYMBOL $0BAB dechifer
FORCE_SYMBOL $0BAE ym_data_start
FORCE_SYMBOL $0BB4 Clear_x_d
FORCE_NO_SYMBOL $0BBA
FORCE_SYMBOL $0BBC ym_data_len
FORCE_SYMBOL $0BBF ym_data_current
FORCE_NO_SYMBOL $0BC2
FORCE_SYMBOL $0BC7 CURRENT_RLE_MAPPER
FORCE_SYMBOL $0BCD CURRENT_PHRASE_START
FORCE_SYMBOL $0BD3 BYTE_POSITION
FORCE_SYMBOL $0BD6 STRUCTURE_LENGTH
FORCE_SYMBOL $0BDB ym_name
COMMENT $0BDF following code uses d0
COMMENT_LINE $0BDF ***************************************************************************
COMMENT_LINE $0BDF expects startposition in D
COMMENT_LINE $0BDF expects length in X
COMMENT_LINE $0BDF sets up Y register, this should under no circumstances be destroyed
FORCE_SYMBOL $0BDF digit_structure_pos
FORCE_NO_SYMBOL $0BE2
COMMENT $0BE4 store new start position
FORCE_SYMBOL $0BE4 digit_start_pos
FORCE_NO_SYMBOL $0BE7
FORCE_NO_SYMBOL $0BE9
FORCE_SYMBOL $0BEB digit_structure_pos_current
COMMENT $0BEE calculate end position
FORCE_SYMBOL $0BEE digit_start_pos
COMMENT $0BF1 and store it
FORCE_SYMBOL $0BF1 digit_end_pos
COMMENT $0BF4 sound is playing is ON
FORCE_NO_SYMBOL $0BF4
COMMENT $0BF6 sound is playing
FORCE_SYMBOL $0BF6 digit_is_playing
COMMENT $0BF9 calculate out first VIA B poke
COMMENT $0BF9 data reg B from 6522
FORCE_SYMBOL $0BF9 VIA_port_b
COMMENT $0BFB save top 5 bits, mask off bottom 3
FORCE_NO_SYMBOL $0BFB
COMMENT $0BFD set S/H, SEL 0, SEL 1
FORCE_NO_SYMBOL $0BFD
COMMENT $0BFF and remember it
FORCE_SYMBOL $0BFF via_b_start
COMMENT $0C02 initialize Y to position in sample data
FORCE_SYMBOL $0C02 digit_end_pos
COMMENT $0C06 Clear_Sound
FORCE_NO_SYMBOL $0C06
FORCE_SYMBOL $0C09 Sound_Byte
COMMENT $0C0F load timer
FORCE_SYMBOL $0C0F VIA_t2_hi
FORCE_SYMBOL $0C11 T2_TIMER_PEROID_REAL
COMMENT $0C13 and store it
FORCE_SYMBOL $0C13 digit_next_digit_cycle
COMMENT_LINE $0C16 JSR     switch_to_digit
COMMENT $0C16 back
COMMENT_LINE $0C17 ***************************************************************************
COMMENT_LINE $0C17 now the makros from above as functions...
COMMENT_LINE $0C17 shortens the source...
COMMENT_LINE $0C17 ***************************************************************************
COMMENT $0C17 go to waiting
FORCE_SYMBOL $0C19 T2_TIMER_PEROID_REAL
COMMENT $0C1B and store it
FORCE_SYMBOL $0C1B digit_next_digit_cycle
COMMENT $0C1E play a sample directly, but with test
COMMENT $0C1E is there a digital sample to be played?
FORCE_SYMBOL $0C1E digit_is_playing
COMMENT $0C21 no, than jump out of here
COMMENT $0C23 load the next sample_byte to A
FORCE_SYMBOL $0C25 digit_start_pos
COMMENT $0C29 with this sample, otherwise we continue further below
FORCE_SYMBOL $0C2B digit_structure_pos_current
FORCE_NO_SYMBOL $0C2F
FORCE_SYMBOL $0C33 digit_structure_pos
COMMENT $0C37 is this sample a looping one?
COMMENT $0C39 store it to is_playing
FORCE_SYMBOL $0C39 digit_is_playing
COMMENT $0C3C if none looping... we are done
COMMENT_LINE $0C3E JSR     switch_to_ym
COMMENT $0C3E if none looping... we are done
COMMENT $0C42 store new start position
FORCE_SYMBOL $0C42 digit_start_pos
FORCE_SYMBOL $0C47 digit_structure_pos_current
COMMENT $0C4B calculate end position
FORCE_SYMBOL $0C4B digit_start_pos
COMMENT $0C4E and store it
FORCE_SYMBOL $0C4E digit_end_pos
COMMENT_LINE $0C51 ok, for restart, we only change current position
COMMENT $0C51 load the start position
COMMENT_LINE $0C53 this is the end_position of the sample,
COMMENT_LINE $0C53 since we go backwards
COMMENT $0C53 next byte
COMMENT_LINE $0C55 is played next round...
COMMENT_LINE $0C55 and store it to the 6522 -> PSG
COMMENT $0C55 store in reg A in 6522 (DAC)
FORCE_SYMBOL $0C55 VIA_port_a
COMMENT_LINE $0C57 following must come after the above, or we
COMMENT_LINE $0C57 put noise to the psg,
COMMENT_LINE $0C57 likewise, before storing anything else to
COMMENT_LINE $0C57 port A, we will disable the connection to PSG
COMMENT $0C57 this sets the MUX of 6522 to PSG
COMMENT $0C57 load the calculated VIA B
FORCE_SYMBOL $0C57 via_b_start
COMMENT $0C5A write back to reg B in 6522
FORCE_SYMBOL $0C5A VIA_port_b
COMMENT $0C5C Clear shift regigster, why ???
FORCE_SYMBOL $0C5C VIA_shift_reg
COMMENT_LINE $0C5E without it, the display 'wobbles' a bit???
COMMENT $0C5E and disable the mux, so no junk will
FORCE_SYMBOL $0C5E VIA_port_b
COMMENT_LINE $0C60 enter our PSG-DAC...
COMMENT $0C60 load timer
FORCE_SYMBOL $0C60 VIA_t2_hi
COMMENT $0C62 interrupt_miss
COMMENT $0C64 otherwise look if we should play a sample
FORCE_SYMBOL $0C64 digit_next_digit_cycle
COMMENT $0C67 yep... do it than
COMMENT $0C69 otherwise... did an inerrupt occur?
FORCE_NO_SYMBOL $0C69
COMMENT $0C6B test for interrupt
FORCE_SYMBOL $0C6B VIA_int_flags
COMMENT $0C6D if no interrupt keep on testing
COMMENT $0C6F Store refresh value
FORCE_NO_SYMBOL $0C6F
COMMENT $0C72 into timer t2
FORCE_SYMBOL $0C72 VIA_t2_lo
COMMENT $0C76 next sample output timer
FORCE_SYMBOL $0C76 T2_TIMER_PEROID_REAL
COMMENT $0C78 store it
FORCE_SYMBOL $0C78 digit_next_digit_cycle
COMMENT_LINE $0C7B note: for low sample rates
COMMENT_LINE $0C7B we could use a normal MOVE
COMMENT_LINE $0C7B and save probably
COMMENT_LINE $0C7B a thousand or more cycles!
COMMENT_LINE $0C7B since THIS MOVE first
COMMENT_LINE $0C7B outputs an sample!
COMMENT_LINE $0C7B (which also means waiting for the sample)
COMMENT $0C7B set the fixed scale factor we will use...
FORCE_NO_SYMBOL $0C7B
COMMENT $0C7D move to time 1 lo, this means scaling
FORCE_SYMBOL $0C7D VIA_t1_cnt_lo
COMMENT $0C7F load the next pos, super long saturation
FORCE_NO_SYMBOL $0C7F
COMMENT $0C82 move to d -> must be achieved
FORCE_SYMBOL $0C82 move_to_d_digit
FORCE_NO_SYMBOL $0C85
COMMENT $0C87 blank low and zero low
FORCE_SYMBOL $0C87 VIA_cntl
COMMENT $0C89 load the next pos, super long saturation
FORCE_NO_SYMBOL $0C89
COMMENT $0C8C move to d -> must be achieved
FORCE_SYMBOL $0C8C move_to_d_digit
FORCE_NO_SYMBOL $0C8F
COMMENT $0C91 /BLANK low and /ZERO low
FORCE_SYMBOL $0C91 VIA_cntl
FORCE_NO_SYMBOL $0C93
COMMENT $0C96 mux=1, disable mux
FORCE_SYMBOL $0C96 VIA_port_b
COMMENT $0C98 clear D/A register
FORCE_SYMBOL $0C98 VIA_port_a
COMMENT $0C9A mux=1, enable mux
FORCE_SYMBOL $0C9A VIA_port_b
COMMENT $0C9C do it again
FORCE_SYMBOL $0C9C VIA_port_b
FORCE_NO_SYMBOL $0C9E
COMMENT $0CA0 disable mux
FORCE_SYMBOL $0CA0 VIA_port_b
COMMENT $0CA2 rethink our VIAB value
COMMENT $0CA2 data reg B from 6522
FORCE_SYMBOL $0CA2 VIA_port_b
COMMENT $0CA4 save top 5 bits, mask off bottom 3
FORCE_NO_SYMBOL $0CA4
COMMENT $0CA6 set S/H, SEL 0, SEL 1
FORCE_NO_SYMBOL $0CA6
COMMENT $0CA8 and remember it
FORCE_SYMBOL $0CA8 via_b_start
COMMENT $0CAB and do one sample-byte
COMMENT $0CAB wait till the last played
COMMENT $0CAB get timer
FORCE_SYMBOL $0CAB VIA_t2_hi
COMMENT_LINE $0CAD note:
COMMENT_LINE $0CAD by reading the timer we
COMMENT_LINE $0CAD can MISS an interrupt state
COMMENT_LINE $0CAD since reading clears the
COMMENT_LINE $0CAD interrupt!
COMMENT_LINE $0CAD during recalibration this
COMMENT_LINE $0CAD is considered (see below)
COMMENT_LINE $0CAD hopefully we have NO
COMMENT_LINE $0CAD interrupt miss here!
COMMENT $0CAD and compare to next
FORCE_SYMBOL $0CAD digit_next_digit_cycle
COMMENT_LINE $0CB0 time we should update
COMMENT $0CB0 not yet? than test again
COMMENT $0CB2 note:
FORCE_SYMBOL $0CB2 T2_TIMER_PEROID_REAL
COMMENT_LINE $0CB4 if this thing is called early enough
COMMENT_LINE $0CB4 we could calculate this above
COMMENT_LINE $0CB4 and save some cycles here!
COMMENT_LINE $0CB4 on the other hand, IF we are called early
COMMENT_LINE $0CB4 enough... we don't need to save cycles :-)
COMMENT $0CB4 and store it
FORCE_SYMBOL $0CB4 digit_next_digit_cycle
COMMENT_LINE $0CB7 sample-byte is finnished
COMMENT $0CB7 load the next sample_byte to A
COMMENT_LINE $0CB9 and store it to the 6522 -> PSG
COMMENT $0CB9 store in reg A in 6522 (DAC)
FORCE_SYMBOL $0CB9 VIA_port_a
COMMENT_LINE $0CBB following must come after the above, or we
COMMENT_LINE $0CBB put noise to the psg,
COMMENT_LINE $0CBB likewise, before storing anything else to
COMMENT_LINE $0CBB port A, we will disable the connection to PSG
COMMENT $0CBB this sets the MUX of 6522 to PSG
COMMENT $0CBB load the calculated VIA B
FORCE_SYMBOL $0CBB via_b_start
COMMENT $0CBE write back to reg B in 6522
FORCE_SYMBOL $0CBE VIA_port_b
COMMENT $0CC0 Clear shift regigster, why ???
FORCE_SYMBOL $0CC0 VIA_shift_reg
COMMENT_LINE $0CC2 without it, the display 'wobbles' a bit???
COMMENT $0CC2 and disable the mux, so no junk will
FORCE_SYMBOL $0CC2 VIA_port_b
COMMENT_LINE $0CC4 enter our PSG-DAC...
COMMENT_LINE $0CC5 ***************************************************************************
COMMENT_LINE $0CC5 position in D
COMMENT $0CC5 save the position
COMMENT $0CC7 play one sample_byte
COMMENT $0CC7 wait till the last played
COMMENT $0CC7 get timer
FORCE_SYMBOL $0CC7 VIA_t2_hi
COMMENT_LINE $0CC9 note:
COMMENT_LINE $0CC9 by reading the timer we
COMMENT_LINE $0CC9 can MISS an interrupt state
COMMENT_LINE $0CC9 since reading clears the
COMMENT_LINE $0CC9 interrupt!
COMMENT_LINE $0CC9 during recalibration this
COMMENT_LINE $0CC9 is considered (see below)
COMMENT_LINE $0CC9 hopefully we have NO
COMMENT_LINE $0CC9 interrupt miss here!
COMMENT $0CC9 and compare to next
FORCE_SYMBOL $0CC9 digit_next_digit_cycle
COMMENT_LINE $0CCC time we should update
COMMENT $0CCC not yet? than test again
COMMENT $0CCE note:
FORCE_SYMBOL $0CCE T2_TIMER_PEROID_REAL
COMMENT_LINE $0CD0 if this thing is called early enough
COMMENT_LINE $0CD0 we could calculate this above
COMMENT_LINE $0CD0 and save some cycles here!
COMMENT_LINE $0CD0 on the other hand, IF we are called early
COMMENT_LINE $0CD0 enough... we don't need to save cycles :-)
COMMENT $0CD0 and store it
FORCE_SYMBOL $0CD0 digit_next_digit_cycle
COMMENT_LINE $0CD3 sample-byte is finnished
COMMENT $0CD3 load the next sample_byte to A
COMMENT_LINE $0CD5 and store it to the 6522 -> PSG
COMMENT $0CD5 store in reg A in 6522 (DAC)
FORCE_SYMBOL $0CD5 VIA_port_a
COMMENT_LINE $0CD7 following must come after the above, or we
COMMENT_LINE $0CD7 put noise to the psg,
COMMENT_LINE $0CD7 likewise, before storing anything else to
COMMENT_LINE $0CD7 port A, we will disable the connection to PSG
COMMENT $0CD7 this sets the MUX of 6522 to PSG
COMMENT $0CD7 load the calculated VIA B
FORCE_SYMBOL $0CD7 via_b_start
COMMENT $0CDA write back to reg B in 6522
FORCE_SYMBOL $0CDA VIA_port_b
COMMENT $0CDC Clear shift regigster, why ???
FORCE_SYMBOL $0CDC VIA_shift_reg
COMMENT_LINE $0CDE without it, the display 'wobbles' a bit???
COMMENT $0CDE and disable the mux, so no junk will
FORCE_SYMBOL $0CDE VIA_port_b
COMMENT_LINE $0CE0 enter our PSG-DAC...
COMMENT $0CE0 restore position
COMMENT $0CE2 Store Y in D/A register
FORCE_SYMBOL $0CE2 VIA_port_a
COMMENT $0CE4 Blank low, zero high?
FORCE_NO_SYMBOL $0CE4
FORCE_SYMBOL $0CE6 VIA_cntl
COMMENT $0CE9 Enable mux
FORCE_SYMBOL $0CE9 VIA_port_b
COMMENT $0CEB Clear shift regigster
FORCE_SYMBOL $0CEB VIA_shift_reg
COMMENT $0CED Disable mux
FORCE_SYMBOL $0CED VIA_port_b
COMMENT $0CEF Store X in D/A register
FORCE_SYMBOL $0CEF VIA_port_a
COMMENT $0CF1 enable timer
FORCE_SYMBOL $0CF1 VIA_t1_cnt_hi
COMMENT $0CF3 t1 flag
FORCE_NO_SYMBOL $0CF3
FORCE_SYMBOL $0CF5 VIA_int_flags
COMMENT_LINE $0CFA ***************************************************************************
COMMENT_LINE $0CFA vector list in X
COMMENT_LINE $0CFA output first line without testing for end
COMMENT $0CFA load # of lines in this list
FORCE_NO_SYMBOL $0CFD
COMMENT $0D00 Load Y, X to D
COMMENT $0D02 put Y to DAC
FORCE_SYMBOL $0D02 VIA_port_a
COMMENT $0D04 MUX Y
FORCE_SYMBOL $0D04 VIA_port_b
COMMENT $0D06 un MUX (X allways set)
FORCE_SYMBOL $0D06 VIA_port_b
COMMENT $0D08 put X to DAC
FORCE_SYMBOL $0D08 VIA_port_a
FORCE_NO_SYMBOL $0D0A
COMMENT $0D0D set pattern
FORCE_SYMBOL $0D0D VIA_shift_reg
COMMENT $0D0F start timer
FORCE_SYMBOL $0D0F VIA_t1_cnt_hi
COMMENT_LINE $0D11 do some work in timer waiting
FORCE_NO_SYMBOL $0D11
COMMENT $0D14 if 0 - branch
COMMENT_LINE $0D16 now digit stuff
COMMENT_LINE $0D16 testing for timer...
COMMENT $0D16 get timer
FORCE_SYMBOL $0D16 VIA_t2_hi
COMMENT $0D18 and compare to next
FORCE_SYMBOL $0D18 digit_next_digit_cycle
COMMENT $0D1D load zero and timer interrupt bit
FORCE_NO_SYMBOL $0D1D
COMMENT $0D20 loop till timer interrupt bit set
FORCE_SYMBOL $0D20 VIA_int_flags
COMMENT $0D24 pattern to OFF
FORCE_SYMBOL $0D24 VIA_shift_reg
COMMENT $0D26 and go on with next vector
COMMENT $0D28 note:
FORCE_SYMBOL $0D28 T2_TIMER_PEROID_REAL
COMMENT $0D2A and store it
FORCE_SYMBOL $0D2A digit_next_digit_cycle
COMMENT $0D2D load zero and timer interrupt bit
FORCE_NO_SYMBOL $0D2D
COMMENT $0D30 loop till timer interrupt bit set
FORCE_SYMBOL $0D30 VIA_int_flags
COMMENT $0D34 pattern to OFF
FORCE_SYMBOL $0D34 VIA_shift_reg
COMMENT_LINE $0D36 now play next sample
COMMENT $0D36 load the next sample_byte to A
COMMENT $0D38 store in reg A in 6522 (DAC)
FORCE_SYMBOL $0D38 VIA_port_a
COMMENT $0D3A this sets the MUX of 6522 to PSG
COMMENT $0D3A load the calculated VIA B
FORCE_SYMBOL $0D3A via_b_start
COMMENT $0D3D write back to reg B in 6522
FORCE_SYMBOL $0D3D VIA_port_b
COMMENT $0D3F Clear shift regigster, why ???
FORCE_SYMBOL $0D3F VIA_shift_reg
COMMENT $0D41 and disable the mux, so no junk will
FORCE_SYMBOL $0D41 VIA_port_b
COMMENT $0D43 and go on with next vector
COMMENT $0D45 load zero and timer interrupt bit
FORCE_NO_SYMBOL $0D45
COMMENT $0D48 loop till timer interrupt bit set
FORCE_SYMBOL $0D48 VIA_int_flags
COMMENT $0D4C pattern to OFF
FORCE_SYMBOL $0D4C VIA_shift_reg
COMMENT_LINE $0D4F ***************************************************************************
COMMENT_LINE $0D4F intensity in A
COMMENT $0D4F Store intensity in D/A
FORCE_SYMBOL $0D4F VIA_port_a
COMMENT $0D51 mux disabled channel 2
FORCE_NO_SYMBOL $0D51
FORCE_SYMBOL $0D54 VIA_port_b
COMMENT $0D56 mux enabled channel 2
FORCE_SYMBOL $0D56 VIA_port_b
FORCE_NO_SYMBOL $0D58
COMMENT $0D5A turn off mux
FORCE_SYMBOL $0D5A VIA_port_b
COMMENT_LINE $0D5D ***************************************************************************
COMMENT_LINE $0D5D output first line without testing for end
COMMENT $0D5D Load Y, X to D
FORCE_NO_SYMBOL $0D5D
COMMENT $0D5F put Y to DAC
FORCE_SYMBOL $0D5F VIA_port_a
COMMENT $0D61 MUX Y
FORCE_SYMBOL $0D61 VIA_port_b
COMMENT $0D63 get pattern
FORCE_NO_SYMBOL $0D63
COMMENT $0D65 un MUX (X allways set)
FORCE_SYMBOL $0D65 VIA_port_b
COMMENT $0D67 put X to DAC
FORCE_SYMBOL $0D67 VIA_port_a
COMMENT $0D69 set pattern
FORCE_SYMBOL $0D69 VIA_shift_reg
COMMENT $0D6B start timer
FORCE_SYMBOL $0D6B VIA_t1_cnt_hi
COMMENT_LINE $0D6D do some work in timer waiting
COMMENT $0D6D increase X by 3
FORCE_NO_SYMBOL $0D6D
COMMENT $0D6F load next pattern
FORCE_NO_SYMBOL $0D6F
COMMENT $0D71 if one(!) - branch
COMMENT_LINE $0D73 now digit stuff
COMMENT_LINE $0D73 testing for timer...
COMMENT $0D73 get timer
FORCE_SYMBOL $0D73 VIA_t2_hi
COMMENT $0D75 and compare to next
FORCE_SYMBOL $0D75 digit_next_digit_cycle
COMMENT $0D7A load zero and timer interrupt bit
FORCE_NO_SYMBOL $0D7A
COMMENT $0D7D loop till timer interrupt bit set
FORCE_SYMBOL $0D7D VIA_int_flags
COMMENT $0D81 pattern to OFF
FORCE_SYMBOL $0D81 VIA_shift_reg
COMMENT $0D83 and go on with next vector
COMMENT $0D85 note:
FORCE_SYMBOL $0D85 T2_TIMER_PEROID_REAL
COMMENT $0D87 and store it
FORCE_SYMBOL $0D87 digit_next_digit_cycle
COMMENT $0D8A load zero and timer interrupt bit
FORCE_NO_SYMBOL $0D8A
COMMENT $0D8D loop till timer interrupt bit set
FORCE_SYMBOL $0D8D VIA_int_flags
COMMENT $0D91 pattern to OFF
FORCE_SYMBOL $0D91 VIA_shift_reg
COMMENT_LINE $0D93 now play next sample
COMMENT $0D93 load the next sample_byte to A
COMMENT $0D95 store in reg A in 6522 (DAC)
FORCE_SYMBOL $0D95 VIA_port_a
COMMENT $0D97 this sets the MUX of 6522 to PSG
COMMENT $0D97 load the calculated VIA B
FORCE_SYMBOL $0D97 via_b_start
COMMENT $0D9A write back to reg B in 6522
FORCE_SYMBOL $0D9A VIA_port_b
COMMENT $0D9C Clear shift regigster, why ???
FORCE_SYMBOL $0D9C VIA_shift_reg
COMMENT $0D9E and disable the mux, so no junk will
FORCE_SYMBOL $0D9E VIA_port_b
COMMENT $0DA0 and go on with next vector
COMMENT $0DA2 load zero and timer interrupt bit
FORCE_NO_SYMBOL $0DA2
COMMENT $0DA5 loop till timer interrupt bit set
FORCE_SYMBOL $0DA5 VIA_int_flags
COMMENT $0DA9 pattern to OFF
FORCE_SYMBOL $0DA9 VIA_shift_reg
COMMENT_LINE $0DAC ***************************************************************************
COMMENT $0DAC is there a digital sample to be played?
FORCE_SYMBOL $0DAC digit_is_playing
COMMENT $0DAF no, than jump out of here
COMMENT $0DB1 otherwise we wait till the last played
COMMENT $0DB1 get timer
FORCE_SYMBOL $0DB1 VIA_t2_hi
COMMENT_LINE $0DB3 note:
COMMENT_LINE $0DB3 by reading the timer we
COMMENT_LINE $0DB3 can MISS an interrupt state
COMMENT_LINE $0DB3 since reading clears the
COMMENT_LINE $0DB3 interrupt!
COMMENT_LINE $0DB3 during recalibration this
COMMENT_LINE $0DB3 is considered (see below)
COMMENT_LINE $0DB3 hopefully we have NO
COMMENT_LINE $0DB3 interrupt miss here!
COMMENT $0DB3 and compare to next
FORCE_SYMBOL $0DB3 digit_next_digit_cycle
COMMENT_LINE $0DB6 time we should update
COMMENT $0DB6 not yet? than test again
COMMENT $0DB8 note:
FORCE_SYMBOL $0DB8 T2_TIMER_PEROID_REAL
COMMENT_LINE $0DBA if this thing is called early enough
COMMENT_LINE $0DBA we could calculate this above
COMMENT_LINE $0DBA and save some cycles here!
COMMENT_LINE $0DBA on the other hand, IF we are called early
COMMENT_LINE $0DBA enough... we don't need to save cycles :-)
COMMENT $0DBA and store it
FORCE_SYMBOL $0DBA digit_next_digit_cycle
COMMENT_LINE $0DBD sample-byte is finnished
COMMENT $0DBD load the next sample_byte to A
FORCE_SYMBOL $0DBF digit_start_pos
COMMENT $0DC3 with this sample, otherwise we continue further below
FORCE_SYMBOL $0DC5 digit_structure_pos_current
FORCE_NO_SYMBOL $0DC9
FORCE_SYMBOL $0DCD digit_structure_pos
COMMENT $0DD1 is this sample a looping one?
COMMENT $0DD3 store it to is_playing
FORCE_SYMBOL $0DD3 digit_is_playing
COMMENT $0DD6 if none looping... we are done
COMMENT_LINE $0DD8 JSR     switch_to_ym
COMMENT $0DD8 if none looping... we are done
COMMENT $0DDC store new start position
FORCE_SYMBOL $0DDC digit_start_pos
FORCE_SYMBOL $0DE1 digit_structure_pos_current
COMMENT $0DE5 calculate end position
FORCE_SYMBOL $0DE5 digit_start_pos
COMMENT $0DE8 and store it
FORCE_SYMBOL $0DE8 digit_end_pos
COMMENT_LINE $0DEB ok, for restart, we only change current position
COMMENT $0DEB load the start position
COMMENT_LINE $0DED this is the end_position of the sample,
COMMENT_LINE $0DED since we go backwards
COMMENT $0DED next byte
COMMENT_LINE $0DEF is played next round...
COMMENT_LINE $0DEF and store it to the 6522 -> PSG
COMMENT $0DEF store in reg A in 6522 (DAC)
FORCE_SYMBOL $0DEF VIA_port_a
COMMENT_LINE $0DF1 following must come after the above, or we
COMMENT_LINE $0DF1 put noise to the psg,
COMMENT_LINE $0DF1 likewise, before storing anything else to
COMMENT_LINE $0DF1 port A, we will disable the connection to PSG
COMMENT $0DF1 this sets the MUX of 6522 to PSG
COMMENT $0DF1 load the calculated VIA B
FORCE_SYMBOL $0DF1 via_b_start
COMMENT $0DF4 write back to reg B in 6522
FORCE_SYMBOL $0DF4 VIA_port_b
COMMENT $0DF6 Clear shift regigster, why ???
FORCE_SYMBOL $0DF6 VIA_shift_reg
COMMENT_LINE $0DF8 without it, the display 'wobbles' a bit???
COMMENT $0DF8 and disable the mux, so no junk will
FORCE_SYMBOL $0DF8 VIA_port_b
COMMENT_LINE $0DFA enter our PSG-DAC...
COMMENT_LINE $0DFB ***************************************************************************
COMMENT_LINE $0DFB ***************************************************************************
COMMENT $0DFB Point to button flags
FORCE_SYMBOL $0DFB Vec_Button_1_1
COMMENT $0DFE Save previous state
COMMENT $0E02 Sound chip register 0E to port A
FORCE_NO_SYMBOL $0E02
FORCE_SYMBOL $0E04 VIA_port_a
COMMENT $0E06 sound BDIR on, BC1 on, mux off
FORCE_NO_SYMBOL $0E06
FORCE_SYMBOL $0E09 VIA_port_b
COMMENT $0E0B pause
COMMENT $0E0C sound BDIR off, BC1 off, mux off
FORCE_SYMBOL $0E0C VIA_port_b
COMMENT $0E0E DDR A to input
FORCE_SYMBOL $0E0E VIA_DDR_a
COMMENT $0E10 sound BDIR off, BC1 on, mux off
FORCE_NO_SYMBOL $0E10
FORCE_SYMBOL $0E13 VIA_port_b
COMMENT $0E15 pause
COMMENT $0E16 Read buttons
FORCE_SYMBOL $0E16 VIA_port_a
COMMENT $0E18 Convert to active high
COMMENT $0E19 Save buttons
COMMENT $0E1B sound BDIR off, BC1 off, mux off
FORCE_SYMBOL $0E1B VIA_port_b
FORCE_NO_SYMBOL $0E1D
COMMENT $0E1F DDR A to output
FORCE_SYMBOL $0E1F VIA_DDR_a
COMMENT $0E21 Check for transitions
COMMENT $0E25 Store transition result
COMMENT_LINE $0E28 ***************************************************************************
COMMENT $0E28 following code uses d0
FORCE_SYMBOL $0E28 helper_first
FORCE_SYMBOL $0E2B move_offset_y
FORCE_SYMBOL $0E2E STEPS
FORCE_SYMBOL $0E31 LAB_REDUCT_1
COMMENT $0E34 and divide by DOUBLE STEP
COMMENT $0E34 this divides d by 64
COMMENT $0E35 result in A
COMMENT $0E38 this is a divider 3
FORCE_NO_SYMBOL $0E38
FORCE_NO_SYMBOL $0E3C
FORCE_SYMBOL $0E3E NOT_CARRY
COMMENT $0E40 roll in carry
FORCE_NO_SYMBOL $0E41
FORCE_NO_SYMBOL $0E45
FORCE_SYMBOL $0E47 NOT_CARRY
COMMENT $0E49 roll in carry
FORCE_NO_SYMBOL $0E4A
FORCE_NO_SYMBOL $0E4E
FORCE_SYMBOL $0E50 NOT_CARRY
COMMENT $0E52 roll in carry
FORCE_NO_SYMBOL $0E53
FORCE_NO_SYMBOL $0E57
FORCE_SYMBOL $0E59 NOT_CARRY
COMMENT $0E5B roll in carry
FORCE_NO_SYMBOL $0E5C
FORCE_NO_SYMBOL $0E60
FORCE_SYMBOL $0E62 NOT_CARRY
COMMENT $0E64 roll in carry
FORCE_NO_SYMBOL $0E65
FORCE_NO_SYMBOL $0E69
FORCE_SYMBOL $0E6B NOT_CARRY
COMMENT $0E6D roll in carry
FORCE_NO_SYMBOL $0E6E
FORCE_NO_SYMBOL $0E72
FORCE_SYMBOL $0E74 NOT_CARRY
COMMENT $0E76 roll in carry
FORCE_SYMBOL $0E79 CARRY
COMMENT $0E7B roll in carry
FORCE_SYMBOL $0E7E CARRY
COMMENT $0E80 roll in carry
FORCE_SYMBOL $0E83 CARRY
COMMENT $0E85 roll in carry
FORCE_SYMBOL $0E88 CARRY
COMMENT $0E8A roll in carry
FORCE_SYMBOL $0E8D CARRY
COMMENT $0E8F roll in carry
FORCE_SYMBOL $0E92 CARRY
COMMENT $0E94 roll in carry
FORCE_SYMBOL $0E97 CARRY
COMMENT $0E99 roll in carry
FORCE_SYMBOL $0E9B LAB_SCALE
FORCE_SYMBOL $0E9D scale_step
FORCE_NO_SYMBOL $0EA0
FORCE_SYMBOL $0EA4 helper_first
FORCE_SYMBOL $0EA7 move_offset_y
COMMENT_LINE $0EAA Depending on size of LAB
COMMENT_LINE $0EAA if steps are smaller use one shift less!
FORCE_SYMBOL $0EAF maze_intensity
FORCE_SYMBOL $0EB2 maze_draw_y
FORCE_SYMBOL $0EB5 view_pos_y
COMMENT $0EBB if u not used, we can put this
FORCE_SYMBOL $0EBB maze_ram
COMMENT_LINE $0EBE out of the loop and do
COMMENT_LINE $0EBE and LEAU 4,U!
COMMENT $0EBE x = 1 in maze_ram
FORCE_SYMBOL $0EC1 scale_step
COMMENT $0EC4 move to time 1 lo, this means scaling
FORCE_SYMBOL $0EC4 VIA_t1_cnt_lo
FORCE_SYMBOL $0EC6 maze_intensity
COMMENT $0EC9 Store intensity in D/A
FORCE_SYMBOL $0EC9 VIA_port_a
COMMENT $0ECB mux disabled channel 2
FORCE_NO_SYMBOL $0ECB
FORCE_SYMBOL $0ECE VIA_port_b
COMMENT $0ED0 mux enabled channel 2
FORCE_SYMBOL $0ED0 VIA_port_b
FORCE_NO_SYMBOL $0ED2
COMMENT $0ED4 turn off mux
FORCE_SYMBOL $0ED4 VIA_port_b
FORCE_SYMBOL $0ED6 vpos_1
COMMENT $0ED9 following code uses d0
COMMENT $0ED9 Store Y in D/A register
FORCE_SYMBOL $0ED9 VIA_port_a
COMMENT $0EDB Blank low, zero high?
FORCE_NO_SYMBOL $0EDB
FORCE_SYMBOL $0EDD VIA_cntl
COMMENT $0EE0 Enable mux
FORCE_SYMBOL $0EE0 VIA_port_b
COMMENT_LINE $0EE2 STA     VIA_shift_reg  ;Clear shift regigster
COMMENT $0EE2 Disable mux
FORCE_SYMBOL $0EE2 VIA_port_b
COMMENT $0EE4 Store X in D/A register
FORCE_SYMBOL $0EE4 VIA_port_a
COMMENT $0EE6 enable timer
FORCE_SYMBOL $0EE6 VIA_t1_cnt_hi
COMMENT_LINE $0EE8 allways draw at least ONE frame
FORCE_NO_SYMBOL $0EE8
COMMENT_LINE $0EEE here we have a good south square
COMMENT $0EF2 two spaces in a row
FORCE_NO_SYMBOL $0EF6
COMMENT $0EFA two spaces in a row
FORCE_SYMBOL $0EFE square_half_vlist
FORCE_SYMBOL $0F03 square_quarter_left_vlist
FORCE_NO_SYMBOL $0F06
COMMENT $0F0A two spaces in a row
FORCE_SYMBOL $0F10 square_quarter_right_vlist
FORCE_SYMBOL $0F15 square_full_vlist
FORCE_NO_SYMBOL $0F18
FORCE_SYMBOL $0F1A VIA_int_flags
FORCE_SYMBOL $0F1E Draw_VLp
COMMENT_LINE $0F21 check side walls
FORCE_NO_SYMBOL $0F27
FORCE_SYMBOL $0F2D no_left_wall_vlist
FORCE_SYMBOL $0F30 Draw_VLp
FORCE_SYMBOL $0F33 no_left_return
FORCE_SYMBOL $0F36 Draw_VLp
FORCE_SYMBOL $0F3B helper_first
FORCE_SYMBOL $0F40 left_wall_vlist_first
FORCE_SYMBOL $0F43 Draw_VLp
FORCE_SYMBOL $0F46 left_return_first
FORCE_SYMBOL $0F49 Draw_VLp
FORCE_SYMBOL $0F4E left_wall_vlist
FORCE_SYMBOL $0F51 Draw_VLp
FORCE_SYMBOL $0F54 left_return
FORCE_SYMBOL $0F57 Draw_VLp
FORCE_SYMBOL $0F66 no_right_wall_vlist
FORCE_SYMBOL $0F69 Draw_VLp
FORCE_SYMBOL $0F6E helper_first
FORCE_SYMBOL $0F73 right_wall_vlist_first
FORCE_SYMBOL $0F76 Draw_VLp
FORCE_SYMBOL $0F7B right_wall_vlist
FORCE_SYMBOL $0F7E Draw_VLp
FORCE_SYMBOL $0F81 helper_first
FORCE_NO_SYMBOL $0F84
COMMENT_LINE $0F8C bra no_monster_in_front
COMMENT_LINE $0F8C do monster stuff
COMMENT_LINE $0F8C if we do all monster stuff here we don't have to worry about
COMMENT_LINE $0F8C positioning, since we are last :-)
COMMENT_LINE $0F8C calculate scale for image
COMMENT_LINE $0F8C that is our offset + figure offset + mazeparts in between
COMMENT $0F8C view position of current maze square
FORCE_SYMBOL $0F8C view_pos_y
COMMENT $0F8F current position in view
FORCE_SYMBOL $0F8F view_pos_y
COMMENT $0F92 y pos equal?
FORCE_SYMBOL $0F92 V_MONSTER_Y
COMMENT $0F95 no -> branch
COMMENT_LINE $0F99 we have a monster in our visibility!
FORCE_NO_SYMBOL $0F99
COMMENT $0F9B /BLANK low and /ZERO low
FORCE_SYMBOL $0F9B VIA_cntl
COMMENT_LINE $0F9D calculate size
COMMENT_LINE $0F9D since monsters can move of there own,
COMMENT_LINE $0F9D we must :-( calculate their size!
COMMENT $0F9D helper for # of divides for scale
FORCE_SYMBOL $0F9D tmp0
COMMENT $0FA0 load our own offset
FORCE_SYMBOL $0FA0 move_offset_y
COMMENT $0FA3 we use bigger numbers now
COMMENT $0FA4 offset it with monster offset
FORCE_SYMBOL $0FA4 V_MONSTER_OFFSET_Y
COMMENT_LINE $0FA7 D is -DOUBLE_STEP - +DOUBLE_STEP
COMMENT_LINE $0FA7 should be -STEP - +STEP
COMMENT_LINE $0FA7 that's what we do now
COMMENT $0FA7 is it negative?
COMMENT $0FA8 well, than go there
COMMENT $0FAA is it to big?
FORCE_SYMBOL $0FAA STEPS
COMMENT_LINE $0FAE to big means the combined offsets
COMMENT_LINE $0FAE are smaller than one maze square
COMMENT_LINE $0FAE so we have to use one divider
COMMENT_LINE $0FAE less
COMMENT $0FAE nope, than all ok
COMMENT $0FB0 to big, correct offset
FORCE_SYMBOL $0FB0 DOUBLE_STEP
COMMENT $0FB3 and one LSR less
FORCE_SYMBOL $0FB3 tmp0
COMMENT $0FB6 done here
COMMENT $0FB8 y pos of monster, allways greater than man!
FORCE_SYMBOL $0FB8 V_MONSTER_Y
COMMENT $0FBB our own position
FORCE_SYMBOL $0FBB maze_draw_y
COMMENT $0FBE any offsets from above added
FORCE_SYMBOL $0FBE tmp0
FORCE_SYMBOL $0FC7 halving_done
COMMENT $0FCA is it to small?
COMMENT_LINE $0FCE to small means the combined offsets
COMMENT_LINE $0FCE are bigger than one maze square
COMMENT_LINE $0FCE so we have to use one divider
COMMENT_LINE $0FCE more
COMMENT $0FCE nope, than all ok
COMMENT $0FD0 to small, correct offset
FORCE_SYMBOL $0FD0 DOUBLE_STEP
COMMENT $0FD3 and one LSR more
FORCE_SYMBOL $0FD3 tmp0
COMMENT_LINE $0FD6 B is be -STEP - +STEP
COMMENT_LINE $0FD6 should be 0 - +DOUBLE_STEP
FORCE_SYMBOL $0FD6 STEPS
COMMENT_LINE $0FD9 in D now 0 - DOUBLE_STEP
COMMENT $0FD9 multiply with laby magic
FORCE_SYMBOL $0FD9 LAB_REDUCT_1
COMMENT $0FDC and divide by DOUBLE STEP
COMMENT $0FDC this divides d by 64
COMMENT $0FDD result in A
COMMENT $0FE0 this is a divider 3
FORCE_NO_SYMBOL $0FE0
FORCE_NO_SYMBOL $0FE4
FORCE_SYMBOL $0FE6 NOT_CARRY
COMMENT $0FE8 roll in carry
FORCE_NO_SYMBOL $0FE9
FORCE_NO_SYMBOL $0FED
FORCE_SYMBOL $0FEF NOT_CARRY
COMMENT $0FF1 roll in carry
FORCE_NO_SYMBOL $0FF2
FORCE_NO_SYMBOL $0FF6
FORCE_SYMBOL $0FF8 NOT_CARRY
COMMENT $0FFA roll in carry
FORCE_NO_SYMBOL $0FFB
FORCE_NO_SYMBOL $0FFF
FORCE_SYMBOL $1001 NOT_CARRY
COMMENT $1003 roll in carry
FORCE_NO_SYMBOL $1004
FORCE_NO_SYMBOL $1008
FORCE_SYMBOL $100A NOT_CARRY
COMMENT $100C roll in carry
FORCE_NO_SYMBOL $100D
FORCE_NO_SYMBOL $1011
FORCE_SYMBOL $1013 NOT_CARRY
COMMENT $1015 roll in carry
FORCE_NO_SYMBOL $1016
FORCE_NO_SYMBOL $101A
FORCE_SYMBOL $101C NOT_CARRY
COMMENT $101E roll in carry
FORCE_SYMBOL $1021 CARRY
COMMENT $1023 roll in carry
FORCE_SYMBOL $1026 CARRY
COMMENT $1028 roll in carry
FORCE_SYMBOL $102B CARRY
COMMENT $102D roll in carry
FORCE_SYMBOL $1030 CARRY
COMMENT $1032 roll in carry
FORCE_SYMBOL $1035 CARRY
COMMENT $1037 roll in carry
FORCE_SYMBOL $103A CARRY
COMMENT $103C roll in carry
FORCE_SYMBOL $103F CARRY
COMMENT $1041 roll in carry
COMMENT $1042 do more magic
COMMENT $1043 and voila our first scale is there!
FORCE_SYMBOL $1043 LAB_SCALE
COMMENT_LINE $1045 now lets see how many divides we need
COMMENT $1045 y pos of monster, allways greater than man!
FORCE_SYMBOL $1045 V_MONSTER_Y
COMMENT $1048 our own position
FORCE_SYMBOL $1048 maze_draw_y
COMMENT $104B any offsets from above added
FORCE_SYMBOL $104B tmp0
COMMENT $104F perhaps nothing to do?
COMMENT $1051 halve it
COMMENT $1052 loop count -1
COMMENT $1053 done?
FORCE_SYMBOL $1055 scale_shadow
COMMENT_LINE $1058 phuu
COMMENT_LINE $1058 done the sizing of our creature
COMMENT_LINE $1058 shitty stuff
COMMENT $1058 x  equal?
FORCE_SYMBOL $1058 V_MONSTER_X
COMMENT $1062 x pointer to monster level list
FORCE_SYMBOL $1062 V_MONSTER_POINTER
COMMENT $1065 load pointer to current graphic
FORCE_SYMBOL $1065 C_MONSTER_GRAPHIC
COMMENT_LINE $1069 bei gesamtbreite des monsters = 2 * SQUARE SIZE!,
COMMENT_LINE $1069 dann koennte die X pos als
COMMENT_LINE $1069 clipping gebarucht werden!
COMMENT_LINE $1069 Am einfachsten, einen 0 offset von links einfï¿½hren!
COMMENT $1069 these are steps, gotto convert to 2 * square
FORCE_SYMBOL $1069 V_MONSTER_OFFSET_X
COMMENT_LINE $106C step == square
FORCE_SYMBOL $106E clip_vlp_p2_left
FORCE_SYMBOL $1073 V_MONSTER_MOVEMENT_AXIS
FORCE_SYMBOL $1078 scale_shadow
COMMENT $107B move to time 1 lo, this means scaling
FORCE_SYMBOL $107B VIA_t1_cnt_lo
FORCE_NO_SYMBOL $107D
FORCE_SYMBOL $1081 my_move_to_d
FORCE_SYMBOL $1084 scale_shadow
COMMENT $1087 halve it
COMMENT $1088 move to time 1 lo, this means scaling
FORCE_SYMBOL $1088 VIA_t1_cnt_lo
FORCE_NO_SYMBOL $108C
FORCE_SYMBOL $1090 my_move_to_d
FORCE_SYMBOL $1093 scale_shadow
COMMENT $1096 halve it
COMMENT $1097 move to time 1 lo, this means scaling
FORCE_SYMBOL $1097 VIA_t1_cnt_lo
FORCE_NO_SYMBOL $1099
FORCE_SYMBOL $109B V_MONSTER_OFFSET_X
FORCE_SYMBOL $109E my_move_to_d
COMMENT_LINE $10A1 geklippte sprites von der seite 'springen' in den anfangskoordinaten!
FORCE_SYMBOL $10A1 Draw_VLp
COMMENT $10A6 x pointer to monster level list
FORCE_SYMBOL $10A6 V_MONSTER_POINTER
COMMENT $10A9 load pointer to current graphic
FORCE_SYMBOL $10A9 C_MONSTER_GRAPHIC
COMMENT_LINE $10AD bei gesamtbreite des monsters = 2 * SQUARE SIZE!,
COMMENT_LINE $10AD dann koennte die X pos als
COMMENT_LINE $10AD clipping gebarucht werden!
COMMENT_LINE $10AD Am einfachsten, einen 0 offset von links einfï¿½hren!
COMMENT $10AD these are steps, gotto convert to 2* square
FORCE_SYMBOL $10AD V_MONSTER_OFFSET_X
COMMENT_LINE $10B0 step == square
FORCE_SYMBOL $10B2 clip_vlp_p2_right
FORCE_SYMBOL $10B7 V_MONSTER_MOVEMENT_AXIS
FORCE_SYMBOL $10BC scale_shadow
COMMENT $10BF move to time 1 lo, this means scaling
FORCE_SYMBOL $10BF VIA_t1_cnt_lo
FORCE_NO_SYMBOL $10C1
FORCE_SYMBOL $10C3 SQUARE_SIZE
FORCE_SYMBOL $10C5 my_move_to_d
FORCE_SYMBOL $10C8 scale_shadow
COMMENT $10CB halve it
COMMENT $10CC move to time 1 lo, this means scaling
FORCE_SYMBOL $10CC VIA_t1_cnt_lo
FORCE_NO_SYMBOL $10D0
FORCE_SYMBOL $10D2 SQUARE_SIZE
FORCE_SYMBOL $10D4 my_move_to_d
FORCE_SYMBOL $10D7 scale_shadow
COMMENT $10DA halve it
COMMENT $10DB move to time 1 lo, this means scaling
FORCE_SYMBOL $10DB VIA_t1_cnt_lo
FORCE_NO_SYMBOL $10DD
FORCE_SYMBOL $10DF V_MONSTER_OFFSET_X
FORCE_SYMBOL $10E2 my_move_to_d
FORCE_SYMBOL $10E5 Draw_VLp
COMMENT $10EA x pointer to monster level list
FORCE_SYMBOL $10EA V_MONSTER_POINTER
COMMENT $10ED load pointer to current graphic
FORCE_SYMBOL $10ED C_MONSTER_GRAPHIC
COMMENT_LINE $10EF bei gesamtbreite des monsters = 2 * SQUARE SIZE!,
COMMENT_LINE $10EF dann koennte die X pos als
COMMENT_LINE $10EF clipping gebarucht werden!
COMMENT_LINE $10EF Am einfachsten, einen 0 offset von links einfï¿½hren!
COMMENT $10EF these are steps, gotto convert to 2* square
FORCE_SYMBOL $10EF V_MONSTER_OFFSET_X
FORCE_SYMBOL $10FD clip_vlp_p2_left
FORCE_SYMBOL $1102 scale_shadow
COMMENT $1105 halve it
COMMENT $1106 move to time 1 lo, this means scaling
FORCE_SYMBOL $1106 VIA_t1_cnt_lo
FORCE_NO_SYMBOL $1108
FORCE_SYMBOL $110A V_MONSTER_OFFSET_X
FORCE_SYMBOL $110D my_move_to_d
COMMENT_LINE $1110 now we can display it :-)
FORCE_SYMBOL $1110 Draw_VLp
FORCE_NO_SYMBOL $1113
COMMENT $1115 /BLANK low and /ZERO low
FORCE_SYMBOL $1115 VIA_cntl
FORCE_SYMBOL $1117 maze_intensity
FORCE_SYMBOL $111A LIGHT
FORCE_SYMBOL $111E maze_intensity
FORCE_SYMBOL $1121 scale_step
FORCE_NO_SYMBOL $1124
FORCE_SYMBOL $1126 next_maze
COMMENT_LINE $112A ***************************************************************************
COMMENT $112A following code uses d0
FORCE_SYMBOL $112A helper_first
COMMENT $112D wait till the last played
COMMENT $112D get timer
FORCE_SYMBOL $112D VIA_t2_hi
COMMENT_LINE $112F note:
COMMENT_LINE $112F by reading the timer we
COMMENT_LINE $112F can MISS an interrupt state
COMMENT_LINE $112F since reading clears the
COMMENT_LINE $112F interrupt!
COMMENT_LINE $112F during recalibration this
COMMENT_LINE $112F is considered (see below)
COMMENT_LINE $112F hopefully we have NO
COMMENT_LINE $112F interrupt miss here!
COMMENT $112F and compare to next
FORCE_SYMBOL $112F digit_next_digit_cycle
COMMENT_LINE $1132 time we should update
COMMENT $1132 not yet? than test again
COMMENT $1134 note:
FORCE_SYMBOL $1134 T2_TIMER_PEROID_REAL
COMMENT_LINE $1136 if this thing is called early enough
COMMENT_LINE $1136 we could calculate this above
COMMENT_LINE $1136 and save some cycles here!
COMMENT_LINE $1136 on the other hand, IF we are called early
COMMENT_LINE $1136 enough... we don't need to save cycles :-)
COMMENT $1136 and store it
FORCE_SYMBOL $1136 digit_next_digit_cycle
COMMENT_LINE $1139 sample-byte is finnished
COMMENT $1139 load the next sample_byte to A
COMMENT_LINE $113B and store it to the 6522 -> PSG
COMMENT $113B store in reg A in 6522 (DAC)
FORCE_SYMBOL $113B VIA_port_a
COMMENT_LINE $113D following must come after the above, or we
COMMENT_LINE $113D put noise to the psg,
COMMENT_LINE $113D likewise, before storing anything else to
COMMENT_LINE $113D port A, we will disable the connection to PSG
COMMENT $113D this sets the MUX of 6522 to PSG
COMMENT $113D load the calculated VIA B
FORCE_SYMBOL $113D via_b_start
COMMENT $1140 write back to reg B in 6522
FORCE_SYMBOL $1140 VIA_port_b
COMMENT $1142 Clear shift regigster, why ???
FORCE_SYMBOL $1142 VIA_shift_reg
COMMENT_LINE $1144 without it, the display 'wobbles' a bit???
COMMENT $1144 and disable the mux, so no junk will
FORCE_SYMBOL $1144 VIA_port_b
COMMENT_LINE $1146 enter our PSG-DAC...
FORCE_SYMBOL $1146 move_offset_y
FORCE_SYMBOL $1149 STEPS
FORCE_SYMBOL $114C LAB_REDUCT_1
COMMENT $114F and divide by DOUBLE STEP
COMMENT $114F this divides d by 64
COMMENT $1150 result in A
COMMENT $1153 this is a divider 3
FORCE_NO_SYMBOL $1153
FORCE_NO_SYMBOL $1157
FORCE_SYMBOL $1159 NOT_CARRY
COMMENT $115B roll in carry
FORCE_NO_SYMBOL $115C
FORCE_NO_SYMBOL $1160
FORCE_SYMBOL $1162 NOT_CARRY
COMMENT $1164 roll in carry
FORCE_NO_SYMBOL $1165
FORCE_NO_SYMBOL $1169
FORCE_SYMBOL $116B NOT_CARRY
COMMENT $116D roll in carry
FORCE_NO_SYMBOL $116E
FORCE_NO_SYMBOL $1172
FORCE_SYMBOL $1174 NOT_CARRY
COMMENT $1176 roll in carry
FORCE_NO_SYMBOL $1177
FORCE_NO_SYMBOL $117B
FORCE_SYMBOL $117D NOT_CARRY
COMMENT $117F roll in carry
FORCE_NO_SYMBOL $1180
FORCE_NO_SYMBOL $1184
FORCE_SYMBOL $1186 NOT_CARRY
COMMENT $1188 roll in carry
FORCE_NO_SYMBOL $1189
FORCE_NO_SYMBOL $118D
FORCE_SYMBOL $118F NOT_CARRY
COMMENT $1191 roll in carry
FORCE_SYMBOL $1194 CARRY
COMMENT $1196 roll in carry
FORCE_SYMBOL $1199 CARRY
COMMENT $119B roll in carry
FORCE_SYMBOL $119E CARRY
COMMENT $11A0 roll in carry
FORCE_SYMBOL $11A3 CARRY
COMMENT $11A5 roll in carry
FORCE_SYMBOL $11A8 CARRY
COMMENT $11AA roll in carry
FORCE_SYMBOL $11AD CARRY
COMMENT $11AF roll in carry
FORCE_SYMBOL $11B2 CARRY
COMMENT $11B4 roll in carry
FORCE_SYMBOL $11B6 LAB_SCALE
FORCE_SYMBOL $11B8 scale_step
FORCE_NO_SYMBOL $11BB
FORCE_SYMBOL $11BF helper_first
COMMENT $11C2 wait till the last played
COMMENT $11C2 get timer
FORCE_SYMBOL $11C2 VIA_t2_hi
COMMENT_LINE $11C4 note:
COMMENT_LINE $11C4 by reading the timer we
COMMENT_LINE $11C4 can MISS an interrupt state
COMMENT_LINE $11C4 since reading clears the
COMMENT_LINE $11C4 interrupt!
COMMENT_LINE $11C4 during recalibration this
COMMENT_LINE $11C4 is considered (see below)
COMMENT_LINE $11C4 hopefully we have NO
COMMENT_LINE $11C4 interrupt miss here!
COMMENT $11C4 and compare to next
FORCE_SYMBOL $11C4 digit_next_digit_cycle
COMMENT_LINE $11C7 time we should update
COMMENT $11C7 not yet? than test again
COMMENT $11C9 note:
FORCE_SYMBOL $11C9 T2_TIMER_PEROID_REAL
COMMENT_LINE $11CB if this thing is called early enough
COMMENT_LINE $11CB we could calculate this above
COMMENT_LINE $11CB and save some cycles here!
COMMENT_LINE $11CB on the other hand, IF we are called early
COMMENT_LINE $11CB enough... we don't need to save cycles :-)
COMMENT $11CB and store it
FORCE_SYMBOL $11CB digit_next_digit_cycle
COMMENT_LINE $11CE sample-byte is finnished
COMMENT $11CE load the next sample_byte to A
COMMENT_LINE $11D0 and store it to the 6522 -> PSG
COMMENT $11D0 store in reg A in 6522 (DAC)
FORCE_SYMBOL $11D0 VIA_port_a
COMMENT_LINE $11D2 following must come after the above, or we
COMMENT_LINE $11D2 put noise to the psg,
COMMENT_LINE $11D2 likewise, before storing anything else to
COMMENT_LINE $11D2 port A, we will disable the connection to PSG
COMMENT $11D2 this sets the MUX of 6522 to PSG
COMMENT $11D2 load the calculated VIA B
FORCE_SYMBOL $11D2 via_b_start
COMMENT $11D5 write back to reg B in 6522
FORCE_SYMBOL $11D5 VIA_port_b
COMMENT $11D7 Clear shift regigster, why ???
FORCE_SYMBOL $11D7 VIA_shift_reg
COMMENT_LINE $11D9 without it, the display 'wobbles' a bit???
COMMENT $11D9 and disable the mux, so no junk will
FORCE_SYMBOL $11D9 VIA_port_b
COMMENT_LINE $11DB enter our PSG-DAC...
FORCE_SYMBOL $11DB move_offset_y
COMMENT_LINE $11DE Depending on size of LAB
COMMENT_LINE $11DE if steps are smaller use one shift less!
FORCE_SYMBOL $11E3 maze_intensity
FORCE_SYMBOL $11E6 maze_draw_y
FORCE_SYMBOL $11E9 view_pos_y
COMMENT $11EF if u not used, we can put this
FORCE_SYMBOL $11EF maze_ram
COMMENT_LINE $11F2 out of the loop and do
COMMENT_LINE $11F2 and LEAU 4,U!
COMMENT $11F2 x = 1 in maze_ram
FORCE_SYMBOL $11F5 scale_step
COMMENT $11F8 move to time 1 lo, this means scaling
FORCE_SYMBOL $11F8 VIA_t1_cnt_lo
FORCE_SYMBOL $11FA maze_intensity
COMMENT $11FD Store intensity in D/A
FORCE_SYMBOL $11FD VIA_port_a
COMMENT $11FF mux disabled channel 2
FORCE_NO_SYMBOL $11FF
FORCE_SYMBOL $1202 VIA_port_b
COMMENT $1204 mux enabled channel 2
FORCE_SYMBOL $1204 VIA_port_b
FORCE_NO_SYMBOL $1206
COMMENT $1208 turn off mux
FORCE_SYMBOL $1208 VIA_port_b
FORCE_SYMBOL $120A vpos_1
COMMENT $120D following code uses d0
COMMENT $120D Store Y in D/A register
FORCE_SYMBOL $120D VIA_port_a
COMMENT $120F Blank low, zero high?
FORCE_NO_SYMBOL $120F
FORCE_SYMBOL $1211 VIA_cntl
COMMENT $1214 Enable mux
FORCE_SYMBOL $1214 VIA_port_b
COMMENT_LINE $1216 STA     VIA_shift_reg  ;Clear shift regigster
COMMENT $1216 Disable mux
FORCE_SYMBOL $1216 VIA_port_b
COMMENT $1218 Store X in D/A register
FORCE_SYMBOL $1218 VIA_port_a
COMMENT $121A enable timer
FORCE_SYMBOL $121A VIA_t1_cnt_hi
FORCE_NO_SYMBOL $121C
COMMENT_LINE $1222 here we have a good south square
COMMENT $1226 two spaces in a row
FORCE_NO_SYMBOL $122A
COMMENT $122E two spaces in a row
FORCE_SYMBOL $1232 square_half_vlist
FORCE_SYMBOL $1237 square_quarter_left_vlist
FORCE_NO_SYMBOL $123A
COMMENT $123E two spaces in a row
FORCE_SYMBOL $1244 square_quarter_right_vlist
FORCE_SYMBOL $1249 square_full_vlist
FORCE_NO_SYMBOL $124C
FORCE_SYMBOL $124E VIA_int_flags
FORCE_SYMBOL $1252 Draw_VLp_digit
COMMENT_LINE $1255 check side walls
FORCE_NO_SYMBOL $125B
FORCE_SYMBOL $1261 no_left_wall_vlist
FORCE_SYMBOL $1264 Draw_VLp_digit
FORCE_SYMBOL $1267 no_left_return
FORCE_SYMBOL $126A Draw_VLp_digit
FORCE_SYMBOL $126F helper_first
FORCE_SYMBOL $1274 left_wall_vlist_first
FORCE_SYMBOL $1277 Draw_VLp_digit
FORCE_SYMBOL $127A left_return_first
FORCE_SYMBOL $127D Draw_VLp_digit
FORCE_SYMBOL $1282 left_wall_vlist
FORCE_SYMBOL $1285 Draw_VLp_digit
FORCE_SYMBOL $1288 left_return
FORCE_SYMBOL $128B Draw_VLp_digit
FORCE_SYMBOL $129A no_right_wall_vlist
FORCE_SYMBOL $129D Draw_VLp_digit
FORCE_SYMBOL $12A2 helper_first
FORCE_SYMBOL $12A7 right_wall_vlist_first
FORCE_SYMBOL $12AA Draw_VLp_digit
FORCE_SYMBOL $12AF right_wall_vlist
FORCE_SYMBOL $12B2 Draw_VLp_digit
FORCE_SYMBOL $12B5 helper_first
FORCE_NO_SYMBOL $12B8
COMMENT_LINE $12C0 bra no_monster_in_front
COMMENT_LINE $12C0 do monster stuff
COMMENT_LINE $12C0 if we do all monster stuff here we don't have to worry about
COMMENT_LINE $12C0 positioning, since we are last :-)
COMMENT_LINE $12C0 calculate scale for image
COMMENT_LINE $12C0 that is our offset + figure offset + mazeparts in between
COMMENT $12C0 view position of current maze square
FORCE_SYMBOL $12C0 view_pos_y
COMMENT $12C3 current position in view
FORCE_SYMBOL $12C3 view_pos_y
COMMENT $12C6 y pos equal?
FORCE_SYMBOL $12C6 V_MONSTER_Y
COMMENT $12C9 no -> branch
COMMENT_LINE $12CD we have a monster in our visibility!
FORCE_NO_SYMBOL $12CD
COMMENT $12CF /BLANK low and /ZERO low
FORCE_SYMBOL $12CF VIA_cntl
COMMENT_LINE $12D1 calculate size
COMMENT_LINE $12D1 since monsters can move of there own,
COMMENT_LINE $12D1 we must :-( calculate their size!
COMMENT_LINE $12D1 following is already set from above
COMMENT_LINE $12D1 keep it here as a reminder that we use it!
COMMENT $12D1 helper for # of divides for scale
FORCE_SYMBOL $12D1 tmp0
COMMENT $12D4 load our own offset
FORCE_SYMBOL $12D4 move_offset_y
COMMENT $12D7 we use bigger numbers now
COMMENT $12D8 offset it with monster offset
FORCE_SYMBOL $12D8 V_MONSTER_OFFSET_Y
COMMENT_LINE $12DB D is -DOUBLE_STEP - +DOUBLE_STEP
COMMENT_LINE $12DB should be -STEP - +STEP
COMMENT_LINE $12DB that's what we do now
COMMENT $12DB is it negative?
COMMENT $12DC well, than go there
COMMENT $12DE is it to big?
FORCE_SYMBOL $12DE STEPS
COMMENT_LINE $12E2 to big means the combined offsets
COMMENT_LINE $12E2 are smaller than one maze square
COMMENT_LINE $12E2 so we have to use one divider
COMMENT_LINE $12E2 less
COMMENT $12E2 nope, than all ok
COMMENT $12E4 to big, correct offset
FORCE_SYMBOL $12E4 DOUBLE_STEP
COMMENT $12E7 and one LSR less
FORCE_SYMBOL $12E7 tmp0
COMMENT $12EA done here
COMMENT $12EC y pos of monster, allways greater than man!
FORCE_SYMBOL $12EC V_MONSTER_Y
COMMENT $12EF our own position
FORCE_SYMBOL $12EF maze_draw_y
COMMENT $12F2 any offsets from above added
FORCE_SYMBOL $12F2 tmp0
FORCE_SYMBOL $12FB halving_done_digit
COMMENT $12FE is it to small?
COMMENT_LINE $1302 to small means the combined offsets
COMMENT_LINE $1302 are bigger than one maze square
COMMENT_LINE $1302 so we have to use one divider
COMMENT_LINE $1302 more
COMMENT $1302 nope, than all ok
COMMENT $1304 to small, correct offset
FORCE_SYMBOL $1304 DOUBLE_STEP
COMMENT $1307 and one LSR more
FORCE_SYMBOL $1307 tmp0
COMMENT_LINE $130A B is be -STEP - +STEP
COMMENT_LINE $130A should be 0 - +DOUBLE_STEP
FORCE_SYMBOL $130A STEPS
COMMENT $130F wait till the last played
COMMENT $130F get timer
FORCE_SYMBOL $130F VIA_t2_hi
COMMENT_LINE $1311 note:
COMMENT_LINE $1311 by reading the timer we
COMMENT_LINE $1311 can MISS an interrupt state
COMMENT_LINE $1311 since reading clears the
COMMENT_LINE $1311 interrupt!
COMMENT_LINE $1311 during recalibration this
COMMENT_LINE $1311 is considered (see below)
COMMENT_LINE $1311 hopefully we have NO
COMMENT_LINE $1311 interrupt miss here!
COMMENT $1311 and compare to next
FORCE_SYMBOL $1311 digit_next_digit_cycle
COMMENT_LINE $1314 time we should update
COMMENT $1314 not yet? than test again
COMMENT $1316 note:
FORCE_SYMBOL $1316 T2_TIMER_PEROID_REAL
COMMENT_LINE $1318 if this thing is called early enough
COMMENT_LINE $1318 we could calculate this above
COMMENT_LINE $1318 and save some cycles here!
COMMENT_LINE $1318 on the other hand, IF we are called early
COMMENT_LINE $1318 enough... we don't need to save cycles :-)
COMMENT $1318 and store it
FORCE_SYMBOL $1318 digit_next_digit_cycle
COMMENT_LINE $131B sample-byte is finnished
COMMENT $131B load the next sample_byte to A
COMMENT_LINE $131D and store it to the 6522 -> PSG
COMMENT $131D store in reg A in 6522 (DAC)
FORCE_SYMBOL $131D VIA_port_a
COMMENT_LINE $131F following must come after the above, or we
COMMENT_LINE $131F put noise to the psg,
COMMENT_LINE $131F likewise, before storing anything else to
COMMENT_LINE $131F port A, we will disable the connection to PSG
COMMENT $131F this sets the MUX of 6522 to PSG
COMMENT $131F load the calculated VIA B
FORCE_SYMBOL $131F via_b_start
COMMENT $1322 write back to reg B in 6522
FORCE_SYMBOL $1322 VIA_port_b
COMMENT $1324 Clear shift regigster, why ???
FORCE_SYMBOL $1324 VIA_shift_reg
COMMENT_LINE $1326 without it, the display 'wobbles' a bit???
COMMENT $1326 and disable the mux, so no junk will
FORCE_SYMBOL $1326 VIA_port_b
COMMENT_LINE $1328 enter our PSG-DAC...
COMMENT_LINE $132A in D now 0 - DOUBLE_STEP
COMMENT $132A multiply with laby magic
FORCE_SYMBOL $132A LAB_REDUCT_1
COMMENT $132D and divide by DOUBLE STEP
COMMENT $132D this divides d by 64
COMMENT $132E result in A
COMMENT $1331 this is a divider 3
FORCE_NO_SYMBOL $1331
FORCE_NO_SYMBOL $1335
FORCE_SYMBOL $1337 NOT_CARRY
COMMENT $1339 roll in carry
FORCE_NO_SYMBOL $133A
FORCE_NO_SYMBOL $133E
FORCE_SYMBOL $1340 NOT_CARRY
COMMENT $1342 roll in carry
FORCE_NO_SYMBOL $1343
FORCE_NO_SYMBOL $1347
FORCE_SYMBOL $1349 NOT_CARRY
COMMENT $134B roll in carry
FORCE_NO_SYMBOL $134C
FORCE_NO_SYMBOL $1350
FORCE_SYMBOL $1352 NOT_CARRY
COMMENT $1354 roll in carry
FORCE_NO_SYMBOL $1355
FORCE_NO_SYMBOL $1359
FORCE_SYMBOL $135B NOT_CARRY
COMMENT $135D roll in carry
FORCE_NO_SYMBOL $135E
FORCE_NO_SYMBOL $1362
FORCE_SYMBOL $1364 NOT_CARRY
COMMENT $1366 roll in carry
FORCE_NO_SYMBOL $1367
FORCE_NO_SYMBOL $136B
FORCE_SYMBOL $136D NOT_CARRY
COMMENT $136F roll in carry
FORCE_SYMBOL $1372 CARRY
COMMENT $1374 roll in carry
FORCE_SYMBOL $1377 CARRY
COMMENT $1379 roll in carry
FORCE_SYMBOL $137C CARRY
COMMENT $137E roll in carry
FORCE_SYMBOL $1381 CARRY
COMMENT $1383 roll in carry
FORCE_SYMBOL $1386 CARRY
COMMENT $1388 roll in carry
FORCE_SYMBOL $138B CARRY
COMMENT $138D roll in carry
FORCE_SYMBOL $1390 CARRY
COMMENT $1392 roll in carry
COMMENT $1393 do more magic
COMMENT $1394 and voila our first scale is there!
FORCE_SYMBOL $1394 LAB_SCALE
COMMENT_LINE $1396 now lets see how many divides we need
COMMENT $1396 y pos of monster, allways greater than man!
FORCE_SYMBOL $1396 V_MONSTER_Y
COMMENT $1399 our own position
FORCE_SYMBOL $1399 maze_draw_y
COMMENT $139C any offsets from above added
FORCE_SYMBOL $139C tmp0
COMMENT $13A0 perhaps nothing to do?
COMMENT $13A2 halve it
COMMENT $13A3 loop count -1
COMMENT $13A4 done?
FORCE_SYMBOL $13A6 scale_shadow
COMMENT_LINE $13A9 phuu
COMMENT_LINE $13A9 done the sizing of our creature
COMMENT_LINE $13A9 shitty stuff
COMMENT $13A9 x  equal?
FORCE_SYMBOL $13A9 V_MONSTER_X
COMMENT $13B3 x pointer to monster level list
FORCE_SYMBOL $13B3 V_MONSTER_POINTER
COMMENT $13B6 load pointer to current graphic
FORCE_SYMBOL $13B6 C_MONSTER_GRAPHIC
COMMENT_LINE $13BA bei gesamtbreite des monsters = 2 * SQUARE SIZE!,
COMMENT_LINE $13BA dann koennte die X pos als
COMMENT_LINE $13BA clipping gebarucht werden!
COMMENT_LINE $13BA Am einfachsten, einen 0 offset von links einfï¿½hren!
COMMENT $13BA wait till the last played
COMMENT $13BA get timer
FORCE_SYMBOL $13BA VIA_t2_hi
COMMENT_LINE $13BC note:
COMMENT_LINE $13BC by reading the timer we
COMMENT_LINE $13BC can MISS an interrupt state
COMMENT_LINE $13BC since reading clears the
COMMENT_LINE $13BC interrupt!
COMMENT_LINE $13BC during recalibration this
COMMENT_LINE $13BC is considered (see below)
COMMENT_LINE $13BC hopefully we have NO
COMMENT_LINE $13BC interrupt miss here!
COMMENT $13BC and compare to next
FORCE_SYMBOL $13BC digit_next_digit_cycle
COMMENT_LINE $13BF time we should update
COMMENT $13BF not yet? than test again
COMMENT $13C1 note:
FORCE_SYMBOL $13C1 T2_TIMER_PEROID_REAL
COMMENT_LINE $13C3 if this thing is called early enough
COMMENT_LINE $13C3 we could calculate this above
COMMENT_LINE $13C3 and save some cycles here!
COMMENT_LINE $13C3 on the other hand, IF we are called early
COMMENT_LINE $13C3 enough... we don't need to save cycles :-)
COMMENT $13C3 and store it
FORCE_SYMBOL $13C3 digit_next_digit_cycle
COMMENT_LINE $13C6 sample-byte is finnished
COMMENT $13C6 load the next sample_byte to A
COMMENT_LINE $13C8 and store it to the 6522 -> PSG
COMMENT $13C8 store in reg A in 6522 (DAC)
FORCE_SYMBOL $13C8 VIA_port_a
COMMENT_LINE $13CA following must come after the above, or we
COMMENT_LINE $13CA put noise to the psg,
COMMENT_LINE $13CA likewise, before storing anything else to
COMMENT_LINE $13CA port A, we will disable the connection to PSG
COMMENT $13CA this sets the MUX of 6522 to PSG
COMMENT $13CA load the calculated VIA B
FORCE_SYMBOL $13CA via_b_start
COMMENT $13CD write back to reg B in 6522
FORCE_SYMBOL $13CD VIA_port_b
COMMENT $13CF Clear shift regigster, why ???
FORCE_SYMBOL $13CF VIA_shift_reg
COMMENT_LINE $13D1 without it, the display 'wobbles' a bit???
COMMENT $13D1 and disable the mux, so no junk will
FORCE_SYMBOL $13D1 VIA_port_b
COMMENT_LINE $13D3 enter our PSG-DAC...
COMMENT $13D3 these are steps, gotto convert to 2* square
FORCE_SYMBOL $13D3 V_MONSTER_OFFSET_X
COMMENT_LINE $13D6 step == square
FORCE_SYMBOL $13D8 clip_vlp_p2_left_digit
FORCE_SYMBOL $13DD V_MONSTER_MOVEMENT_AXIS
FORCE_SYMBOL $13E2 scale_shadow
COMMENT $13E5 move to time 1 lo, this means scaling
FORCE_SYMBOL $13E5 VIA_t1_cnt_lo
FORCE_NO_SYMBOL $13E7
FORCE_SYMBOL $13EB move_to_d_digit
FORCE_SYMBOL $13EE scale_shadow
COMMENT $13F1 halve it
COMMENT $13F2 move to time 1 lo, this means scaling
FORCE_SYMBOL $13F2 VIA_t1_cnt_lo
FORCE_NO_SYMBOL $13F6
FORCE_SYMBOL $13FA move_to_d_digit
FORCE_SYMBOL $13FD scale_shadow
COMMENT $1400 halve it
COMMENT $1401 move to time 1 lo, this means scaling
FORCE_SYMBOL $1401 VIA_t1_cnt_lo
FORCE_NO_SYMBOL $1403
FORCE_SYMBOL $1405 V_MONSTER_OFFSET_X
FORCE_SYMBOL $1408 move_to_d_digit
FORCE_SYMBOL $140B Draw_VLp_digit
FORCE_SYMBOL $140E finish_current_maze_digit
COMMENT $1411 x pointer to monster level list
FORCE_SYMBOL $1411 V_MONSTER_POINTER
COMMENT $1414 load pointer to current graphic
FORCE_SYMBOL $1414 C_MONSTER_GRAPHIC
COMMENT_LINE $1418 bei gesamtbreite des monsters = 2 * SQUARE SIZE!,
COMMENT_LINE $1418 dann koennte die X pos als
COMMENT_LINE $1418 clipping gebarucht werden!
COMMENT_LINE $1418 Am einfachsten, einen 0 offset von links einfï¿½hren!
COMMENT $1418 wait till the last played
COMMENT $1418 get timer
FORCE_SYMBOL $1418 VIA_t2_hi
COMMENT_LINE $141A note:
COMMENT_LINE $141A by reading the timer we
COMMENT_LINE $141A can MISS an interrupt state
COMMENT_LINE $141A since reading clears the
COMMENT_LINE $141A interrupt!
COMMENT_LINE $141A during recalibration this
COMMENT_LINE $141A is considered (see below)
COMMENT_LINE $141A hopefully we have NO
COMMENT_LINE $141A interrupt miss here!
COMMENT $141A and compare to next
FORCE_SYMBOL $141A digit_next_digit_cycle
COMMENT_LINE $141D time we should update
COMMENT $141D not yet? than test again
COMMENT $141F note:
FORCE_SYMBOL $141F T2_TIMER_PEROID_REAL
COMMENT_LINE $1421 if this thing is called early enough
COMMENT_LINE $1421 we could calculate this above
COMMENT_LINE $1421 and save some cycles here!
COMMENT_LINE $1421 on the other hand, IF we are called early
COMMENT_LINE $1421 enough... we don't need to save cycles :-)
COMMENT $1421 and store it
FORCE_SYMBOL $1421 digit_next_digit_cycle
COMMENT_LINE $1424 sample-byte is finnished
COMMENT $1424 load the next sample_byte to A
COMMENT_LINE $1426 and store it to the 6522 -> PSG
COMMENT $1426 store in reg A in 6522 (DAC)
FORCE_SYMBOL $1426 VIA_port_a
COMMENT_LINE $1428 following must come after the above, or we
COMMENT_LINE $1428 put noise to the psg,
COMMENT_LINE $1428 likewise, before storing anything else to
COMMENT_LINE $1428 port A, we will disable the connection to PSG
COMMENT $1428 this sets the MUX of 6522 to PSG
COMMENT $1428 load the calculated VIA B
FORCE_SYMBOL $1428 via_b_start
COMMENT $142B write back to reg B in 6522
FORCE_SYMBOL $142B VIA_port_b
COMMENT $142D Clear shift regigster, why ???
FORCE_SYMBOL $142D VIA_shift_reg
COMMENT_LINE $142F without it, the display 'wobbles' a bit???
COMMENT $142F and disable the mux, so no junk will
FORCE_SYMBOL $142F VIA_port_b
COMMENT_LINE $1431 enter our PSG-DAC...
COMMENT $1431 these are steps, gotto convert to 2* square
FORCE_SYMBOL $1431 V_MONSTER_OFFSET_X
COMMENT_LINE $1434 step == square
FORCE_SYMBOL $1436 clip_vlp_p2_right_digit
FORCE_SYMBOL $143B V_MONSTER_MOVEMENT_AXIS
FORCE_SYMBOL $1440 scale_shadow
COMMENT $1443 move to time 1 lo, this means scaling
FORCE_SYMBOL $1443 VIA_t1_cnt_lo
FORCE_NO_SYMBOL $1445
FORCE_SYMBOL $1447 SQUARE_SIZE
FORCE_SYMBOL $1449 move_to_d_digit
FORCE_SYMBOL $144C scale_shadow
COMMENT $144F halve it
COMMENT $1450 move to time 1 lo, this means scaling
FORCE_SYMBOL $1450 VIA_t1_cnt_lo
FORCE_NO_SYMBOL $1454
FORCE_SYMBOL $1456 SQUARE_SIZE
FORCE_SYMBOL $1458 move_to_d_digit
FORCE_SYMBOL $145B scale_shadow
COMMENT $145E halve it
COMMENT $145F move to time 1 lo, this means scaling
FORCE_SYMBOL $145F VIA_t1_cnt_lo
FORCE_NO_SYMBOL $1461
FORCE_SYMBOL $1463 V_MONSTER_OFFSET_X
FORCE_SYMBOL $1466 move_to_d_digit
FORCE_SYMBOL $1469 Draw_VLp_digit
COMMENT $146E x pointer to monster level list
FORCE_SYMBOL $146E V_MONSTER_POINTER
COMMENT $1471 load pointer to current graphic
FORCE_SYMBOL $1471 C_MONSTER_GRAPHIC
COMMENT_LINE $1473 bei gesamtbreite des monsters = 2 * SQUARE SIZE!,
COMMENT_LINE $1473 dann koennte die X pos als
COMMENT_LINE $1473 clipping gebarucht werden!
COMMENT_LINE $1473 Am einfachsten, einen 0 offset von links einfï¿½hren!
COMMENT $1473 wait till the last played
COMMENT $1473 get timer
FORCE_SYMBOL $1473 VIA_t2_hi
COMMENT_LINE $1475 note:
COMMENT_LINE $1475 by reading the timer we
COMMENT_LINE $1475 can MISS an interrupt state
COMMENT_LINE $1475 since reading clears the
COMMENT_LINE $1475 interrupt!
COMMENT_LINE $1475 during recalibration this
COMMENT_LINE $1475 is considered (see below)
COMMENT_LINE $1475 hopefully we have NO
COMMENT_LINE $1475 interrupt miss here!
COMMENT $1475 and compare to next
FORCE_SYMBOL $1475 digit_next_digit_cycle
COMMENT_LINE $1478 time we should update
COMMENT $1478 not yet? than test again
COMMENT $147A note:
FORCE_SYMBOL $147A T2_TIMER_PEROID_REAL
COMMENT_LINE $147C if this thing is called early enough
COMMENT_LINE $147C we could calculate this above
COMMENT_LINE $147C and save some cycles here!
COMMENT_LINE $147C on the other hand, IF we are called early
COMMENT_LINE $147C enough... we don't need to save cycles :-)
COMMENT $147C and store it
FORCE_SYMBOL $147C digit_next_digit_cycle
COMMENT_LINE $147F sample-byte is finnished
COMMENT $147F load the next sample_byte to A
COMMENT_LINE $1481 and store it to the 6522 -> PSG
COMMENT $1481 store in reg A in 6522 (DAC)
FORCE_SYMBOL $1481 VIA_port_a
COMMENT_LINE $1483 following must come after the above, or we
COMMENT_LINE $1483 put noise to the psg,
COMMENT_LINE $1483 likewise, before storing anything else to
COMMENT_LINE $1483 port A, we will disable the connection to PSG
COMMENT $1483 this sets the MUX of 6522 to PSG
COMMENT $1483 load the calculated VIA B
FORCE_SYMBOL $1483 via_b_start
COMMENT $1486 write back to reg B in 6522
FORCE_SYMBOL $1486 VIA_port_b
COMMENT $1488 Clear shift regigster, why ???
FORCE_SYMBOL $1488 VIA_shift_reg
COMMENT_LINE $148A without it, the display 'wobbles' a bit???
COMMENT $148A and disable the mux, so no junk will
FORCE_SYMBOL $148A VIA_port_b
COMMENT_LINE $148C enter our PSG-DAC...
COMMENT $148C these are steps, gotto convert to 2* square
FORCE_SYMBOL $148C V_MONSTER_OFFSET_X
FORCE_SYMBOL $149A clip_vlp_p2_left_digit
FORCE_SYMBOL $149F scale_shadow
COMMENT $14A2 halve it
COMMENT $14A3 move to time 1 lo, this means scaling
FORCE_SYMBOL $14A3 VIA_t1_cnt_lo
FORCE_NO_SYMBOL $14A5
FORCE_SYMBOL $14A7 V_MONSTER_OFFSET_X
FORCE_SYMBOL $14AA move_to_d_digit
COMMENT_LINE $14AD now we can display it :-)
FORCE_SYMBOL $14AD Draw_VLp_digit
FORCE_NO_SYMBOL $14B0
COMMENT $14B2 /BLANK low and /ZERO low
FORCE_SYMBOL $14B2 VIA_cntl
FORCE_SYMBOL $14B4 maze_intensity
FORCE_SYMBOL $14B7 LIGHT
FORCE_SYMBOL $14BB maze_intensity
FORCE_SYMBOL $14BE scale_step
FORCE_NO_SYMBOL $14C1
FORCE_SYMBOL $14C3 next_maze_digit
COMMENT_LINE $14C7 ***************************************************************************
FORCE_SYMBOL $14C7 pos_offset_x
FORCE_SYMBOL $14CB move_offset_y
FORCE_SYMBOL $14D0 pos_x
FORCE_SYMBOL $14D3 maze_draw_y
FORCE_SYMBOL $14D6 maze_ram
FORCE_SYMBOL $14D9 current_maze
FORCE_SYMBOL $14DC pos_y
FORCE_SYMBOL $14E0 MAZE_SIZE
FORCE_SYMBOL $14E7 MAZE_SIZE
FORCE_NO_SYMBOL $14E9
FORCE_SYMBOL $14ED MAZE_SIZE
FORCE_NO_SYMBOL $14F7
COMMENT_LINE $14FF ***************************************************************************
FORCE_SYMBOL $14FF pos_offset_y
FORCE_SYMBOL $1503 move_offset_y
FORCE_SYMBOL $1508 pos_y
FORCE_SYMBOL $150B maze_draw_y
FORCE_SYMBOL $150E maze_ram
FORCE_SYMBOL $1511 current_maze
FORCE_SYMBOL $1514 pos_x
FORCE_SYMBOL $151E MAZE_SIZE
FORCE_NO_SYMBOL $1520
FORCE_NO_SYMBOL $1524
FORCE_NO_SYMBOL $1528
FORCE_NO_SYMBOL $152C
COMMENT_LINE $1534 ***************************************************************************
FORCE_SYMBOL $1534 pos_offset_x
FORCE_SYMBOL $1537 move_offset_y
FORCE_SYMBOL $153A pos_x
FORCE_SYMBOL $153D maze_draw_y
FORCE_SYMBOL $1540 maze_ram
FORCE_SYMBOL $1543 current_maze
FORCE_SYMBOL $1546 pos_y
FORCE_SYMBOL $154A MAZE_SIZE
FORCE_SYMBOL $154F MAZE_SIZE
FORCE_SYMBOL $1556 MAZE_SIZE
FORCE_NO_SYMBOL $155B
FORCE_NO_SYMBOL $155F
FORCE_NO_SYMBOL $1561
COMMENT_LINE $1567 ***************************************************************************
FORCE_SYMBOL $1567 pos_offset_y
FORCE_SYMBOL $156A move_offset_y
FORCE_SYMBOL $156D pos_y
FORCE_SYMBOL $1570 maze_draw_y
FORCE_SYMBOL $1573 maze_ram
FORCE_SYMBOL $1576 current_maze
FORCE_SYMBOL $1579 pos_x
FORCE_SYMBOL $157F MAZE_SIZE
FORCE_NO_SYMBOL $1581
FORCE_NO_SYMBOL $1585
FORCE_NO_SYMBOL $1589
FORCE_NO_SYMBOL $158D
FORCE_SYMBOL $158F MAZE_SIZE
COMMENT_LINE $1596 ***************************************************************************
COMMENT_LINE $1677 ***************************************************************************
COMMENT $1677 read joystick positions
FORCE_SYMBOL $1677 Joy_Digital
FORCE_SYMBOL $167A next_digit
COMMENT $167D load joystick 1 position Y to A
FORCE_SYMBOL $167D Vec_Joy_1_Y
COMMENT $1686 load current y position
FORCE_SYMBOL $1686 maze_draw_y
COMMENT $1689 look at next wall, not
COMMENT_LINE $168A at current position
COMMENT $168A maze view is 4 size
COMMENT $168C plus 1 for current position
COMMENT $168D and load maze address
FORCE_SYMBOL $168D maze_ram
COMMENT $1690 add them
COMMENT_LINE $1692 in U position ahead of current position
COMMENT $1692 A has current ahead char
FORCE_NO_SYMBOL $1692
FORCE_SYMBOL $1694 move_offset_y
FORCE_SYMBOL $1697 SPEED
FORCE_SYMBOL $1699 move_offset_y
FORCE_SYMBOL $169C STEPS
FORCE_SYMBOL $16A4 maze_draw_y
FORCE_SYMBOL $16A9 move_offset_y
FORCE_SYMBOL $16B0 move_offset_y
COMMENT $16B5 load current y position
FORCE_SYMBOL $16B5 maze_draw_y
COMMENT $16B8 look at wall behind, not
COMMENT_LINE $16B9 at current position
COMMENT $16B9 maze view is 4 size
COMMENT $16BB plus 1 for current position
COMMENT $16BC and load maze address
FORCE_SYMBOL $16BC maze_ram
COMMENT $16BF add them
COMMENT_LINE $16C1 in U position ahead of current position
COMMENT $16C1 A has current ahead char
FORCE_NO_SYMBOL $16C1
FORCE_SYMBOL $16C3 move_offset_y
FORCE_SYMBOL $16C6 SPEED
FORCE_SYMBOL $16C8 move_offset_y
FORCE_SYMBOL $16D3 maze_draw_y
FORCE_SYMBOL $16D8 move_offset_y
FORCE_SYMBOL $16DF move_offset_y
COMMENT $16E2 load joystick 1 position Y to A
FORCE_SYMBOL $16E2 Vec_Joy_1_X
FORCE_SYMBOL $16E7 last_x_pressed
FORCE_SYMBOL $16EC last_x_pressed
FORCE_SYMBOL $16F1 display_turn_left
FORCE_SYMBOL $16F4 init_turn_left
FORCE_SYMBOL $16F8 display_turn_right
FORCE_SYMBOL $16FB init_turn_right
FORCE_SYMBOL $16FF last_x_pressed
COMMENT_LINE $1703 ***************************************************************************
COMMENT $1703 read joystick positions
FORCE_SYMBOL $1703 Joy_Digital
COMMENT $1706 wait till the last played
COMMENT $1706 get timer
FORCE_SYMBOL $1706 VIA_t2_hi
COMMENT_LINE $1708 note:
COMMENT_LINE $1708 by reading the timer we
COMMENT_LINE $1708 can MISS an interrupt state
COMMENT_LINE $1708 since reading clears the
COMMENT_LINE $1708 interrupt!
COMMENT_LINE $1708 during recalibration this
COMMENT_LINE $1708 is considered (see below)
COMMENT_LINE $1708 hopefully we have NO
COMMENT_LINE $1708 interrupt miss here!
COMMENT $1708 and compare to next
FORCE_SYMBOL $1708 digit_next_digit_cycle
COMMENT_LINE $170B time we should update
COMMENT $170B not yet? than test again
COMMENT $170D note:
FORCE_SYMBOL $170D T2_TIMER_PEROID_REAL
COMMENT_LINE $170F if this thing is called early enough
COMMENT_LINE $170F we could calculate this above
COMMENT_LINE $170F and save some cycles here!
COMMENT_LINE $170F on the other hand, IF we are called early
COMMENT_LINE $170F enough... we don't need to save cycles :-)
COMMENT $170F and store it
FORCE_SYMBOL $170F digit_next_digit_cycle
COMMENT_LINE $1712 sample-byte is finnished
COMMENT $1712 load the next sample_byte to A
COMMENT_LINE $1714 and store it to the 6522 -> PSG
COMMENT $1714 store in reg A in 6522 (DAC)
FORCE_SYMBOL $1714 VIA_port_a
COMMENT_LINE $1716 following must come after the above, or we
COMMENT_LINE $1716 put noise to the psg,
COMMENT_LINE $1716 likewise, before storing anything else to
COMMENT_LINE $1716 port A, we will disable the connection to PSG
COMMENT $1716 this sets the MUX of 6522 to PSG
COMMENT $1716 load the calculated VIA B
FORCE_SYMBOL $1716 via_b_start
COMMENT $1719 write back to reg B in 6522
FORCE_SYMBOL $1719 VIA_port_b
COMMENT $171B Clear shift regigster, why ???
FORCE_SYMBOL $171B VIA_shift_reg
COMMENT_LINE $171D without it, the display 'wobbles' a bit???
COMMENT $171D and disable the mux, so no junk will
FORCE_SYMBOL $171D VIA_port_b
COMMENT_LINE $171F enter our PSG-DAC...
COMMENT $171F load joystick 1 position Y to A
FORCE_SYMBOL $171F Vec_Joy_1_Y
COMMENT $1728 load current y position
FORCE_SYMBOL $1728 maze_draw_y
COMMENT $172B look at next wall, not
COMMENT_LINE $172C at current position
COMMENT $172C maze view is 4 size
COMMENT $172E plus 1 for current position
COMMENT $172F and load maze address
FORCE_SYMBOL $172F maze_ram
COMMENT $1732 add them
COMMENT_LINE $1734 in U position ahead of current position
COMMENT $1734 A has current ahead char
FORCE_NO_SYMBOL $1734
FORCE_SYMBOL $1736 move_offset_y
FORCE_SYMBOL $1739 SPEED
FORCE_SYMBOL $173B move_offset_y
FORCE_SYMBOL $173E STEPS
FORCE_SYMBOL $1746 maze_draw_y
FORCE_SYMBOL $174B move_offset_y
FORCE_SYMBOL $1752 move_offset_y
COMMENT $1757 load current y position
FORCE_SYMBOL $1757 maze_draw_y
COMMENT $175A look at wall behind, not
COMMENT_LINE $175B at current position
COMMENT $175B maze view is 4 size
COMMENT $175D plus 1 for current position
COMMENT $175E and load maze address
FORCE_SYMBOL $175E maze_ram
COMMENT $1761 add them
COMMENT_LINE $1763 in U position ahead of current position
COMMENT $1763 A has current ahead char
FORCE_NO_SYMBOL $1763
FORCE_SYMBOL $1765 move_offset_y
FORCE_SYMBOL $1768 SPEED
FORCE_SYMBOL $176A move_offset_y
FORCE_SYMBOL $1775 maze_draw_y
FORCE_SYMBOL $177A move_offset_y
FORCE_SYMBOL $1781 move_offset_y
COMMENT $1784 load joystick 1 position Y to A
FORCE_SYMBOL $1784 Vec_Joy_1_X
FORCE_SYMBOL $1789 last_x_pressed
FORCE_SYMBOL $178E last_x_pressed
FORCE_SYMBOL $1793 display_turn_left
FORCE_SYMBOL $1796 init_turn_left
FORCE_SYMBOL $179A display_turn_right
FORCE_SYMBOL $179D init_turn_right
FORCE_SYMBOL $17A1 last_x_pressed
COMMENT_LINE $17A5 ***************************************************************************
COMMENT_LINE $17A5 ***************************************************************************
COMMENT $18A5 start point in maze for player y, x
COMMENT $18A7 start looking direction
COMMENT $18A8 0 x, y position in Labyrinth
COMMENT $18AA 2 x, y offset position in field
COMMENT $18AC 4 moving type
COMMENT $18AD 5 moving type speed
COMMENT $18AE 6 moving type information (not used here)
COMMENT $18B2 10 monster information structure
COMMENT $18B4 0 x, y position in Labyrinth
COMMENT $18B6 2 x, y offset position in field
COMMENT $18B8 4 moving type
COMMENT $18B9 5 moving type speed
COMMENT $18BA 6 moving type information (not used here)
COMMENT $18BE 10 monster information structure
COMMENT $18C0 0 is end of monster definition for
COMMENT_LINE $18C2 current labyrinth
COMMENT_LINE $18C2 ***************************************************************************
COMMENT $18C2 0 special information TORCH_CARRYING, TREASURE TYPE...
COMMENT_LINE $18C3 baddie, goodie
COMMENT $18C3 1 graphic definition
COMMENT_LINE $18C5 ***************************************************************************
COMMENT $18C5 0 anim delay value
COMMENT $18C6 1 type of animation ANIMATION or MORPHING
COMMENT $18CF end of list
COMMENT_LINE $18D1 ***************************************************************************
COMMENT $18D1 for map drawing
COMMENT_LINE $18D1 '#'
COMMENT_LINE $18E1 ' '
COMMENT_LINE $18E5 'v'
COMMENT $1937 ym song
COMMENT $1937 vbl_len
COMMENT_LINE $1939 translation data
COMMENT_LINE $1939 DB $0D; bytes follow
COMMENT_LINE $1939 bits used, code, real 'byte'
COMMENT $1939 528
COMMENT $193C 576
COMMENT $193F 720
COMMENT $1942 912
COMMENT $1945 240
COMMENT $1948 288
COMMENT $194B 384
COMMENT $194E 423
COMMENT $1951 432
COMMENT $1954 480
COMMENT $1957 96
COMMENT $195A 144
COMMENT $195D 192
COMMENT_LINE $1960 phrases follow
COMMENT_LINE $1960 data follows
COMMENT $199C flushed
COMMENT_LINE $19A0 translation data
COMMENT_LINE $19A0 DB $05; bytes follow
COMMENT_LINE $19A0 bits used, code, real 'byte'
COMMENT $19A0 912
COMMENT $19A3 2592
COMMENT $19A6 423
COMMENT $19A9 720
COMMENT $19AC 768
COMMENT_LINE $19AF phrases follow
COMMENT_LINE $19AF data follows
COMMENT $19CD flushed
COMMENT_LINE $19CF translation data
COMMENT_LINE $19CF DB $18; bytes follow
COMMENT_LINE $19CF bits used, code, real 'byte'
COMMENT $19CF 608
COMMENT $19D2 608
COMMENT $19D5 736
COMMENT $19D8 768
COMMENT $19DB 224
COMMENT $19DE 304
COMMENT $19E1 368
COMMENT $19E4 471
COMMENT $19E7 176
COMMENT $19EA 192
COMMENT $19ED 192
COMMENT $19F0 208
COMMENT $19F3 32
COMMENT $19F6 64
COMMENT $19F9 64
COMMENT $19FC 64
COMMENT $19FF 128
COMMENT $1A02 32
COMMENT $1A05 32
COMMENT $1A08 48
COMMENT $1A0B 48
COMMENT $1A0E 16
COMMENT $1A11 16
COMMENT $1A14 16
COMMENT_LINE $1A17 phrases follow
COMMENT_LINE $1A17 data follows
COMMENT $1C0B flushed
COMMENT_LINE $1C0C translation data
COMMENT_LINE $1C0C DB $07; bytes follow
COMMENT_LINE $1C0C bits used, code, real 'byte'
COMMENT $1C0C 2720
COMMENT $1C0F 471
COMMENT $1C12 720
COMMENT $1C15 1248
COMMENT $1C18 192
COMMENT $1C1B 48
COMMENT $1C1E 16
COMMENT_LINE $1C21 phrases follow
COMMENT_LINE $1C21 data follows
COMMENT $1D61 flushed
COMMENT_LINE $1D69 translation data
COMMENT_LINE $1D69 DB $0C; bytes follow
COMMENT_LINE $1D69 bits used, code, real 'byte'
COMMENT $1D69 768
COMMENT $1D6C 336
COMMENT $1D6F 1200
COMMENT $1D72 1344
COMMENT $1D75 192
COMMENT $1D78 288
COMMENT $1D7B 423
COMMENT $1D7E 576
COMMENT $1D81 48
COMMENT $1D84 96
COMMENT $1D87 96
COMMENT $1D8A 48
COMMENT_LINE $1D8D phrases follow
COMMENT_LINE $1D8D data follows
COMMENT $1DD3 flushed
COMMENT_LINE $1DD8 translation data
COMMENT_LINE $1DD8 DB $07; bytes follow
COMMENT_LINE $1DD8 bits used, code, real 'byte'
COMMENT $1DD8 2784
COMMENT $1DDB 768
COMMENT $1DDE 912
COMMENT $1DE1 192
COMMENT $1DE4 240
COMMENT $1DE7 423
COMMENT $1DEA 96
COMMENT_LINE $1DED phrases follow
COMMENT_LINE $1DED data follows
COMMENT $1E1F flushed
COMMENT_LINE $1E26 translation data
COMMENT_LINE $1E26 DB $01; bytes follow
COMMENT_LINE $1E26 bits used, code, real 'byte'
COMMENT $1E26 5415
COMMENT_LINE $1E29 phrases follow
COMMENT_LINE $1E29 data follows
COMMENT $1E29 flushed
COMMENT_LINE $1E2D translation data
COMMENT_LINE $1E2D DB $05; bytes follow
COMMENT_LINE $1E2D bits used, code, real 'byte'
COMMENT $1E2D 4072
COMMENT $1E30 980
COMMENT $1E33 184
COMMENT $1E36 131
COMMENT $1E39 48
COMMENT_LINE $1E3C phrases follow
COMMENT_LINE $1E3C data follows
COMMENT $1E50 flushed
COMMENT_LINE $1E54 translation data
COMMENT_LINE $1E54 DB $12; bytes follow
COMMENT_LINE $1E54 bits used, code, real 'byte'
COMMENT $1E54 3032
COMMENT $1E57 400
COMMENT $1E5A 1179
COMMENT $1E5D 144
COMMENT $1E60 360
COMMENT $1E63 24
COMMENT $1E66 28
COMMENT $1E69 32
COMMENT $1E6C 32
COMMENT $1E6F 12
COMMENT $1E72 24
COMMENT $1E75 24
COMMENT $1E78 24
COMMENT $1E7B 24
COMMENT $1E7E 36
COMMENT $1E81 48
COMMENT $1E84 4
COMMENT $1E87 4
COMMENT_LINE $1E8A phrases follow
COMMENT $1E8A 400
COMMENT $1E93 360
COMMENT_LINE $1E9C data follows
COMMENT $1F78 flushed
COMMENT_LINE $1F7D translation data
COMMENT_LINE $1F7D DB $11; bytes follow
COMMENT_LINE $1F7D bits used, code, real 'byte'
COMMENT $1F7D 4665
COMMENT $1F80 502
COMMENT $1F83 139
COMMENT $1F86 8
COMMENT $1F89 16
COMMENT $1F8C 24
COMMENT $1F8F 8
COMMENT $1F92 8
COMMENT $1F95 8
COMMENT $1F98 8
COMMENT $1F9B 8
COMMENT $1F9E 8
COMMENT $1FA1 8
COMMENT $1FA4 8
COMMENT $1FA7 4
COMMENT $1FAA 4
COMMENT $1FAD 4
COMMENT_LINE $1FB0 phrases follow
COMMENT $1FB0 4665
COMMENT_LINE $1FC0 data follows
COMMENT $209C flushed
COMMENT_LINE $20A1 translation data
COMMENT_LINE $20A1 DB $11; bytes follow
COMMENT_LINE $20A1 bits used, code, real 'byte'
COMMENT $20A1 4192
COMMENT $20A4 391
COMMENT $20A7 480
COMMENT $20AA 32
COMMENT $20AD 32
COMMENT $20B0 32
COMMENT $20B3 32
COMMENT $20B6 32
COMMENT $20B9 32
COMMENT $20BC 32
COMMENT $20BF 32
COMMENT $20C2 32
COMMENT $20C5 32
COMMENT $20C8 32
COMMENT $20CB 4
COMMENT $20CE 4
COMMENT $20D1 4
COMMENT_LINE $20D4 phrases follow
COMMENT $20D4 480
COMMENT_LINE $20E1 data follows
COMMENT $2181 flushed
COMMENT_LINE $2189 This data does not appear in binary output!
COMMENT_LINE $21E5 A sample should have a small buffer behind it,
COMMENT_LINE $21E5 since it is only checked during recalibration whether the sample
COMMENT_LINE $21E5 is finished.
COMMENT_LINE $21E5 Using 2kHz samples playes about 40 samples per update round
COMMENT_LINE $21E5 -> in worst case we play 39 garbage samples.
COMMENT_LINE $21E5 turning is here worst case, since after turning another 'clean'
COMMENT_LINE $21E5 sample should be played.
COMMENT_LINE $21E5 without this buffer there is a noticeable 'click'.
COMMENT_LINE $2211 Backward data for binary file"data\turning.sam"
COMMENT $2211 11
COMMENT $221C 22
COMMENT $2227 33
COMMENT $2232 44
COMMENT $223D 55
COMMENT $2248 66
COMMENT $2253 77
COMMENT $225E 88
COMMENT $2269 99
COMMENT $2274 110
COMMENT $227F 121
COMMENT $228A 132
COMMENT $2295 143
COMMENT $22A0 154
COMMENT $22AB 165
COMMENT $22B6 176
COMMENT $22C1 187
COMMENT $22CC 198
COMMENT $22D7 209
COMMENT $22E2 220
COMMENT $22ED 231
COMMENT $22F8 242
COMMENT $2303 253
COMMENT $230E 264
COMMENT $2319 275
COMMENT $2324 286
COMMENT $232F 297
COMMENT $233A 308
COMMENT $2345 319
COMMENT $2350 330
COMMENT $235B 341
COMMENT $2366 352
COMMENT $2371 363
COMMENT $237C 374
COMMENT $2387 385
COMMENT $2392 396
COMMENT $239D 407
COMMENT $23A8 418
COMMENT $23B3 429
COMMENT $23BE 440
COMMENT $23C9 451
COMMENT $23D4 462
COMMENT $23DF 473
COMMENT $23EA 484
COMMENT $23F5 495
COMMENT $2400 506
COMMENT $240B 517
COMMENT $2416 528
COMMENT $2421 539
COMMENT $242C 550
COMMENT $2437 561
COMMENT $2442 572
COMMENT $244D 583
COMMENT $2458 594
COMMENT $2463 605
COMMENT $246E 616
COMMENT $2479 627
COMMENT $2484 638
COMMENT $248F 649
COMMENT $249A 660
COMMENT $24A5 671
COMMENT $24B0 682
COMMENT $24BB 693
COMMENT $24C6 704
COMMENT $24D1 715
COMMENT $24DC 726
COMMENT $24E7 737
COMMENT $24F2 748
COMMENT $24FD 759
COMMENT $2508 770
COMMENT $2513 781
COMMENT $251E 792
COMMENT $2529 803
COMMENT $2534 814
COMMENT_LINE $2546 ***************************************************************************
COMMENT_LINE $2546 Backward data for binary file"data\west.sam"
COMMENT $2546 11
COMMENT $2551 22
COMMENT $255C 33
COMMENT $2567 44
COMMENT $2572 55
COMMENT $257D 66
COMMENT $2588 77
COMMENT $2593 88
COMMENT $259E 99
COMMENT $25A9 110
COMMENT $25B4 121
COMMENT $25BF 132
COMMENT $25CA 143
COMMENT $25D5 154
COMMENT $25E0 165
COMMENT $25EB 176
COMMENT $25F6 187
COMMENT $2601 198
COMMENT $260C 209
COMMENT $2617 220
COMMENT $2622 231
COMMENT $262D 242
COMMENT $2638 253
COMMENT $2643 264
COMMENT $264E 275
COMMENT $2659 286
COMMENT $2664 297
COMMENT $266F 308
COMMENT $267A 319
COMMENT $2685 330
COMMENT $2690 341
COMMENT $269B 352
COMMENT $26A6 363
COMMENT $26B1 374
COMMENT $26BC 385
COMMENT $26C7 396
COMMENT $26D2 407
COMMENT $26DD 418
COMMENT $26E8 429
COMMENT $26F3 440
COMMENT $26FE 451
COMMENT $2709 462
COMMENT $2714 473
COMMENT $271F 484
COMMENT $272A 495
COMMENT $2735 506
COMMENT $2740 517
COMMENT $274B 528
COMMENT $2756 539
COMMENT $2761 550
COMMENT $276C 561
COMMENT $2777 572
COMMENT $2782 583
COMMENT $278D 594
COMMENT $2798 605
COMMENT $27A3 616
COMMENT $27AE 627
COMMENT $27B9 638
COMMENT $27C4 649
COMMENT $27CF 660
COMMENT $27DA 671
COMMENT $27E5 682
COMMENT $27F0 693
COMMENT $27FB 704
COMMENT $2806 715
COMMENT $2811 726
COMMENT $281C 737
COMMENT $2827 748
COMMENT $2832 759
COMMENT $283D 770
COMMENT $2848 781
COMMENT $2853 792
COMMENT $285E 803
COMMENT $2869 814
COMMENT $2874 825
COMMENT $287F 836
COMMENT $288A 847
COMMENT $2895 858
COMMENT $28A0 869
COMMENT $28AB 880
COMMENT $28B6 891
COMMENT $28C1 902
COMMENT $28CC 913
COMMENT $28D7 924
COMMENT $28E2 935
COMMENT $28ED 946
COMMENT $28F8 957
COMMENT $2903 968
COMMENT $290E 979
COMMENT $2919 990
COMMENT $2924 1001
COMMENT $292F 1012
COMMENT $293A 1023
COMMENT $2945 1034
COMMENT $2950 1045
COMMENT $295B 1056
COMMENT $2966 1067
COMMENT $2971 1078
COMMENT $297C 1089
COMMENT $2987 1100
COMMENT $2992 1111
COMMENT $299D 1122
COMMENT $29A8 1133
COMMENT $29B3 1144
COMMENT $29BE 1155
COMMENT $29C9 1166
COMMENT $29D4 1177
COMMENT $29DF 1188
COMMENT $29EA 1199
COMMENT_LINE $29FB ***************************************************************************
COMMENT_LINE $29FB Backward data for binary file"data\east.sam"
COMMENT $29FB 11
COMMENT $2A06 22
COMMENT $2A11 33
COMMENT $2A1C 44
COMMENT $2A27 55
COMMENT $2A32 66
COMMENT $2A3D 77
COMMENT $2A48 88
COMMENT $2A53 99
COMMENT $2A5E 110
COMMENT $2A69 121
COMMENT $2A74 132
COMMENT $2A7F 143
COMMENT $2A8A 154
COMMENT $2A95 165
COMMENT $2AA0 176
COMMENT $2AAB 187
COMMENT $2AB6 198
COMMENT $2AC1 209
COMMENT $2ACC 220
COMMENT $2AD7 231
COMMENT $2AE2 242
COMMENT $2AED 253
COMMENT $2AF8 264
COMMENT $2B03 275
COMMENT $2B0E 286
COMMENT $2B19 297
COMMENT $2B24 308
COMMENT $2B2F 319
COMMENT $2B3A 330
COMMENT $2B45 341
COMMENT $2B50 352
COMMENT $2B5B 363
COMMENT $2B66 374
COMMENT $2B71 385
COMMENT $2B7C 396
COMMENT $2B87 407
COMMENT $2B92 418
COMMENT $2B9D 429
COMMENT $2BA8 440
COMMENT $2BB3 451
COMMENT $2BBE 462
COMMENT $2BC9 473
COMMENT $2BD4 484
COMMENT $2BDF 495
COMMENT $2BEA 506
COMMENT $2BF5 517
COMMENT $2C00 528
COMMENT $2C0B 539
COMMENT $2C16 550
COMMENT $2C21 561
COMMENT $2C2C 572
COMMENT $2C37 583
COMMENT $2C42 594
COMMENT $2C4D 605
COMMENT $2C58 616
COMMENT $2C63 627
COMMENT $2C6E 638
COMMENT $2C79 649
COMMENT $2C84 660
COMMENT $2C8F 671
COMMENT $2C9A 682
COMMENT $2CA5 693
COMMENT $2CB0 704
COMMENT $2CBB 715
COMMENT $2CC6 726
COMMENT $2CD1 737
COMMENT $2CDC 748
COMMENT $2CE7 759
COMMENT $2CF2 770
COMMENT $2CFD 781
COMMENT $2D08 792
COMMENT $2D13 803
COMMENT $2D1E 814
COMMENT $2D29 825
COMMENT $2D34 836
COMMENT $2D3F 847
COMMENT $2D4A 858
COMMENT $2D55 869
COMMENT $2D60 880
COMMENT $2D6B 891
COMMENT $2D76 902
COMMENT_LINE $2D8B ***************************************************************************
COMMENT_LINE $2D8B Backward data for binary file"data\north.sam"
COMMENT $2D8B 11
COMMENT $2D96 22
COMMENT $2DA1 33
COMMENT $2DAC 44
COMMENT $2DB7 55
COMMENT $2DC2 66
COMMENT $2DCD 77
COMMENT $2DD8 88
COMMENT $2DE3 99
COMMENT $2DEE 110
COMMENT $2DF9 121
COMMENT $2E04 132
COMMENT $2E0F 143
COMMENT $2E1A 154
COMMENT $2E25 165
COMMENT $2E30 176
COMMENT $2E3B 187
COMMENT $2E46 198
COMMENT $2E51 209
COMMENT $2E5C 220
COMMENT $2E67 231
COMMENT $2E72 242
COMMENT $2E7D 253
COMMENT $2E88 264
COMMENT $2E93 275
COMMENT $2E9E 286
COMMENT $2EA9 297
COMMENT $2EB4 308
COMMENT $2EBF 319
COMMENT $2ECA 330
COMMENT $2ED5 341
COMMENT $2EE0 352
COMMENT $2EEB 363
COMMENT $2EF6 374
COMMENT $2F01 385
COMMENT $2F0C 396
COMMENT $2F17 407
COMMENT $2F22 418
COMMENT $2F2D 429
COMMENT $2F38 440
COMMENT $2F43 451
COMMENT $2F4E 462
COMMENT $2F59 473
COMMENT $2F64 484
COMMENT $2F6F 495
COMMENT $2F7A 506
COMMENT $2F85 517
COMMENT $2F90 528
COMMENT $2F9B 539
COMMENT $2FA6 550
COMMENT $2FB1 561
COMMENT $2FBC 572
COMMENT $2FC7 583
COMMENT $2FD2 594
COMMENT $2FDD 605
COMMENT $2FE8 616
COMMENT $2FF3 627
COMMENT $2FFE 638
COMMENT $3009 649
COMMENT $3014 660
COMMENT $301F 671
COMMENT $302A 682
COMMENT $3035 693
COMMENT $3040 704
COMMENT $304B 715
COMMENT $3056 726
COMMENT $3061 737
COMMENT $306C 748
COMMENT $3077 759
COMMENT $3082 770
COMMENT $308D 781
COMMENT $3098 792
COMMENT $30A3 803
COMMENT $30AE 814
COMMENT $30B9 825
COMMENT $30C4 836
COMMENT $30CF 847
COMMENT $30DA 858
COMMENT $30E5 869
COMMENT $30F0 880
COMMENT $30FB 891
COMMENT $3106 902
COMMENT $3111 913
COMMENT $311C 924
COMMENT $3127 935
COMMENT $3132 946
COMMENT $313D 957
COMMENT $3148 968
COMMENT $3153 979
COMMENT $315E 990
COMMENT $3169 1001
COMMENT $3174 1012
COMMENT $317F 1023
COMMENT $318A 1034
COMMENT $3195 1045
COMMENT $31A0 1056
COMMENT $31AB 1067
COMMENT_LINE $31BD ***************************************************************************
COMMENT_LINE $31BD Backward data for binary file"data\south.sam"
COMMENT $31BD 11
COMMENT $31C8 22
COMMENT $31D3 33
COMMENT $31DE 44
COMMENT $31E9 55
COMMENT $31F4 66
COMMENT $31FF 77
COMMENT $320A 88
COMMENT $3215 99
COMMENT $3220 110
COMMENT $322B 121
COMMENT $3236 132
COMMENT $3241 143
COMMENT $324C 154
COMMENT $3257 165
COMMENT $3262 176
COMMENT $326D 187
COMMENT $3278 198
COMMENT $3283 209
COMMENT $328E 220
COMMENT $3299 231
COMMENT $32A4 242
COMMENT $32AF 253
COMMENT $32BA 264
COMMENT $32C5 275
COMMENT $32D0 286
COMMENT $32DB 297
COMMENT $32E6 308
COMMENT $32F1 319
COMMENT $32FC 330
COMMENT $3307 341
COMMENT $3312 352
COMMENT $331D 363
COMMENT $3328 374
COMMENT $3333 385
COMMENT $333E 396
COMMENT $3349 407
COMMENT $3354 418
COMMENT $335F 429
COMMENT $336A 440
COMMENT $3375 451
COMMENT $3380 462
COMMENT $338B 473
COMMENT $3396 484
COMMENT $33A1 495
COMMENT $33AC 506
COMMENT $33B7 517
COMMENT $33C2 528
COMMENT $33CD 539
COMMENT $33D8 550
COMMENT $33E3 561
COMMENT $33EE 572
COMMENT $33F9 583
COMMENT $3404 594
COMMENT $340F 605
COMMENT $341A 616
COMMENT $3425 627
COMMENT $3430 638
COMMENT $343B 649
COMMENT $3446 660
COMMENT $3451 671
COMMENT $345C 682
COMMENT $3467 693
COMMENT $3472 704
COMMENT $347D 715
COMMENT $3488 726
COMMENT $3493 737
COMMENT $349E 748
COMMENT $34A9 759
COMMENT $34B4 770
COMMENT $34BF 781
COMMENT $34CA 792
COMMENT $34D5 803
COMMENT $34E0 814
COMMENT $34EB 825
COMMENT $34F6 836
COMMENT $3501 847
COMMENT $350C 858
COMMENT $3517 869
COMMENT $3522 880
COMMENT_LINE $3536 ***************************************************************************
COMMENT $3536 not looping
COMMENT $3537 start position of sample
COMMENT $3539 the length
COMMENT $353B start position of sample
COMMENT $353D the length
COMMENT $353F finish sample
COMMENT_LINE $3541 ***************************************************************************
COMMENT $3541 not looping
COMMENT $3542 start position of sample
COMMENT $3544 the length
COMMENT $3546 start position of sample
COMMENT $3548 the length
COMMENT $354A finish sample
COMMENT_LINE $354C ***************************************************************************
COMMENT $354C not looping
COMMENT $354D start position of sample
COMMENT $354F the length
COMMENT $3551 start position of sample
COMMENT $3553 the length
COMMENT $3555 finish sample
COMMENT_LINE $3557 ***************************************************************************
COMMENT $3557 not looping
COMMENT $3558 start position of sample
COMMENT $355A the length
COMMENT $355C start position of sample
COMMENT $355E the length
COMMENT $3560 finish sample
COMMENT_LINE $3562 ***************************************************************************
COMMENT_LINE $3562 ***************************************************************************
COMMENT_LINE $3562 goblin
COMMENT_LINE $3562 sprite for clipping, X sized 1, 2 or 4! (allways double)
COMMENT_LINE $3562 Size is 16 so ALL X are power of 2
COMMENT_LINE $3562 64 is highest :-(
COMMENT_LINE $3562 middle offset list for goblin_pic1
COMMENT_LINE $3664 ***************************************************************************
RANGE $0000-$055A DP $D0
RANGE $055A-$0579 DP $C8
RANGE $0579-$05F2 DP $D0
RANGE $05F2-$0634 DP $C8
RANGE $0634-$0634 DP $D0
RANGE $0634-$06E3 DP $C8
RANGE $06E3-$06EA DP $D0
RANGE $06EA-$0753 DP $C8
RANGE $0753-$0753 DP $D0
RANGE $0753-$082B DP $C8
RANGE $082B-$0832 DP $D0
RANGE $0832-$0874 DP $C8
RANGE $0874-$0874 DP $D0
RANGE $0874-$0928 DP $C8
RANGE $0928-$092F DP $D0
RANGE $092F-$0998 DP $C8
RANGE $0998-$0998 DP $D0
RANGE $0998-$0A75 DP $C8
RANGE $0A75-$3662 DP $D0
RANGE $0000-$000B CHAR_DATA 11
RANGE $000B-$000D DW_DATA 1
RANGE $000D-$0011 DB_DATA 4
RANGE $0011-$001F CHAR_DATA 14
RANGE $001F-$0023 DB_DATA 4
RANGE $0023-$002A CHAR_DATA 7
RANGE $002A-$002B DB_DATA 1
RANGE $002B-$002D CODE
RANGE $002E-$03A7 CODE
RANGE $03A8-$1596 CODE
RANGE $1596-$1597 DB_DATA 1
RANGE $1597-$1598 DB_DATA 1
RANGE $1598-$159B DB_DATA 3
RANGE $159B-$159E DB_DATA 3
RANGE $159E-$15A1 DB_DATA 3
RANGE $15A1-$15A4 DB_DATA 3
RANGE $15A4-$15A5 DB_DATA 1
RANGE $15A5-$15A8 DB_DATA 3
RANGE $15A8-$15AB DB_DATA 3
RANGE $15AB-$15AE DB_DATA 3
RANGE $15AE-$15B1 DB_DATA 3
RANGE $15B1-$15B4 DB_DATA 3
RANGE $15B4-$15B7 DB_DATA 3
RANGE $15B7-$15B8 DB_DATA 1
RANGE $15B8-$15BB DB_DATA 3
RANGE $15BB-$15BE DB_DATA 3
RANGE $15BE-$15C1 DB_DATA 3
RANGE $15C1-$15C4 DB_DATA 3
RANGE $15C4-$15C7 DB_DATA 3
RANGE $15C7-$15CA DB_DATA 3
RANGE $15CA-$15CD DB_DATA 3
RANGE $15CD-$15D0 DB_DATA 3
RANGE $15D0-$15D1 DB_DATA 1
RANGE $15D1-$15D4 DB_DATA 3
RANGE $15D4-$15D7 DB_DATA 3
RANGE $15D7-$15DA DB_DATA 3
RANGE $15DA-$15DD DB_DATA 3
RANGE $15DD-$15E0 DB_DATA 3
RANGE $15E0-$15E3 DB_DATA 3
RANGE $15E3-$15E6 DB_DATA 3
RANGE $15E6-$15E9 DB_DATA 3
RANGE $15E9-$15EA DB_DATA 1
RANGE $15EA-$15ED DB_DATA 3
RANGE $15ED-$15F0 DB_DATA 3
RANGE $15F0-$15F3 DB_DATA 3
RANGE $15F3-$15F6 DB_DATA 3
RANGE $15F6-$15F9 DB_DATA 3
RANGE $15F9-$15FA DB_DATA 1
RANGE $15FA-$15FD DB_DATA 3
RANGE $15FD-$1600 DB_DATA 3
RANGE $1600-$1603 DB_DATA 3
RANGE $1603-$1604 DB_DATA 1
RANGE $1604-$1607 DB_DATA 3
RANGE $1607-$160A DB_DATA 3
RANGE $160A-$160D DB_DATA 3
RANGE $160D-$1610 DB_DATA 3
RANGE $1610-$1613 DB_DATA 3
RANGE $1613-$1614 DB_DATA 1
RANGE $1614-$1617 DB_DATA 3
RANGE $1617-$161A DB_DATA 3
RANGE $161A-$161D DB_DATA 3
RANGE $161D-$161E DB_DATA 1
RANGE $161E-$1621 DB_DATA 3
RANGE $1621-$1624 DB_DATA 3
RANGE $1624-$1627 DB_DATA 3
RANGE $1627-$162A DB_DATA 3
RANGE $162A-$162D DB_DATA 3
RANGE $162D-$162E DB_DATA 1
RANGE $162E-$1631 DB_DATA 3
RANGE $1631-$1634 DB_DATA 3
RANGE $1634-$1635 DB_DATA 1
RANGE $1635-$1638 DB_DATA 3
RANGE $1638-$163B DB_DATA 3
RANGE $163B-$163E DB_DATA 3
RANGE $163E-$1641 DB_DATA 3
RANGE $1641-$1644 DB_DATA 3
RANGE $1644-$1647 DB_DATA 3
RANGE $1647-$164A DB_DATA 3
RANGE $164A-$164B DB_DATA 1
RANGE $164B-$164E DB_DATA 3
RANGE $164E-$1651 DB_DATA 3
RANGE $1651-$1654 DB_DATA 3
RANGE $1654-$1657 DB_DATA 3
RANGE $1657-$165A DB_DATA 3
RANGE $165A-$165D DB_DATA 3
RANGE $165D-$1660 DB_DATA 3
RANGE $1660-$1661 DB_DATA 1
RANGE $1661-$1664 DB_DATA 3
RANGE $1664-$1667 DB_DATA 3
RANGE $1667-$166A DB_DATA 3
RANGE $166A-$166D DB_DATA 3
RANGE $166D-$1670 DB_DATA 3
RANGE $1670-$1673 DB_DATA 3
RANGE $1673-$1676 DB_DATA 3
RANGE $1676-$1677 DB_DATA 1
RANGE $1677-$17A5 CODE
RANGE $17A5-$17B5 CHAR_DATA 16
RANGE $17B5-$17C5 CHAR_DATA 16
RANGE $17C5-$17D5 CHAR_DATA 16
RANGE $17D5-$17E5 CHAR_DATA 16
RANGE $17E5-$17F5 CHAR_DATA 16
RANGE $17F5-$1805 CHAR_DATA 16
RANGE $1805-$1815 CHAR_DATA 16
RANGE $1815-$1825 CHAR_DATA 16
RANGE $1825-$1835 CHAR_DATA 16
RANGE $1835-$1845 CHAR_DATA 16
RANGE $1845-$1855 CHAR_DATA 16
RANGE $1855-$1865 CHAR_DATA 16
RANGE $1865-$1875 CHAR_DATA 16
RANGE $1875-$1885 CHAR_DATA 16
RANGE $1885-$1895 CHAR_DATA 16
RANGE $1895-$18A5 CHAR_DATA 16
RANGE $18A5-$18A7 DB_DATA 2
RANGE $18A7-$18A8 DB_DATA 1
RANGE $18A8-$18AA DB_DATA 2
RANGE $18AA-$18AC DB_DATA 2
RANGE $18AC-$18AD DB_DATA 1
RANGE $18AD-$18AE DB_DATA 1
RANGE $18AE-$18B2 DB_DATA 4
RANGE $18B2-$18B4 DW_DATA 1
RANGE $18B4-$18B6 DB_DATA 2
RANGE $18B6-$18B8 DB_DATA 2
RANGE $18B8-$18B9 DB_DATA 1
RANGE $18B9-$18BA DB_DATA 1
RANGE $18BA-$18BE DB_DATA 4
RANGE $18BE-$18C0 DW_DATA 1
RANGE $18C0-$18C2 DB_DATA 2
RANGE $18C2-$18C3 DB_DATA 1
RANGE $18C3-$18C5 DW_DATA 1
RANGE $18C5-$18C6 DB_DATA 1
RANGE $18C6-$18C7 DB_DATA 1
RANGE $18C7-$18C9 DW_DATA 1
RANGE $18C9-$18CB DW_DATA 1
RANGE $18CB-$18CD DW_DATA 1
RANGE $18CD-$18CF DW_DATA 1
RANGE $18CF-$18D1 DW_DATA 1
RANGE $18D1-$18D4 DB_DATA 3
RANGE $18D4-$18D7 DB_DATA 3
RANGE $18D7-$18DA DB_DATA 3
RANGE $18DA-$18DD DB_DATA 3
RANGE $18DD-$18E0 DB_DATA 3
RANGE $18E0-$18E1 DB_DATA 1
RANGE $18E1-$18E4 DB_DATA 3
RANGE $18E4-$18E5 DB_DATA 1
RANGE $18E5-$18E8 DB_DATA 3
RANGE $18E8-$18EB DB_DATA 3
RANGE $18EB-$18EE DB_DATA 3
RANGE $18EE-$18F1 DB_DATA 3
RANGE $18F1-$18F4 DB_DATA 3
RANGE $18F4-$18F7 DB_DATA 3
RANGE $18F7-$18F8 DB_DATA 1
RANGE $18F8-$18FB DB_DATA 3
RANGE $18FB-$18FE DB_DATA 3
RANGE $18FE-$1901 DB_DATA 3
RANGE $1901-$1904 DB_DATA 3
RANGE $1904-$1907 DB_DATA 3
RANGE $1907-$190A DB_DATA 3
RANGE $190A-$190D DB_DATA 3
RANGE $190D-$190E DB_DATA 1
RANGE $190E-$1911 DB_DATA 3
RANGE $1911-$1914 DB_DATA 3
RANGE $1914-$1917 DB_DATA 3
RANGE $1917-$191A DB_DATA 3
RANGE $191A-$191D DB_DATA 3
RANGE $191D-$1920 DB_DATA 3
RANGE $1920-$1921 DB_DATA 1
RANGE $1921-$1924 DB_DATA 3
RANGE $1924-$1927 DB_DATA 3
RANGE $1927-$192A DB_DATA 3
RANGE $192A-$192D DB_DATA 3
RANGE $192D-$1930 DB_DATA 3
RANGE $1930-$1933 DB_DATA 3
RANGE $1933-$1936 DB_DATA 3
RANGE $1936-$1937 DB_DATA 1
RANGE $1937-$1939 DW_DATA 1
RANGE $1939-$193C DB_DATA 3
RANGE $193C-$193F DB_DATA 3
RANGE $193F-$1942 DB_DATA 3
RANGE $1942-$1945 DB_DATA 3
RANGE $1945-$1948 DB_DATA 3
RANGE $1948-$194B DB_DATA 3
RANGE $194B-$194E DB_DATA 3
RANGE $194E-$1951 DB_DATA 3
RANGE $1951-$1954 DB_DATA 3
RANGE $1954-$1957 DB_DATA 3
RANGE $1957-$195A DB_DATA 3
RANGE $195A-$195D DB_DATA 3
RANGE $195D-$1960 DB_DATA 3
RANGE $1960-$196A DB_DATA 10
RANGE $196A-$1974 DB_DATA 10
RANGE $1974-$197E DB_DATA 10
RANGE $197E-$1988 DB_DATA 10
RANGE $1988-$1992 DB_DATA 10
RANGE $1992-$199C DB_DATA 10
RANGE $199C-$19A0 DB_DATA 4
RANGE $19A0-$19A3 DB_DATA 3
RANGE $19A3-$19A6 DB_DATA 3
RANGE $19A6-$19A9 DB_DATA 3
RANGE $19A9-$19AC DB_DATA 3
RANGE $19AC-$19AF DB_DATA 3
RANGE $19AF-$19B9 DB_DATA 10
RANGE $19B9-$19C3 DB_DATA 10
RANGE $19C3-$19CD DB_DATA 10
RANGE $19CD-$19CF DB_DATA 2
RANGE $19CF-$19D2 DB_DATA 3
RANGE $19D2-$19D5 DB_DATA 3
RANGE $19D5-$19D8 DB_DATA 3
RANGE $19D8-$19DB DB_DATA 3
RANGE $19DB-$19DE DB_DATA 3
RANGE $19DE-$19E1 DB_DATA 3
RANGE $19E1-$19E4 DB_DATA 3
RANGE $19E4-$19E7 DB_DATA 3
RANGE $19E7-$19EA DB_DATA 3
RANGE $19EA-$19ED DB_DATA 3
RANGE $19ED-$19F0 DB_DATA 3
RANGE $19F0-$19F3 DB_DATA 3
RANGE $19F3-$19F6 DB_DATA 3
RANGE $19F6-$19F9 DB_DATA 3
RANGE $19F9-$19FC DB_DATA 3
RANGE $19FC-$19FF DB_DATA 3
RANGE $19FF-$1A02 DB_DATA 3
RANGE $1A02-$1A05 DB_DATA 3
RANGE $1A05-$1A08 DB_DATA 3
RANGE $1A08-$1A0B DB_DATA 3
RANGE $1A0B-$1A0E DB_DATA 3
RANGE $1A0E-$1A11 DB_DATA 3
RANGE $1A11-$1A14 DB_DATA 3
RANGE $1A14-$1A17 DB_DATA 3
RANGE $1A17-$1A21 DB_DATA 10
RANGE $1A21-$1A2B DB_DATA 10
RANGE $1A2B-$1A35 DB_DATA 10
RANGE $1A35-$1A3F DB_DATA 10
RANGE $1A3F-$1A49 DB_DATA 10
RANGE $1A49-$1A53 DB_DATA 10
RANGE $1A53-$1A5D DB_DATA 10
RANGE $1A5D-$1A67 DB_DATA 10
RANGE $1A67-$1A71 DB_DATA 10
RANGE $1A71-$1A7B DB_DATA 10
RANGE $1A7B-$1A85 DB_DATA 10
RANGE $1A85-$1A8F DB_DATA 10
RANGE $1A8F-$1A99 DB_DATA 10
RANGE $1A99-$1AA3 DB_DATA 10
RANGE $1AA3-$1AAD DB_DATA 10
RANGE $1AAD-$1AB7 DB_DATA 10
RANGE $1AB7-$1AC1 DB_DATA 10
RANGE $1AC1-$1ACB DB_DATA 10
RANGE $1ACB-$1AD5 DB_DATA 10
RANGE $1AD5-$1ADF DB_DATA 10
RANGE $1ADF-$1AE9 DB_DATA 10
RANGE $1AE9-$1AF3 DB_DATA 10
RANGE $1AF3-$1AFD DB_DATA 10
RANGE $1AFD-$1B07 DB_DATA 10
RANGE $1B07-$1B11 DB_DATA 10
RANGE $1B11-$1B1B DB_DATA 10
RANGE $1B1B-$1B25 DB_DATA 10
RANGE $1B25-$1B2F DB_DATA 10
RANGE $1B2F-$1B39 DB_DATA 10
RANGE $1B39-$1B43 DB_DATA 10
RANGE $1B43-$1B4D DB_DATA 10
RANGE $1B4D-$1B57 DB_DATA 10
RANGE $1B57-$1B61 DB_DATA 10
RANGE $1B61-$1B6B DB_DATA 10
RANGE $1B6B-$1B75 DB_DATA 10
RANGE $1B75-$1B7F DB_DATA 10
RANGE $1B7F-$1B89 DB_DATA 10
RANGE $1B89-$1B93 DB_DATA 10
RANGE $1B93-$1B9D DB_DATA 10
RANGE $1B9D-$1BA7 DB_DATA 10
RANGE $1BA7-$1BB1 DB_DATA 10
RANGE $1BB1-$1BBB DB_DATA 10
RANGE $1BBB-$1BC5 DB_DATA 10
RANGE $1BC5-$1BCF DB_DATA 10
RANGE $1BCF-$1BD9 DB_DATA 10
RANGE $1BD9-$1BE3 DB_DATA 10
RANGE $1BE3-$1BED DB_DATA 10
RANGE $1BED-$1BF7 DB_DATA 10
RANGE $1BF7-$1C01 DB_DATA 10
RANGE $1C01-$1C0B DB_DATA 10
RANGE $1C0B-$1C0C DB_DATA 1
RANGE $1C0C-$1C0F DB_DATA 3
RANGE $1C0F-$1C12 DB_DATA 3
RANGE $1C12-$1C15 DB_DATA 3
RANGE $1C15-$1C18 DB_DATA 3
RANGE $1C18-$1C1B DB_DATA 3
RANGE $1C1B-$1C1E DB_DATA 3
RANGE $1C1E-$1C21 DB_DATA 3
RANGE $1C21-$1C2B DB_DATA 10
RANGE $1C2B-$1C35 DB_DATA 10
RANGE $1C35-$1C3F DB_DATA 10
RANGE $1C3F-$1C49 DB_DATA 10
RANGE $1C49-$1C53 DB_DATA 10
RANGE $1C53-$1C5D DB_DATA 10
RANGE $1C5D-$1C67 DB_DATA 10
RANGE $1C67-$1C71 DB_DATA 10
RANGE $1C71-$1C7B DB_DATA 10
RANGE $1C7B-$1C85 DB_DATA 10
RANGE $1C85-$1C8F DB_DATA 10
RANGE $1C8F-$1C99 DB_DATA 10
RANGE $1C99-$1CA3 DB_DATA 10
RANGE $1CA3-$1CAD DB_DATA 10
RANGE $1CAD-$1CB7 DB_DATA 10
RANGE $1CB7-$1CC1 DB_DATA 10
RANGE $1CC1-$1CCB DB_DATA 10
RANGE $1CCB-$1CD5 DB_DATA 10
RANGE $1CD5-$1CDF DB_DATA 10
RANGE $1CDF-$1CE9 DB_DATA 10
RANGE $1CE9-$1CF3 DB_DATA 10
RANGE $1CF3-$1CFD DB_DATA 10
RANGE $1CFD-$1D07 DB_DATA 10
RANGE $1D07-$1D11 DB_DATA 10
RANGE $1D11-$1D1B DB_DATA 10
RANGE $1D1B-$1D25 DB_DATA 10
RANGE $1D25-$1D2F DB_DATA 10
RANGE $1D2F-$1D39 DB_DATA 10
RANGE $1D39-$1D43 DB_DATA 10
RANGE $1D43-$1D4D DB_DATA 10
RANGE $1D4D-$1D57 DB_DATA 10
RANGE $1D57-$1D61 DB_DATA 10
RANGE $1D61-$1D69 DB_DATA 8
RANGE $1D69-$1D6C DB_DATA 3
RANGE $1D6C-$1D6F DB_DATA 3
RANGE $1D6F-$1D72 DB_DATA 3
RANGE $1D72-$1D75 DB_DATA 3
RANGE $1D75-$1D78 DB_DATA 3
RANGE $1D78-$1D7B DB_DATA 3
RANGE $1D7B-$1D7E DB_DATA 3
RANGE $1D7E-$1D81 DB_DATA 3
RANGE $1D81-$1D84 DB_DATA 3
RANGE $1D84-$1D87 DB_DATA 3
RANGE $1D87-$1D8A DB_DATA 3
RANGE $1D8A-$1D8D DB_DATA 3
RANGE $1D8D-$1D97 DB_DATA 10
RANGE $1D97-$1DA1 DB_DATA 10
RANGE $1DA1-$1DAB DB_DATA 10
RANGE $1DAB-$1DB5 DB_DATA 10
RANGE $1DB5-$1DBF DB_DATA 10
RANGE $1DBF-$1DC9 DB_DATA 10
RANGE $1DC9-$1DD3 DB_DATA 10
RANGE $1DD3-$1DD8 DB_DATA 5
RANGE $1DD8-$1DDB DB_DATA 3
RANGE $1DDB-$1DDE DB_DATA 3
RANGE $1DDE-$1DE1 DB_DATA 3
RANGE $1DE1-$1DE4 DB_DATA 3
RANGE $1DE4-$1DE7 DB_DATA 3
RANGE $1DE7-$1DEA DB_DATA 3
RANGE $1DEA-$1DED DB_DATA 3
RANGE $1DED-$1DF7 DB_DATA 10
RANGE $1DF7-$1E01 DB_DATA 10
RANGE $1E01-$1E0B DB_DATA 10
RANGE $1E0B-$1E15 DB_DATA 10
RANGE $1E15-$1E1F DB_DATA 10
RANGE $1E1F-$1E26 DB_DATA 7
RANGE $1E26-$1E29 DB_DATA 3
RANGE $1E29-$1E2D DB_DATA 4
RANGE $1E2D-$1E30 DB_DATA 3
RANGE $1E30-$1E33 DB_DATA 3
RANGE $1E33-$1E36 DB_DATA 3
RANGE $1E36-$1E39 DB_DATA 3
RANGE $1E39-$1E3C DB_DATA 3
RANGE $1E3C-$1E46 DB_DATA 10
RANGE $1E46-$1E50 DB_DATA 10
RANGE $1E50-$1E54 DB_DATA 4
RANGE $1E54-$1E57 DB_DATA 3
RANGE $1E57-$1E5A DB_DATA 3
RANGE $1E5A-$1E5D DB_DATA 3
RANGE $1E5D-$1E60 DB_DATA 3
RANGE $1E60-$1E63 DB_DATA 3
RANGE $1E63-$1E66 DB_DATA 3
RANGE $1E66-$1E69 DB_DATA 3
RANGE $1E69-$1E6C DB_DATA 3
RANGE $1E6C-$1E6F DB_DATA 3
RANGE $1E6F-$1E72 DB_DATA 3
RANGE $1E72-$1E75 DB_DATA 3
RANGE $1E75-$1E78 DB_DATA 3
RANGE $1E78-$1E7B DB_DATA 3
RANGE $1E7B-$1E7E DB_DATA 3
RANGE $1E7E-$1E81 DB_DATA 3
RANGE $1E81-$1E84 DB_DATA 3
RANGE $1E84-$1E87 DB_DATA 3
RANGE $1E87-$1E8A DB_DATA 3
RANGE $1E8A-$1E93 DB_DATA 9
RANGE $1E93-$1E9C DB_DATA 9
RANGE $1E9C-$1EA6 DB_DATA 10
RANGE $1EA6-$1EB0 DB_DATA 10
RANGE $1EB0-$1EBA DB_DATA 10
RANGE $1EBA-$1EC4 DB_DATA 10
RANGE $1EC4-$1ECE DB_DATA 10
RANGE $1ECE-$1ED8 DB_DATA 10
RANGE $1ED8-$1EE2 DB_DATA 10
RANGE $1EE2-$1EEC DB_DATA 10
RANGE $1EEC-$1EF6 DB_DATA 10
RANGE $1EF6-$1F00 DB_DATA 10
RANGE $1F00-$1F0A DB_DATA 10
RANGE $1F0A-$1F14 DB_DATA 10
RANGE $1F14-$1F1E DB_DATA 10
RANGE $1F1E-$1F28 DB_DATA 10
RANGE $1F28-$1F32 DB_DATA 10
RANGE $1F32-$1F3C DB_DATA 10
RANGE $1F3C-$1F46 DB_DATA 10
RANGE $1F46-$1F50 DB_DATA 10
RANGE $1F50-$1F5A DB_DATA 10
RANGE $1F5A-$1F64 DB_DATA 10
RANGE $1F64-$1F6E DB_DATA 10
RANGE $1F6E-$1F78 DB_DATA 10
RANGE $1F78-$1F7D DB_DATA 5
RANGE $1F7D-$1F80 DB_DATA 3
RANGE $1F80-$1F83 DB_DATA 3
RANGE $1F83-$1F86 DB_DATA 3
RANGE $1F86-$1F89 DB_DATA 3
RANGE $1F89-$1F8C DB_DATA 3
RANGE $1F8C-$1F8F DB_DATA 3
RANGE $1F8F-$1F92 DB_DATA 3
RANGE $1F92-$1F95 DB_DATA 3
RANGE $1F95-$1F98 DB_DATA 3
RANGE $1F98-$1F9B DB_DATA 3
RANGE $1F9B-$1F9E DB_DATA 3
RANGE $1F9E-$1FA1 DB_DATA 3
RANGE $1FA1-$1FA4 DB_DATA 3
RANGE $1FA4-$1FA7 DB_DATA 3
RANGE $1FA7-$1FAA DB_DATA 3
RANGE $1FAA-$1FAD DB_DATA 3
RANGE $1FAD-$1FB0 DB_DATA 3
RANGE $1FB0-$1FC0 DB_DATA 16
RANGE $1FC0-$1FCA DB_DATA 10
RANGE $1FCA-$1FD4 DB_DATA 10
RANGE $1FD4-$1FDE DB_DATA 10
RANGE $1FDE-$1FE8 DB_DATA 10
RANGE $1FE8-$1FF2 DB_DATA 10
RANGE $1FF2-$1FFC DB_DATA 10
RANGE $1FFC-$2006 DB_DATA 10
RANGE $2006-$2010 DB_DATA 10
RANGE $2010-$201A DB_DATA 10
RANGE $201A-$2024 DB_DATA 10
RANGE $2024-$202E DB_DATA 10
RANGE $202E-$2038 DB_DATA 10
RANGE $2038-$2042 DB_DATA 10
RANGE $2042-$204C DB_DATA 10
RANGE $204C-$2056 DB_DATA 10
RANGE $2056-$2060 DB_DATA 10
RANGE $2060-$206A DB_DATA 10
RANGE $206A-$2074 DB_DATA 10
RANGE $2074-$207E DB_DATA 10
RANGE $207E-$2088 DB_DATA 10
RANGE $2088-$2092 DB_DATA 10
RANGE $2092-$209C DB_DATA 10
RANGE $209C-$20A1 DB_DATA 5
RANGE $20A1-$20A4 DB_DATA 3
RANGE $20A4-$20A7 DB_DATA 3
RANGE $20A7-$20AA DB_DATA 3
RANGE $20AA-$20AD DB_DATA 3
RANGE $20AD-$20B0 DB_DATA 3
RANGE $20B0-$20B3 DB_DATA 3
RANGE $20B3-$20B6 DB_DATA 3
RANGE $20B6-$20B9 DB_DATA 3
RANGE $20B9-$20BC DB_DATA 3
RANGE $20BC-$20BF DB_DATA 3
RANGE $20BF-$20C2 DB_DATA 3
RANGE $20C2-$20C5 DB_DATA 3
RANGE $20C5-$20C8 DB_DATA 3
RANGE $20C8-$20CB DB_DATA 3
RANGE $20CB-$20CE DB_DATA 3
RANGE $20CE-$20D1 DB_DATA 3
RANGE $20D1-$20D4 DB_DATA 3
RANGE $20D4-$20E1 DB_DATA 13
RANGE $20E1-$20EB DB_DATA 10
RANGE $20EB-$20F5 DB_DATA 10
RANGE $20F5-$20FF DB_DATA 10
RANGE $20FF-$2109 DB_DATA 10
RANGE $2109-$2113 DB_DATA 10
RANGE $2113-$211D DB_DATA 10
RANGE $211D-$2127 DB_DATA 10
RANGE $2127-$2131 DB_DATA 10
RANGE $2131-$213B DB_DATA 10
RANGE $213B-$2145 DB_DATA 10
RANGE $2145-$214F DB_DATA 10
RANGE $214F-$2159 DB_DATA 10
RANGE $2159-$2163 DB_DATA 10
RANGE $2163-$216D DB_DATA 10
RANGE $216D-$2177 DB_DATA 10
RANGE $2177-$2181 DB_DATA 10
RANGE $2181-$2189 DB_DATA 8
RANGE $2189-$218B DW_DATA 1
RANGE $218B-$2191 DW_DATA 3
RANGE $2191-$2197 DW_DATA 3
RANGE $2197-$219D DW_DATA 3
RANGE $219D-$21A3 DW_DATA 3
RANGE $21A3-$21A9 DW_DATA 3
RANGE $21A9-$21AF DW_DATA 3
RANGE $21AF-$21B5 DW_DATA 3
RANGE $21B5-$21BB DW_DATA 3
RANGE $21BB-$21C1 DW_DATA 3
RANGE $21C1-$21C7 DW_DATA 3
RANGE $21C7-$21CD DW_DATA 3
RANGE $21CD-$21E5 DB_DATA 24
RANGE $21E5-$21F0 DB_DATA 11
RANGE $21F0-$21FB DB_DATA 11
RANGE $21FB-$2206 DB_DATA 11
RANGE $2206-$2211 DB_DATA 11
RANGE $2211-$221C DB_DATA 11
RANGE $221C-$2227 DB_DATA 11
RANGE $2227-$2232 DB_DATA 11
RANGE $2232-$223D DB_DATA 11
RANGE $223D-$2248 DB_DATA 11
RANGE $2248-$2253 DB_DATA 11
RANGE $2253-$225E DB_DATA 11
RANGE $225E-$2269 DB_DATA 11
RANGE $2269-$2274 DB_DATA 11
RANGE $2274-$227F DB_DATA 11
RANGE $227F-$228A DB_DATA 11
RANGE $228A-$2295 DB_DATA 11
RANGE $2295-$22A0 DB_DATA 11
RANGE $22A0-$22AB DB_DATA 11
RANGE $22AB-$22B6 DB_DATA 11
RANGE $22B6-$22C1 DB_DATA 11
RANGE $22C1-$22CC DB_DATA 11
RANGE $22CC-$22D7 DB_DATA 11
RANGE $22D7-$22E2 DB_DATA 11
RANGE $22E2-$22ED DB_DATA 11
RANGE $22ED-$22F8 DB_DATA 11
RANGE $22F8-$2303 DB_DATA 11
RANGE $2303-$230E DB_DATA 11
RANGE $230E-$2319 DB_DATA 11
RANGE $2319-$2324 DB_DATA 11
RANGE $2324-$232F DB_DATA 11
RANGE $232F-$233A DB_DATA 11
RANGE $233A-$2345 DB_DATA 11
RANGE $2345-$2350 DB_DATA 11
RANGE $2350-$235B DB_DATA 11
RANGE $235B-$2366 DB_DATA 11
RANGE $2366-$2371 DB_DATA 11
RANGE $2371-$237C DB_DATA 11
RANGE $237C-$2387 DB_DATA 11
RANGE $2387-$2392 DB_DATA 11
RANGE $2392-$239D DB_DATA 11
RANGE $239D-$23A8 DB_DATA 11
RANGE $23A8-$23B3 DB_DATA 11
RANGE $23B3-$23BE DB_DATA 11
RANGE $23BE-$23C9 DB_DATA 11
RANGE $23C9-$23D4 DB_DATA 11
RANGE $23D4-$23DF DB_DATA 11
RANGE $23DF-$23EA DB_DATA 11
RANGE $23EA-$23F5 DB_DATA 11
RANGE $23F5-$2400 DB_DATA 11
RANGE $2400-$240B DB_DATA 11
RANGE $240B-$2416 DB_DATA 11
RANGE $2416-$2421 DB_DATA 11
RANGE $2421-$242C DB_DATA 11
RANGE $242C-$2437 DB_DATA 11
RANGE $2437-$2442 DB_DATA 11
RANGE $2442-$244D DB_DATA 11
RANGE $244D-$2458 DB_DATA 11
RANGE $2458-$2463 DB_DATA 11
RANGE $2463-$246E DB_DATA 11
RANGE $246E-$2479 DB_DATA 11
RANGE $2479-$2484 DB_DATA 11
RANGE $2484-$248F DB_DATA 11
RANGE $248F-$249A DB_DATA 11
RANGE $249A-$24A5 DB_DATA 11
RANGE $24A5-$24B0 DB_DATA 11
RANGE $24B0-$24BB DB_DATA 11
RANGE $24BB-$24C6 DB_DATA 11
RANGE $24C6-$24D1 DB_DATA 11
RANGE $24D1-$24DC DB_DATA 11
RANGE $24DC-$24E7 DB_DATA 11
RANGE $24E7-$24F2 DB_DATA 11
RANGE $24F2-$24FD DB_DATA 11
RANGE $24FD-$2508 DB_DATA 11
RANGE $2508-$2513 DB_DATA 11
RANGE $2513-$251E DB_DATA 11
RANGE $251E-$2529 DB_DATA 11
RANGE $2529-$2534 DB_DATA 11
RANGE $2534-$253F DB_DATA 11
RANGE $253F-$2546 DB_DATA 7
RANGE $2546-$2551 DB_DATA 11
RANGE $2551-$255C DB_DATA 11
RANGE $255C-$2567 DB_DATA 11
RANGE $2567-$2572 DB_DATA 11
RANGE $2572-$257D DB_DATA 11
RANGE $257D-$2588 DB_DATA 11
RANGE $2588-$2593 DB_DATA 11
RANGE $2593-$259E DB_DATA 11
RANGE $259E-$25A9 DB_DATA 11
RANGE $25A9-$25B4 DB_DATA 11
RANGE $25B4-$25BF DB_DATA 11
RANGE $25BF-$25CA DB_DATA 11
RANGE $25CA-$25D5 DB_DATA 11
RANGE $25D5-$25E0 DB_DATA 11
RANGE $25E0-$25EB DB_DATA 11
RANGE $25EB-$25F6 DB_DATA 11
RANGE $25F6-$2601 DB_DATA 11
RANGE $2601-$260C DB_DATA 11
RANGE $260C-$2617 DB_DATA 11
RANGE $2617-$2622 DB_DATA 11
RANGE $2622-$262D DB_DATA 11
RANGE $262D-$2638 DB_DATA 11
RANGE $2638-$2643 DB_DATA 11
RANGE $2643-$264E DB_DATA 11
RANGE $264E-$2659 DB_DATA 11
RANGE $2659-$2664 DB_DATA 11
RANGE $2664-$266F DB_DATA 11
RANGE $266F-$267A DB_DATA 11
RANGE $267A-$2685 DB_DATA 11
RANGE $2685-$2690 DB_DATA 11
RANGE $2690-$269B DB_DATA 11
RANGE $269B-$26A6 DB_DATA 11
RANGE $26A6-$26B1 DB_DATA 11
RANGE $26B1-$26BC DB_DATA 11
RANGE $26BC-$26C7 DB_DATA 11
RANGE $26C7-$26D2 DB_DATA 11
RANGE $26D2-$26DD DB_DATA 11
RANGE $26DD-$26E8 DB_DATA 11
RANGE $26E8-$26F3 DB_DATA 11
RANGE $26F3-$26FE DB_DATA 11
RANGE $26FE-$2709 DB_DATA 11
RANGE $2709-$2714 DB_DATA 11
RANGE $2714-$271F DB_DATA 11
RANGE $271F-$272A DB_DATA 11
RANGE $272A-$2735 DB_DATA 11
RANGE $2735-$2740 DB_DATA 11
RANGE $2740-$274B DB_DATA 11
RANGE $274B-$2756 DB_DATA 11
RANGE $2756-$2761 DB_DATA 11
RANGE $2761-$276C DB_DATA 11
RANGE $276C-$2777 DB_DATA 11
RANGE $2777-$2782 DB_DATA 11
RANGE $2782-$278D DB_DATA 11
RANGE $278D-$2798 DB_DATA 11
RANGE $2798-$27A3 DB_DATA 11
RANGE $27A3-$27AE DB_DATA 11
RANGE $27AE-$27B9 DB_DATA 11
RANGE $27B9-$27C4 DB_DATA 11
RANGE $27C4-$27CF DB_DATA 11
RANGE $27CF-$27DA DB_DATA 11
RANGE $27DA-$27E5 DB_DATA 11
RANGE $27E5-$27F0 DB_DATA 11
RANGE $27F0-$27FB DB_DATA 11
RANGE $27FB-$2806 DB_DATA 11
RANGE $2806-$2811 DB_DATA 11
RANGE $2811-$281C DB_DATA 11
RANGE $281C-$2827 DB_DATA 11
RANGE $2827-$2832 DB_DATA 11
RANGE $2832-$283D DB_DATA 11
RANGE $283D-$2848 DB_DATA 11
RANGE $2848-$2853 DB_DATA 11
RANGE $2853-$285E DB_DATA 11
RANGE $285E-$2869 DB_DATA 11
RANGE $2869-$2874 DB_DATA 11
RANGE $2874-$287F DB_DATA 11
RANGE $287F-$288A DB_DATA 11
RANGE $288A-$2895 DB_DATA 11
RANGE $2895-$28A0 DB_DATA 11
RANGE $28A0-$28AB DB_DATA 11
RANGE $28AB-$28B6 DB_DATA 11
RANGE $28B6-$28C1 DB_DATA 11
RANGE $28C1-$28CC DB_DATA 11
RANGE $28CC-$28D7 DB_DATA 11
RANGE $28D7-$28E2 DB_DATA 11
RANGE $28E2-$28ED DB_DATA 11
RANGE $28ED-$28F8 DB_DATA 11
RANGE $28F8-$2903 DB_DATA 11
RANGE $2903-$290E DB_DATA 11
RANGE $290E-$2919 DB_DATA 11
RANGE $2919-$2924 DB_DATA 11
RANGE $2924-$292F DB_DATA 11
RANGE $292F-$293A DB_DATA 11
RANGE $293A-$2945 DB_DATA 11
RANGE $2945-$2950 DB_DATA 11
RANGE $2950-$295B DB_DATA 11
RANGE $295B-$2966 DB_DATA 11
RANGE $2966-$2971 DB_DATA 11
RANGE $2971-$297C DB_DATA 11
RANGE $297C-$2987 DB_DATA 11
RANGE $2987-$2992 DB_DATA 11
RANGE $2992-$299D DB_DATA 11
RANGE $299D-$29A8 DB_DATA 11
RANGE $29A8-$29B3 DB_DATA 11
RANGE $29B3-$29BE DB_DATA 11
RANGE $29BE-$29C9 DB_DATA 11
RANGE $29C9-$29D4 DB_DATA 11
RANGE $29D4-$29DF DB_DATA 11
RANGE $29DF-$29EA DB_DATA 11
RANGE $29EA-$29F5 DB_DATA 11
RANGE $29F5-$29FB DB_DATA 6
RANGE $29FB-$2A06 DB_DATA 11
RANGE $2A06-$2A11 DB_DATA 11
RANGE $2A11-$2A1C DB_DATA 11
RANGE $2A1C-$2A27 DB_DATA 11
RANGE $2A27-$2A32 DB_DATA 11
RANGE $2A32-$2A3D DB_DATA 11
RANGE $2A3D-$2A48 DB_DATA 11
RANGE $2A48-$2A53 DB_DATA 11
RANGE $2A53-$2A5E DB_DATA 11
RANGE $2A5E-$2A69 DB_DATA 11
RANGE $2A69-$2A74 DB_DATA 11
RANGE $2A74-$2A7F DB_DATA 11
RANGE $2A7F-$2A8A DB_DATA 11
RANGE $2A8A-$2A95 DB_DATA 11
RANGE $2A95-$2AA0 DB_DATA 11
RANGE $2AA0-$2AAB DB_DATA 11
RANGE $2AAB-$2AB6 DB_DATA 11
RANGE $2AB6-$2AC1 DB_DATA 11
RANGE $2AC1-$2ACC DB_DATA 11
RANGE $2ACC-$2AD7 DB_DATA 11
RANGE $2AD7-$2AE2 DB_DATA 11
RANGE $2AE2-$2AED DB_DATA 11
RANGE $2AED-$2AF8 DB_DATA 11
RANGE $2AF8-$2B03 DB_DATA 11
RANGE $2B03-$2B0E DB_DATA 11
RANGE $2B0E-$2B19 DB_DATA 11
RANGE $2B19-$2B24 DB_DATA 11
RANGE $2B24-$2B2F DB_DATA 11
RANGE $2B2F-$2B3A DB_DATA 11
RANGE $2B3A-$2B45 DB_DATA 11
RANGE $2B45-$2B50 DB_DATA 11
RANGE $2B50-$2B5B DB_DATA 11
RANGE $2B5B-$2B66 DB_DATA 11
RANGE $2B66-$2B71 DB_DATA 11
RANGE $2B71-$2B7C DB_DATA 11
RANGE $2B7C-$2B87 DB_DATA 11
RANGE $2B87-$2B92 DB_DATA 11
RANGE $2B92-$2B9D DB_DATA 11
RANGE $2B9D-$2BA8 DB_DATA 11
RANGE $2BA8-$2BB3 DB_DATA 11
RANGE $2BB3-$2BBE DB_DATA 11
RANGE $2BBE-$2BC9 DB_DATA 11
RANGE $2BC9-$2BD4 DB_DATA 11
RANGE $2BD4-$2BDF DB_DATA 11
RANGE $2BDF-$2BEA DB_DATA 11
RANGE $2BEA-$2BF5 DB_DATA 11
RANGE $2BF5-$2C00 DB_DATA 11
RANGE $2C00-$2C0B DB_DATA 11
RANGE $2C0B-$2C16 DB_DATA 11
RANGE $2C16-$2C21 DB_DATA 11
RANGE $2C21-$2C2C DB_DATA 11
RANGE $2C2C-$2C37 DB_DATA 11
RANGE $2C37-$2C42 DB_DATA 11
RANGE $2C42-$2C4D DB_DATA 11
RANGE $2C4D-$2C58 DB_DATA 11
RANGE $2C58-$2C63 DB_DATA 11
RANGE $2C63-$2C6E DB_DATA 11
RANGE $2C6E-$2C79 DB_DATA 11
RANGE $2C79-$2C84 DB_DATA 11
RANGE $2C84-$2C8F DB_DATA 11
RANGE $2C8F-$2C9A DB_DATA 11
RANGE $2C9A-$2CA5 DB_DATA 11
RANGE $2CA5-$2CB0 DB_DATA 11
RANGE $2CB0-$2CBB DB_DATA 11
RANGE $2CBB-$2CC6 DB_DATA 11
RANGE $2CC6-$2CD1 DB_DATA 11
RANGE $2CD1-$2CDC DB_DATA 11
RANGE $2CDC-$2CE7 DB_DATA 11
RANGE $2CE7-$2CF2 DB_DATA 11
RANGE $2CF2-$2CFD DB_DATA 11
RANGE $2CFD-$2D08 DB_DATA 11
RANGE $2D08-$2D13 DB_DATA 11
RANGE $2D13-$2D1E DB_DATA 11
RANGE $2D1E-$2D29 DB_DATA 11
RANGE $2D29-$2D34 DB_DATA 11
RANGE $2D34-$2D3F DB_DATA 11
RANGE $2D3F-$2D4A DB_DATA 11
RANGE $2D4A-$2D55 DB_DATA 11
RANGE $2D55-$2D60 DB_DATA 11
RANGE $2D60-$2D6B DB_DATA 11
RANGE $2D6B-$2D76 DB_DATA 11
RANGE $2D76-$2D81 DB_DATA 11
RANGE $2D81-$2D8B DB_DATA 10
RANGE $2D8B-$2D96 DB_DATA 11
RANGE $2D96-$2DA1 DB_DATA 11
RANGE $2DA1-$2DAC DB_DATA 11
RANGE $2DAC-$2DB7 DB_DATA 11
RANGE $2DB7-$2DC2 DB_DATA 11
RANGE $2DC2-$2DCD DB_DATA 11
RANGE $2DCD-$2DD8 DB_DATA 11
RANGE $2DD8-$2DE3 DB_DATA 11
RANGE $2DE3-$2DEE DB_DATA 11
RANGE $2DEE-$2DF9 DB_DATA 11
RANGE $2DF9-$2E04 DB_DATA 11
RANGE $2E04-$2E0F DB_DATA 11
RANGE $2E0F-$2E1A DB_DATA 11
RANGE $2E1A-$2E25 DB_DATA 11
RANGE $2E25-$2E30 DB_DATA 11
RANGE $2E30-$2E3B DB_DATA 11
RANGE $2E3B-$2E46 DB_DATA 11
RANGE $2E46-$2E51 DB_DATA 11
RANGE $2E51-$2E5C DB_DATA 11
RANGE $2E5C-$2E67 DB_DATA 11
RANGE $2E67-$2E72 DB_DATA 11
RANGE $2E72-$2E7D DB_DATA 11
RANGE $2E7D-$2E88 DB_DATA 11
RANGE $2E88-$2E93 DB_DATA 11
RANGE $2E93-$2E9E DB_DATA 11
RANGE $2E9E-$2EA9 DB_DATA 11
RANGE $2EA9-$2EB4 DB_DATA 11
RANGE $2EB4-$2EBF DB_DATA 11
RANGE $2EBF-$2ECA DB_DATA 11
RANGE $2ECA-$2ED5 DB_DATA 11
RANGE $2ED5-$2EE0 DB_DATA 11
RANGE $2EE0-$2EEB DB_DATA 11
RANGE $2EEB-$2EF6 DB_DATA 11
RANGE $2EF6-$2F01 DB_DATA 11
RANGE $2F01-$2F0C DB_DATA 11
RANGE $2F0C-$2F17 DB_DATA 11
RANGE $2F17-$2F22 DB_DATA 11
RANGE $2F22-$2F2D DB_DATA 11
RANGE $2F2D-$2F38 DB_DATA 11
RANGE $2F38-$2F43 DB_DATA 11
RANGE $2F43-$2F4E DB_DATA 11
RANGE $2F4E-$2F59 DB_DATA 11
RANGE $2F59-$2F64 DB_DATA 11
RANGE $2F64-$2F6F DB_DATA 11
RANGE $2F6F-$2F7A DB_DATA 11
RANGE $2F7A-$2F85 DB_DATA 11
RANGE $2F85-$2F90 DB_DATA 11
RANGE $2F90-$2F9B DB_DATA 11
RANGE $2F9B-$2FA6 DB_DATA 11
RANGE $2FA6-$2FB1 DB_DATA 11
RANGE $2FB1-$2FBC DB_DATA 11
RANGE $2FBC-$2FC7 DB_DATA 11
RANGE $2FC7-$2FD2 DB_DATA 11
RANGE $2FD2-$2FDD DB_DATA 11
RANGE $2FDD-$2FE8 DB_DATA 11
RANGE $2FE8-$2FF3 DB_DATA 11
RANGE $2FF3-$2FFE DB_DATA 11
RANGE $2FFE-$3009 DB_DATA 11
RANGE $3009-$3014 DB_DATA 11
RANGE $3014-$301F DB_DATA 11
RANGE $301F-$302A DB_DATA 11
RANGE $302A-$3035 DB_DATA 11
RANGE $3035-$3040 DB_DATA 11
RANGE $3040-$304B DB_DATA 11
RANGE $304B-$3056 DB_DATA 11
RANGE $3056-$3061 DB_DATA 11
RANGE $3061-$306C DB_DATA 11
RANGE $306C-$3077 DB_DATA 11
RANGE $3077-$3082 DB_DATA 11
RANGE $3082-$308D DB_DATA 11
RANGE $308D-$3098 DB_DATA 11
RANGE $3098-$30A3 DB_DATA 11
RANGE $30A3-$30AE DB_DATA 11
RANGE $30AE-$30B9 DB_DATA 11
RANGE $30B9-$30C4 DB_DATA 11
RANGE $30C4-$30CF DB_DATA 11
RANGE $30CF-$30DA DB_DATA 11
RANGE $30DA-$30E5 DB_DATA 11
RANGE $30E5-$30F0 DB_DATA 11
RANGE $30F0-$30FB DB_DATA 11
RANGE $30FB-$3106 DB_DATA 11
RANGE $3106-$3111 DB_DATA 11
RANGE $3111-$311C DB_DATA 11
RANGE $311C-$3127 DB_DATA 11
RANGE $3127-$3132 DB_DATA 11
RANGE $3132-$313D DB_DATA 11
RANGE $313D-$3148 DB_DATA 11
RANGE $3148-$3153 DB_DATA 11
RANGE $3153-$315E DB_DATA 11
RANGE $315E-$3169 DB_DATA 11
RANGE $3169-$3174 DB_DATA 11
RANGE $3174-$317F DB_DATA 11
RANGE $317F-$318A DB_DATA 11
RANGE $318A-$3195 DB_DATA 11
RANGE $3195-$31A0 DB_DATA 11
RANGE $31A0-$31AB DB_DATA 11
RANGE $31AB-$31B6 DB_DATA 11
RANGE $31B6-$31BD DB_DATA 7
RANGE $31BD-$31C8 DB_DATA 11
RANGE $31C8-$31D3 DB_DATA 11
RANGE $31D3-$31DE DB_DATA 11
RANGE $31DE-$31E9 DB_DATA 11
RANGE $31E9-$31F4 DB_DATA 11
RANGE $31F4-$31FF DB_DATA 11
RANGE $31FF-$320A DB_DATA 11
RANGE $320A-$3215 DB_DATA 11
RANGE $3215-$3220 DB_DATA 11
RANGE $3220-$322B DB_DATA 11
RANGE $322B-$3236 DB_DATA 11
RANGE $3236-$3241 DB_DATA 11
RANGE $3241-$324C DB_DATA 11
RANGE $324C-$3257 DB_DATA 11
RANGE $3257-$3262 DB_DATA 11
RANGE $3262-$326D DB_DATA 11
RANGE $326D-$3278 DB_DATA 11
RANGE $3278-$3283 DB_DATA 11
RANGE $3283-$328E DB_DATA 11
RANGE $328E-$3299 DB_DATA 11
RANGE $3299-$32A4 DB_DATA 11
RANGE $32A4-$32AF DB_DATA 11
RANGE $32AF-$32BA DB_DATA 11
RANGE $32BA-$32C5 DB_DATA 11
RANGE $32C5-$32D0 DB_DATA 11
RANGE $32D0-$32DB DB_DATA 11
RANGE $32DB-$32E6 DB_DATA 11
RANGE $32E6-$32F1 DB_DATA 11
RANGE $32F1-$32FC DB_DATA 11
RANGE $32FC-$3307 DB_DATA 11
RANGE $3307-$3312 DB_DATA 11
RANGE $3312-$331D DB_DATA 11
RANGE $331D-$3328 DB_DATA 11
RANGE $3328-$3333 DB_DATA 11
RANGE $3333-$333E DB_DATA 11
RANGE $333E-$3349 DB_DATA 11
RANGE $3349-$3354 DB_DATA 11
RANGE $3354-$335F DB_DATA 11
RANGE $335F-$336A DB_DATA 11
RANGE $336A-$3375 DB_DATA 11
RANGE $3375-$3380 DB_DATA 11
RANGE $3380-$338B DB_DATA 11
RANGE $338B-$3396 DB_DATA 11
RANGE $3396-$33A1 DB_DATA 11
RANGE $33A1-$33AC DB_DATA 11
RANGE $33AC-$33B7 DB_DATA 11
RANGE $33B7-$33C2 DB_DATA 11
RANGE $33C2-$33CD DB_DATA 11
RANGE $33CD-$33D8 DB_DATA 11
RANGE $33D8-$33E3 DB_DATA 11
RANGE $33E3-$33EE DB_DATA 11
RANGE $33EE-$33F9 DB_DATA 11
RANGE $33F9-$3404 DB_DATA 11
RANGE $3404-$340F DB_DATA 11
RANGE $340F-$341A DB_DATA 11
RANGE $341A-$3425 DB_DATA 11
RANGE $3425-$3430 DB_DATA 11
RANGE $3430-$343B DB_DATA 11
RANGE $343B-$3446 DB_DATA 11
RANGE $3446-$3451 DB_DATA 11
RANGE $3451-$345C DB_DATA 11
RANGE $345C-$3467 DB_DATA 11
RANGE $3467-$3472 DB_DATA 11
RANGE $3472-$347D DB_DATA 11
RANGE $347D-$3488 DB_DATA 11
RANGE $3488-$3493 DB_DATA 11
RANGE $3493-$349E DB_DATA 11
RANGE $349E-$34A9 DB_DATA 11
RANGE $34A9-$34B4 DB_DATA 11
RANGE $34B4-$34BF DB_DATA 11
RANGE $34BF-$34CA DB_DATA 11
RANGE $34CA-$34D5 DB_DATA 11
RANGE $34D5-$34E0 DB_DATA 11
RANGE $34E0-$34EB DB_DATA 11
RANGE $34EB-$34F6 DB_DATA 11
RANGE $34F6-$3501 DB_DATA 11
RANGE $3501-$350C DB_DATA 11
RANGE $350C-$3517 DB_DATA 11
RANGE $3517-$3522 DB_DATA 11
RANGE $3522-$352D DB_DATA 11
RANGE $352D-$3536 DB_DATA 9
RANGE $3536-$3537 DB_DATA 1
RANGE $3537-$3539 DW_DATA 1
RANGE $3539-$353B DW_DATA 1
RANGE $353B-$353D DW_DATA 1
RANGE $353D-$353F DW_DATA 1
RANGE $353F-$3541 DW_DATA 1
RANGE $3541-$3542 DB_DATA 1
RANGE $3542-$3544 DW_DATA 1
RANGE $3544-$3546 DW_DATA 1
RANGE $3546-$3548 DW_DATA 1
RANGE $3548-$354A DW_DATA 1
RANGE $354A-$354C DW_DATA 1
RANGE $354C-$354D DB_DATA 1
RANGE $354D-$354F DW_DATA 1
RANGE $354F-$3551 DW_DATA 1
RANGE $3551-$3553 DW_DATA 1
RANGE $3553-$3555 DW_DATA 1
RANGE $3555-$3557 DW_DATA 1
RANGE $3557-$3558 DB_DATA 1
RANGE $3558-$355A DW_DATA 1
RANGE $355A-$355C DW_DATA 1
RANGE $355C-$355E DW_DATA 1
RANGE $355E-$3560 DW_DATA 1
RANGE $3560-$3562 DW_DATA 1
RANGE $3562-$3565 DB_DATA 3
RANGE $3565-$3568 DB_DATA 3
RANGE $3568-$356B DB_DATA 3
RANGE $356B-$356E DB_DATA 3
RANGE $356E-$3571 DB_DATA 3
RANGE $3571-$3574 DB_DATA 3
RANGE $3574-$3577 DB_DATA 3
RANGE $3577-$357A DB_DATA 3
RANGE $357A-$357D DB_DATA 3
RANGE $357D-$3580 DB_DATA 3
RANGE $3580-$3583 DB_DATA 3
RANGE $3583-$3586 DB_DATA 3
RANGE $3586-$3589 DB_DATA 3
RANGE $3589-$358C DB_DATA 3
RANGE $358C-$358F DB_DATA 3
RANGE $358F-$3592 DB_DATA 3
RANGE $3592-$3595 DB_DATA 3
RANGE $3595-$3598 DB_DATA 3
RANGE $3598-$359B DB_DATA 3
RANGE $359B-$359E DB_DATA 3
RANGE $359E-$35A1 DB_DATA 3
RANGE $35A1-$35A4 DB_DATA 3
RANGE $35A4-$35A7 DB_DATA 3
RANGE $35A7-$35AA DB_DATA 3
RANGE $35AA-$35AD DB_DATA 3
RANGE $35AD-$35B0 DB_DATA 3
RANGE $35B0-$35B3 DB_DATA 3
RANGE $35B3-$35B4 DB_DATA 1
RANGE $35B4-$35B7 DB_DATA 3
RANGE $35B7-$35BA DB_DATA 3
RANGE $35BA-$35BD DB_DATA 3
RANGE $35BD-$35C0 DB_DATA 3
RANGE $35C0-$35C3 DB_DATA 3
RANGE $35C3-$35C6 DB_DATA 3
RANGE $35C6-$35C9 DB_DATA 3
RANGE $35C9-$35CC DB_DATA 3
RANGE $35CC-$35CF DB_DATA 3
RANGE $35CF-$35D2 DB_DATA 3
RANGE $35D2-$35D5 DB_DATA 3
RANGE $35D5-$35D8 DB_DATA 3
RANGE $35D8-$35DB DB_DATA 3
RANGE $35DB-$35DE DB_DATA 3
RANGE $35DE-$35E1 DB_DATA 3
RANGE $35E1-$35E4 DB_DATA 3
RANGE $35E4-$35E7 DB_DATA 3
RANGE $35E7-$35EA DB_DATA 3
RANGE $35EA-$35ED DB_DATA 3
RANGE $35ED-$35F0 DB_DATA 3
RANGE $35F0-$35F3 DB_DATA 3
RANGE $35F3-$35F6 DB_DATA 3
RANGE $35F6-$35F9 DB_DATA 3
RANGE $35F9-$35FC DB_DATA 3
RANGE $35FC-$35FF DB_DATA 3
RANGE $35FF-$3602 DB_DATA 3
RANGE $3602-$3605 DB_DATA 3
RANGE $3605-$3608 DB_DATA 3
RANGE $3608-$360B DB_DATA 3
RANGE $360B-$360C DB_DATA 1
RANGE $360C-$360F DB_DATA 3
RANGE $360F-$3612 DB_DATA 3
RANGE $3612-$3615 DB_DATA 3
RANGE $3615-$3618 DB_DATA 3
RANGE $3618-$361B DB_DATA 3
RANGE $361B-$361E DB_DATA 3
RANGE $361E-$3621 DB_DATA 3
RANGE $3621-$3624 DB_DATA 3
RANGE $3624-$3627 DB_DATA 3
RANGE $3627-$362A DB_DATA 3
RANGE $362A-$362D DB_DATA 3
RANGE $362D-$3630 DB_DATA 3
RANGE $3630-$3633 DB_DATA 3
RANGE $3633-$3636 DB_DATA 3
RANGE $3636-$3639 DB_DATA 3
RANGE $3639-$363C DB_DATA 3
RANGE $363C-$363F DB_DATA 3
RANGE $363F-$3642 DB_DATA 3
RANGE $3642-$3645 DB_DATA 3
RANGE $3645-$3648 DB_DATA 3
RANGE $3648-$364B DB_DATA 3
RANGE $364B-$364E DB_DATA 3
RANGE $364E-$3651 DB_DATA 3
RANGE $3651-$3654 DB_DATA 3
RANGE $3654-$3657 DB_DATA 3
RANGE $3657-$365A DB_DATA 3
RANGE $365A-$365D DB_DATA 3
RANGE $365D-$3660 DB_DATA 3
RANGE $3660-$3663 DB_DATA 3
RANGE $3663-$3664 DB_DATA 1

