/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.malban.graphics;

import de.malban.event.EditMouseEvent;
import static de.malban.graphics.VectorColors.*;
import de.malban.gui.Scaler;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Stroke;
import static java.awt.event.ActionEvent.CTRL_MASK;
import static java.awt.event.ActionEvent.SHIFT_MASK;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
import java.util.HashMap;

/**
 *
 * @author malban
 */
public class SingleVector3dPanel  extends SingleVectorPanel
{
    int inSetting = 0;
    boolean isOpaque = false;
    
    public boolean moveXAllowed = true;
    public boolean moveYAllowed = true;
    public boolean moveZAllowed = false;
    
    GFXVector xAxis = new GFXVector();
    GFXVector yAxis = new GFXVector();
    GFXVector zAxis = new GFXVector();

    boolean axisShown = false;
    boolean repaint = true;
    public void setRepaint(boolean rp)
    {
        repaint = rp;
    }
    
    
    public void setAxisShown (boolean s)
    {
        axisShown = s;
        sharedRepaint();
    }
            
    public SingleVector3dPanel() {
        initComponents();
        xAxis.start.x(-2000);
        xAxis.end.x(+2000);
        yAxis.start.y(-2000);
        yAxis.end.y(+2000);
        zAxis.start.z(-2000);
        zAxis.end.z(+2000);
    }
    public void deinit()
    {
        setVisible(false);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 235, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 241, Short.MAX_VALUE)
        );
    }// </editor-fold>                        

    int axisXAngle = 0;
    int axisYAngle = 0;
    int axisZAngle = 0;
    public void setAxisAngleX(int value)
    {
        axisXAngle = value;
        sharedRepaint();
    }
    public void setAxisAngleY(int value)
    {
        axisYAngle = value;
        sharedRepaint();
    }
    public void setAxisAngleZ(int value)
    {
        axisZAngle = value;
        sharedRepaint();
    }
    public int getAxisAngleX()
    {
        return axisXAngle;
    }
    public int getAxisAngleY()
    {
        return axisYAngle;
    }
    public int getAxisAngleZ()
    {
        return axisZAngle;
    }
    
    int angleX = 0;
    int angleY = 0;
    int angleZ = 0;
    int transX = 0;
    int transY = 0;
    int transZ = 0;
    public void setAngleX(int value)
    {
        angleX = value;
        sharedRepaint();
    }
    public void setAngleY(int value)
    {
        angleY = value;
        sharedRepaint();
    }
    public void setAngleZ(int value)
    {
        angleZ = value;
        sharedRepaint();
    }
    
    public void setTranslocationX(int x)
    {
        transX = x;
        sharedRepaint();
    }
    public void setTranslocationY(int y)
    {
        transY = y;
        sharedRepaint();
    }
    public void setTranslocationZ(int z)
    {
        transZ = z;
        sharedRepaint();
    }
    public GFXVectorList getDisplayVectorList()
    {
        return lastDisplayList;
    }
    GFXVectorList lastDisplayList = new GFXVectorList();
    @Override public void paintComponent(Graphics g)
    {
//        super.paintComponent(g);
        if (bufferUsed == -1) return;
        g.drawImage(paintBufferImage[bufferUsed], 0, 0, null);
    }

    @Override
    public void sharedRepaint() {
        if (singleRepaint)
        {
            return;
        }

        updateAndRepaint();
        super.sharedRepaint(); //To change body of generated methods, choose Tools | Templates.

    }

    
    
    // Variables declaration - do not modify                     
    // End of variables declaration                   

    boolean singleRepaint = false;
    public void setSingleRepaint(boolean b)
    {
        singleRepaint = b;
    }
    boolean oldSingleRepaint = false;
    public void disableSingleRepaint()
    {
        oldSingleRepaint = singleRepaint;
        singleRepaint = false;
    }
    public void enableSingleRepaint()
    {
        oldSingleRepaint = singleRepaint;
        singleRepaint = true;
    }
    public void restoreSingleRepaint()
    {
        singleRepaint = oldSingleRepaint;
    }
    
    BufferedImage[] paintBufferImage = new BufferedImage[2];
    int bufferUsed = -1;
    public synchronized void updateAndRepaint()
    {
        if (noRepaint) return;
        int width = getWidth();
        int height = getHeight();
        if (width == 0) return;
        if (height == 0) return;
        int nextBuffer = (bufferUsed +1)%2;
        paintBufferImage[nextBuffer] = de.malban.util.UtilityImage.getNewImage(width, height);

        int usedxOff = usePrivateOffset?xOffset:vars.xOffset;
        int usedyOff = usePrivateOffset?yOffset:vars.yOffset;
        int usedzOff = usePrivateOffset?zOffset:vars.zOffset;

        if ( paintBufferImage[nextBuffer] == null) return;

        if (!repaint) 
        {
            bufferUsed = nextBuffer;
            return;
        }
        x0Offset = getWidth()/2;
        y0Offset = getHeight()/2;
        Matrix4x4 trans = Matrix4x4.getTranslocation(transX, transY, transZ);
        Matrix4x4 rotx = Matrix4x4.getRotationX(Math.toRadians(angleX));
        Matrix4x4 roty = Matrix4x4.getRotationY(Math.toRadians(angleY));
        Matrix4x4 rotz = Matrix4x4.getRotationZ(Math.toRadians(angleZ));
        Matrix4x4 rotax = Matrix4x4.getRotationX(Math.toRadians(axisXAngle));
        Matrix4x4 rotay = Matrix4x4.getRotationY(Math.toRadians(axisYAngle));
        Matrix4x4 rotaz = Matrix4x4.getRotationZ(Math.toRadians(axisZAngle));

        Graphics2D g = paintBufferImage[nextBuffer].createGraphics();
        synchronized (vars.foregroundVectors.list)
        {
            g.setColor(VECCI_BACKGROUND_COLOR);
            g.fillRect(0, 0, getWidth(), getHeight());
            if (!repaint) return;

            if (vars.drawByteFrame)
            {
                g.setColor(VECCI_FRAME_COLOR);
                Vertex vq1 =new Vertex(-128, -128, -128);
                Vertex vq2 =new Vertex(-128, -128, 127);
                Vertex vq3 =new Vertex(-128, 127, -128);
                Vertex vq4 =new Vertex(-128, 127, 127);
                Vertex vq5 =new Vertex(127, -128, -128);
                Vertex vq6 =new Vertex(127, -128, 127);
                Vertex vq7 =new Vertex(127, 127, -128);
                Vertex vq8 =new Vertex(127, 127, 127);
                int q=0;
                GFXVector[] qube = new GFXVector[12];
                qube[q++] = new GFXVector(vq1,vq5);
                qube[q++] = new GFXVector(vq1,vq3);
                qube[q++] = new GFXVector(vq1,vq2);
                qube[q++] = new GFXVector(vq8,vq4);
                qube[q++] = new GFXVector(vq8,vq6);
                qube[q++] = new GFXVector(vq8,vq7);
                qube[q++] = new GFXVector(vq7,vq5);
                qube[q++] = new GFXVector(vq7,vq3);
                qube[q++] = new GFXVector(vq4,vq3);
                qube[q++] = new GFXVector(vq4,vq2);
                qube[q++] = new GFXVector(vq6,vq2);
                qube[q++] = new GFXVector(vq6,vq5);
                
                for (q=0; q<12;q++)
                {
                    qube[q].start.x(qube[q].start.x()+usedxOff);
                    qube[q].start.y(qube[q].start.y()-usedyOff);
                    qube[q].start.z(qube[q].start.z()+usedzOff);
                    qube[q].end.x(qube[q].end.x()+usedxOff);
                    qube[q].end.y(qube[q].end.y()-usedyOff);
                    qube[q].end.z(qube[q].end.z()+usedzOff);
                    
                    qube[q].start = rotax.multiply(qube[q].start);
                    qube[q].start = rotay.multiply(qube[q].start);
                    qube[q].start = rotaz.multiply(qube[q].start);
                    qube[q].end = rotax.multiply(qube[q].end);
                    qube[q].end = rotay.multiply(qube[q].end);
                    qube[q].end = rotaz.multiply(qube[q].end);

                    int x0 = Scaler.scaleDoubleToInt(qube[q].start.x(), scale);            
                    int y0 = -Scaler.scaleDoubleToInt(qube[q].start.y(), scale);            
                    int x1 = Scaler.scaleDoubleToInt(qube[q].end.x(), scale);            
                    int y1 = -Scaler.scaleDoubleToInt(qube[q].end.y(), scale);            

                    x0 = x0Offset + x0;
                    y0 = y0Offset + y0;
                    x1 = x0Offset + x1;
                    y1 = y0Offset + y1;

                    g.drawLine(x0, y0, x1, y1);
                }
                


            }            


            if (axisShown)
            {
                GFXVector xAxisClone =  xAxis.clone();
                GFXVector yAxisClone =  yAxis.clone();
                GFXVector zAxisClone =  zAxis.clone();
                
                xAxisClone.start.x(xAxisClone.start.x()+usedxOff);
                xAxisClone.end.x(xAxisClone.end.x()+usedxOff);
                xAxisClone.start.y(xAxisClone.start.y()-usedyOff);
                xAxisClone.end.y(xAxisClone.end.y()-usedyOff);
                xAxisClone.start.z(xAxisClone.start.z()+usedzOff);
                xAxisClone.end.z(xAxisClone.end.z()+usedzOff);
                yAxisClone.start.x(yAxisClone.start.x()+usedxOff);
                yAxisClone.end.x(yAxisClone.end.x()+usedxOff);
                yAxisClone.start.y(yAxisClone.start.y()-usedyOff);
                yAxisClone.end.y(yAxisClone.end.y()-usedyOff);
                yAxisClone.start.z(yAxisClone.start.z()+usedzOff);
                yAxisClone.end.z(yAxisClone.end.z()+usedzOff);
                zAxisClone.start.x(zAxisClone.start.x()+usedxOff);
                zAxisClone.end.x(zAxisClone.end.x()+usedxOff);
                zAxisClone.start.y(zAxisClone.start.y()-usedyOff);
                zAxisClone.end.y(zAxisClone.end.y()-usedyOff);
                zAxisClone.start.z(zAxisClone.start.z()+usedzOff);
                zAxisClone.end.z(zAxisClone.end.z()+usedzOff);

                GFXVector ax = rotax.multiply(xAxisClone);
                ax = rotay.multiply(ax);
                ax = rotaz.multiply(ax);
                GFXVector ay = rotax.multiply(yAxisClone);
                ay = rotay.multiply(ay);
                ay = rotaz.multiply(ay);
                GFXVector az = rotax.multiply(zAxisClone);
                az = rotay.multiply(az);
                az = rotaz.multiply(az);

                g.setColor(VECCI_X_AXIS_COLOR);
                double x0 = Scaler.scaleDoubleToInt(ax.start.x(), scale);            
                double y0 = -Scaler.scaleDoubleToInt(ax.start.y(), scale);            
                double x1 = Scaler.scaleDoubleToInt(ax.end.x(), scale);            
                double y1 = -Scaler.scaleDoubleToInt(ax.end.y(), scale);            
                g.drawLine((int) (x0+x0Offset), (int) (y0+y0Offset),  (int) (x1+x0Offset),  (int)(y1+y0Offset));

                
                
                g.setColor(VECCI_Y_AXIS_COLOR);
                x0 = Scaler.scaleDoubleToInt(ay.start.x(), scale);            
                y0 = -Scaler.scaleDoubleToInt(ay.start.y(), scale);            
                x1 = Scaler.scaleDoubleToInt(ay.end.x(), scale);            
                y1 = -Scaler.scaleDoubleToInt(ay.end.y(), scale);            
                g.drawLine((int) (x0+x0Offset), (int) (y0+y0Offset),  (int) (x1+x0Offset),  (int)(y1+y0Offset));
                
                
                
                g.setColor(VECCI_Z_AXIS_COLOR);
                x0 = Scaler.scaleDoubleToInt(az.start.x(), scale);            
                y0 = -Scaler.scaleDoubleToInt(az.start.y(), scale);            
                x1 = Scaler.scaleDoubleToInt(az.end.x(), scale);            
                y1 = -Scaler.scaleDoubleToInt(az.end.y(), scale);            
                g.drawLine((int) (x0+x0Offset), (int) (y0+y0Offset),  (int) (x1+x0Offset),  (int)(y1+y0Offset));
            }        
            drawGrid(g);
            // Grid done
            // save original color
            Color c = g.getColor();
            

            int pos = 0;
        
            lastDisplayList = vars.foregroundVectors.clone();
            int count = 0;
           // for (GFXVector v: vars.foregroundVectors.list)
            HashMap<Vertex, Vertex> noDouble = new HashMap<Vertex, Vertex>();
            for (GFXVector v: lastDisplayList.list)
            {
                double x0,x1,y0,y1, z0, z1;
                // vectrex y coordinate has opposite "direction"

                // transformation
                Vertex p1 = v.start;
                Vertex p2 = v.end;
                
                
                if (noDouble.get(p1) == null)
                {
                    noDouble.put(p1,p1);

                    p1.x(p1.x()+usedxOff);
                    p1.y(p1.y()-usedyOff);
                    p1.z(p1.z()+usedzOff);
                    
                    p1 = trans.multiply(p1);
                    p1 = rotx.multiply(p1);
                    p1 = roty.multiply(p1);
                    p1 = rotz.multiply(p1);
                    p1 = rotax.multiply(p1);
                    p1 = rotay.multiply(p1);
                    p1 = rotaz.multiply(p1);
            //        p1.coords[0] = Math.round(p1.coords[0]);
            //        p1.coords[1] = Math.round(p1.coords[1]);
            //        p1.coords[2] = Math.round(p1.coords[2]);
                    v.start.set(p1);
                }
                if (noDouble.get(p2) == null)
                {
                    noDouble.put(p2,p2);

                    p2.x(p2.x()+usedxOff);
                    p2.y(p2.y()-usedyOff);
                    p2.z(p2.z()+usedzOff);

                    p2 = trans.multiply(p2);
                    p2 = rotx.multiply(p2);
                    p2 = roty.multiply(p2);
                    p2 = rotz.multiply(p2);
                    p2 = rotax.multiply(p2);
                    p2 = rotay.multiply(p2);
                    p2 = rotaz.multiply(p2);
            //        p2.coords[0] = Math.round(p2.coords[0]);
            //        p2.coords[1] = Math.round(p2.coords[1]);
            //        p2.coords[2] = Math.round(p2.coords[2]);
                    v.end.set(p2);
                }

                x0 = Scaler.scaleDoubleToInt(p1.x(), scale);            
                y0 = -Scaler.scaleDoubleToInt(p1.y(), scale);            
                x1 = Scaler.scaleDoubleToInt(p2.x(), scale);            
                y1 = -Scaler.scaleDoubleToInt(p2.y(), scale);            

                double x0v = x0Offset + x0;
                double y0v = y0Offset + y0;
                double x1v = x0Offset + x1;
                double y1v = y0Offset + y1;

                if ((v.a>255) || (v.a<0)) v.a = 127;
                g.setColor(new Color(v.r, v.g, v.b, v.a));
                // g.setColor(Color.white);
                if (v.highlight)
                {
                    g.setColor(VECCI_VECTOR_HIGHLIGHT_COLOR);
                }
                if (v.selected)
                {
                    g.setColor(VECCI_VECTOR_SELECTED_COLOR);
                }


                // DRAW the Vector
                if (v.pattern != 255)
                {
                    
                    if ((v.pattern == 0) && (vars.drawMoves))
                    {
                        g.setColor(VECCI_MOVE_COLOR);
                        if (vars.drawArrows)
                            drawArrow(g,(int) x0v,  (int)y0v,  (int)x1v,  (int)y1v);    
                        else
                            g.drawLine((int) x0v,  (int)y0v,  (int)x1v,  (int)y1v);
                    }
                    
                    else
                    {
                        float[] pattern = getPattern(v);
                        Stroke dashed = new BasicStroke(0, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 1, pattern, 0);
                        Graphics2D g2 = (Graphics2D) g;
                        Stroke saveStroke = g2.getStroke();
                        g2.setStroke(dashed);
                        g2.drawLine((int) x0v,  (int)y0v,  (int)x1v,  (int)y1v);
                        g2.setStroke(saveStroke);
                    }
                }
                else
                {
                    if (vars.drawArrows)
                        drawArrow(g,(int) x0v,  (int)y0v,  (int)x1v,  (int)y1v);    
                    else
                        g.drawLine((int) x0v,  (int)y0v,  (int)x1v,  (int)y1v);
                    
                }
                if (vars.drawPositions)
                {

                    g.setColor(VECCI_POS_COLOR);
                    int xx =(int) x0v + (int) (x1v-x0v)/2;
                    int yy =(int) y0v + (int)(y1v-y0v)/2;
                    g.drawString(""+pos, xx,  yy);
                }

                // DRAW endpoints
                if (v.start.highlight)
                {
                    g.setColor(VECCI_POINT_HIGHLIGHT_COLOR);
                    g.fillRect((int) x0v, (int)y0v, 3, 3);
                }
                if (v.end.highlight)
                {
                    g.setColor(VECCI_POINT_HIGHLIGHT_COLOR);
                    g.fillRect((int) x1v, (int)y1v, 3, 3);
                }
                if (v.start.selected)
                {
                    g.setColor(VECCI_POINT_SELECTED_COLOR);
                    g.fillRect((int) x0v, (int)y0v, 3, 3);
                }
                if (v.end.selected)
                {
                    g.setColor(VECCI_POINT_SELECTED_COLOR);
                    g.fillRect((int) x1v, (int)y1v, 3, 3);
                }
                count++;
                pos++;
            } // Foreground Vectors done

            if (!dumpMode)
                lastDisplayList.setRelativeWherePossible();

            // draw highlighted points (mouse is on them)
            if (vars.hightLightVPoint != null) 
            {
                if (vars.hightLightVPoint.highlight)
                {
                    Vertex s = new Vertex (vars.hightLightVPoint);
                    s.x(s.x()+usedxOff);
                    s.y(s.y()-usedyOff);
                    s.z(s.z()+usedzOff);

                    s = rotax.multiply(s);
                    s = rotay.multiply(s);
                    s = rotaz.multiply(s);

                    double x0 = Scaler.scaleDoubleToInt(s.x(), scale);            
                    double y0 = -Scaler.scaleDoubleToInt(s.y(), scale);            
                    x0 = x0Offset+x0;
                    y0 = y0Offset+y0;
                    g.setColor(VECCI_POINT_HIGHLIGHT_COLOR);
                    g.drawOval((int)x0-vars.POINT_HIGHLIGHT_RADIUS, (int)y0-vars.POINT_HIGHLIGHT_RADIUS, vars.POINT_HIGHLIGHT_RADIUS*2, vars.POINT_HIGHLIGHT_RADIUS*2);
                }
            }

            // draw highlighted vector (mouse is on)
            if (vars.hightLightVector != null) 
            {
                if (vars.hightLightVector.highlight)
                {
                    GFXVector clone = vars.hightLightVector.clone();

                    clone.start.x(clone.start.x()+usedxOff);
                    clone.start.y(clone.start.y()-usedyOff);
                    clone.start.z(clone.start.z()+usedzOff);
                    clone.end.x(clone.end.x()+usedxOff);
                    clone.end.y(clone.end.y()-usedyOff);
                    clone.end.z(clone.end.z()+usedzOff);

                    
                    
                    clone.start = rotax.multiply(clone.start);
                    clone.start = rotay.multiply(clone.start);
                    clone.start = rotaz.multiply(clone.start);
                    clone.end = rotax.multiply(clone.end);
                    clone.end = rotay.multiply(clone.end);
                    clone.end = rotaz.multiply(clone.end);

                    double x0 = Scaler.scaleDoubleToInt(clone.start.x(), scale);            
                    double y0 = -Scaler.scaleDoubleToInt(clone.start.y(), scale);            
                    double x1 = Scaler.scaleDoubleToInt(clone.end.x(), scale);            
                    double y1 = -Scaler.scaleDoubleToInt(clone.end.y(), scale);            

                    x0 = x0Offset+x0;
                    y0 = y0Offset+y0;
                    x1 = x0Offset+x1;
                    y1 = y0Offset+y1;
                    g.setColor(VECCI_VECTOR_HIGHLIGHT_COLOR);

                    // construct a perpendicular vector for a 
                    // paralle transition
                    double py = x0-x1;
                    double px = -(y0-y1);
                    double l = Math.sqrt((Math.pow(py,2) + Math.pow(px,2)));

                    double transition = vars.VECTOR_HIGHLIGHT_RADIUS;

                    double px0 = x0 + (transition / l) * px;
                    double py0 = y0 + (transition / l) * py;
                    double px1 = x1 + (transition / l) * px;
                    double py1 = y1 + (transition / l) * py;

                    double transition2 = -vars.VECTOR_HIGHLIGHT_RADIUS;

                    double px02 = x0 + (transition2 / l) * px;
                    double py02 = y0 + (transition2 / l) * py;
                    double px12 = x1 + (transition2 / l) * px;
                    double py12 = y1 + (transition2 / l) * py;

                    g.drawLine(((int) px0), ((int) py0), ((int) px1),((int) py1));
                    g.drawLine(((int) px02), ((int) py02), ((int) px12),((int) py12));

                    g.drawLine(((int) px0), ((int) py0), ((int) px02),((int) py02));
                    g.drawLine(((int) px1), ((int) py1), ((int) px12),((int) py12));
                }
            }
            // draw selected vectors/ points 
            synchronized (vars.foregroundVectors.list)
            {
                for (GFXVector v: vars.foregroundVectors.list)
                {
                    // draw selected vectors
                    if (v.selected)
                    {
                        GFXVector clone = v.clone();

                        clone.start.x(clone.start.x()+usedxOff);
                        clone.start.y(clone.start.y()-usedyOff);
                        clone.start.z(clone.start.z()+usedzOff);
                        clone.end.x(clone.end.x()+usedxOff);
                        clone.end.y(clone.end.y()-usedyOff);
                        clone.end.z(clone.end.z()+usedzOff);



                        clone.start = rotax.multiply(clone.start);
                        clone.start = rotay.multiply(clone.start);
                        clone.start = rotaz.multiply(clone.start);
                        clone.end = rotax.multiply(clone.end);
                        clone.end = rotay.multiply(clone.end);
                        clone.end = rotaz.multiply(clone.end);

                        double x0 = Scaler.scaleDoubleToInt(clone.start.x(), scale);            
                        double y0 = -Scaler.scaleDoubleToInt(clone.start.y(), scale);            
                        double x1 = Scaler.scaleDoubleToInt(clone.end.x(), scale);            
                        double y1 = -Scaler.scaleDoubleToInt(clone.end.y(), scale);            

                        x0 = x0Offset+x0;
                        y0 = y0Offset+y0;
                        x1 = x0Offset+x1;
                        y1 = y0Offset+y1;                        
             
                        g.setColor(VECCI_VECTOR_SELECTED_COLOR);

                        // construct a perpendicular vector for a 
                        // parallel transition
                        double py = x0-x1;
                        double px = -(y0-y1);
                        double l = Math.sqrt((Math.pow(py,2) + Math.pow(px,2)));

                        double transition = vars.VECTOR_SELECTED_RADIUS;

                        double px0 = x0 + (transition / l) * px;
                        double py0 = y0 + (transition / l) * py;
                        double px1 = x1 + (transition / l) * px;
                        double py1 = y1 + (transition / l) * py;

                        double transition2 = -vars.VECTOR_SELECTED_RADIUS;

                        double px02 = x0 + (transition2 / l) * px;
                        double py02 = y0 + (transition2 / l) * py;
                        double px12 = x1 + (transition2 / l) * px;
                        double py12 = y1 + (transition2 / l) * py;

                        g.drawLine(((int) px0), ((int) py0), ((int) px1),((int) py1));
                        g.drawLine(((int) px02), ((int) py02), ((int) px12),((int) py12));

                        g.drawLine(((int) px0), ((int) py0), ((int) px02),((int) py02));
                        g.drawLine(((int) px1), ((int) py1), ((int) px12),((int) py12));
                    }
                    
                    
                    
                    // draw selected point
                    Vertex s = new Vertex (v.start);
                    if (s.selected)
                    {
                        s.x(s.x()+usedxOff);
                        s.y(s.y()-usedyOff);
                        s.z(s.z()+usedzOff);

                        s = rotax.multiply(s);
                        s = rotay.multiply(s);
                        s = rotaz.multiply(s);

                        double x0 = Scaler.scaleDoubleToInt(s.x(), scale);            
                        double y0 = -Scaler.scaleDoubleToInt(s.y(), scale);            
                        x0 = x0Offset+x0;
                        y0 = y0Offset+y0;
                        g.setColor(VECCI_POINT_SELECTED_COLOR);
                        g.drawOval((int)x0-vars.POINT_SELECTED_RADIUS, (int)y0-vars.POINT_SELECTED_RADIUS, vars.POINT_SELECTED_RADIUS*2, vars.POINT_SELECTED_RADIUS*2);
                    }
                    s = new Vertex (v.end);
                    if (s.selected)
                    {
                        s.x(s.x()+usedxOff);
                        s.y(s.y()-usedyOff);
                        s.z(s.z()+usedzOff);

                        s = rotax.multiply(s);
                        s = rotay.multiply(s);
                        s = rotaz.multiply(s);

                        double x0 = Scaler.scaleDoubleToInt(s.x(), scale);            
                        double y0 = -Scaler.scaleDoubleToInt(s.y(), scale);            
                        x0 = x0Offset+x0;
                        y0 = y0Offset+y0;
                        g.setColor(VECCI_POINT_SELECTED_COLOR);
                        g.drawOval((int)x0-vars.POINT_SELECTED_RADIUS, (int)y0-vars.POINT_SELECTED_RADIUS, vars.POINT_SELECTED_RADIUS*2, vars.POINT_SELECTED_RADIUS*2);
                    }
                }
            }        
            // restore original color
            g.setColor(c);            
        }

        bufferUsed = nextBuffer;
        super.repaint();
    }
    public void repaint() 
    {
        updateAndRepaint();
    }
    boolean noRepaint = false;
    public void suspendRepaint()
    {
        noRepaint = true;
    }
    public void continueRepaint()
    {
        noRepaint = false;
        repaint();
    }
    
    boolean dumpMode = false;
    public void setDumpMode(boolean dp)
    {
        dumpMode = dp;
    }

    boolean gridx = true;
    boolean gridy = true;
    boolean gridz = false;

    public void setGridx(boolean b)
    {
        gridx = b;
        repaint();
    }
    public void setGridy(boolean b)
    {
        gridy = b;
        repaint();
    }
    public void setGridz(boolean b)
    {
        gridz = b;
        repaint();
    }
    
    void drawGrid(Graphics2D g)
    {
        Matrix4x4 rotax = Matrix4x4.getRotationX(Math.toRadians(axisXAngle));
        Matrix4x4 rotay = Matrix4x4.getRotationY(Math.toRadians(axisYAngle));
        Matrix4x4 rotaz = Matrix4x4.getRotationZ(Math.toRadians(axisZAngle));
        
        GFXVector dot = new GFXVector();
        int usedxOff = usePrivateOffset?xOffset:vars.xOffset;
        int usedyOff = usePrivateOffset?yOffset:vars.yOffset;
        int usedzOff = usePrivateOffset?zOffset:vars.zOffset;

        // draw the grid
        g.setColor(VECCI_GRID_COLOR);
        double scaleUse = usePrivateScale?scale:vars.scale;
        
        int minx = (int) Scaler.unscaleDoubleToDouble((x0Offset), scaleUse);
        int miny = (int) Scaler.unscaleDoubleToDouble((y0Offset), scaleUse);
        int minz = minx;
        
        int gwidth = vars.gridWidth;
        
        if (!vars.displayGrid) gwidth = 1;
        
        if (!gridx)minx = gwidth;
        if (!gridy)miny = gwidth;
        if (!gridz)minz = gwidth;
        
        if (minx<gwidth)minx=gwidth;
        if (miny<gwidth)miny=gwidth;
        if (minz<gwidth)minz=gwidth;
        
        
        long max = (minx/gwidth)*(miny/gwidth)*(minz/gwidth);
        
        if (minx!=1) max *=2;
        if (miny!=1) max *=2;
        if (minz!=1) max *=2;
        
        if (max > 10000) return ;//50*50*25) return;
        if (max <0) return; // overflow
        if (!gridx)minx = 1;
        if (!gridy)miny = 1;
        if (!gridz)minz = 1;


        for (int x = -(minx/gwidth)*gwidth;x<=minx; x+=gwidth)
        {
            if (minx == 1) x = 0;
            for (int y = -(miny/gwidth)*gwidth;y<=miny; y+=gwidth)
            {
                if (miny == 1) y = 0;
                for (int z = -(minz/gwidth)*gwidth;z<=minz; z+=gwidth)
                {
                    if (minz == 1) z = 0;

                    dot.start.x(x+usedxOff);
                    dot.start.y(y-usedyOff);
                    dot.start.z(z+usedzOff);
                    
                    dot.end = dot.start;
                    dot.start = rotax.multiplyVariant(dot.start);
                    dot.start = rotay.multiplyVariant(dot.start);
                    dot.start = rotaz.multiplyVariant(dot.start);

                    double printx = Scaler.unscaleDoubleToDouble((x0Offset), scaleUse)+ dot.start.x();
                    double printy = Scaler.unscaleDoubleToDouble((y0Offset), scaleUse)- dot.start.y();

                    printx = Scaler.scaleDoubleToInt(printx, scaleUse);
                    printy = Scaler.scaleDoubleToInt(printy, scaleUse);
                    
                
                    g.drawLine((int)printx, (int)printy,  (int)printx, (int)printy);

                    if (minz == 1) z += 1000000;
                }
                if (miny == 1) y += 1000000;
            }
            if (minx == 1) x += 1000000;
        }
      // Grid done
    }

    // coordinates of vectors must be unrotated 
    protected void handleMouseMovedEvent(java.awt.event.MouseEvent evt)
    {
        mX=evt.getX();
        mY=evt.getY();
        
        int usedxOff = usePrivateOffset?xOffset:vars.xOffset;
        int usedyOff = usePrivateOffset?yOffset:vars.yOffset;
        int usedzOff = usePrivateOffset?zOffset:vars.zOffset;
        
        
        vars.crossColor = VECCI_CROSS_COLOR;
        
Matrix4x4 trans = Matrix4x4.getTranslocation(transX, transY, transZ);
Matrix4x4 rotx = Matrix4x4.getRotationX(Math.toRadians(angleX));
Matrix4x4 roty = Matrix4x4.getRotationY(Math.toRadians(angleY));
Matrix4x4 rotz = Matrix4x4.getRotationZ(Math.toRadians(angleZ));
        
        Matrix4x4 rotax = Matrix4x4.getRotationX(Math.toRadians(axisXAngle));
        Matrix4x4 rotay = Matrix4x4.getRotationY(Math.toRadians(axisYAngle));
        Matrix4x4 rotaz = Matrix4x4.getRotationZ(Math.toRadians(axisZAngle));

        
        // check for highliting
        if (vars.workingMode == SVP_SELECT_POINT)
        {
            double distance = Double.MAX_VALUE;
            if (vars.hightLightVPoint != null) 
            {
                vars.hightLightVPoint.highlight = false;
                vars.hightLightVPoint = null;
            }
            
           synchronized (vars.foregroundVectors.list)
           {
                for (GFXVector v: vars.foregroundVectors.list)
                {
                    GFXVector clone = v.clone();
                    
                    // transformation

                    clone.start.x(clone.start.x()+usedxOff);
                    clone.start.y(clone.start.y()-usedyOff);
                    clone.start.z(clone.start.z()+usedzOff);
                    clone.end.x(clone.end.x()+usedxOff);
                    clone.end.y(clone.end.y()-usedyOff);
                    clone.end.z(clone.end.z()+usedzOff);

                    
                    clone.start = rotax.multiplyVariant(clone.start);
                    clone.start = rotay.multiplyVariant(clone.start);
                    clone.start = rotaz.multiplyVariant(clone.start);
                    
                    clone.end = rotax.multiplyVariant(clone.end);
                    clone.end = rotay.multiplyVariant(clone.end);
                    clone.end = rotaz.multiplyVariant(clone.end);

                    Vertex p1 = clone.start;
                    Vertex p2 = clone.end;

                    double x0 = Scaler.scaleDoubleToInt(p1.x(), scale);            
                    double y0 = -Scaler.scaleDoubleToInt(p1.y(), scale);            
                    double x1 = Scaler.scaleDoubleToInt(p2.x(), scale);            
                    double y1 = -Scaler.scaleDoubleToInt(p2.y(), scale);            

                    x0 = x0Offset + x0;
                    y0 = y0Offset + y0;
                    x1 = x0Offset + x1;
                    y1 = y0Offset + y1;
                    
                    
                     double d;
                     // reset old highlite
                     v.start.highlight = false;
                     v.end.highlight = false;
                     d = Math.sqrt((mX-x0)*(mX-x0)+(mY-y0)*(mY-y0));
                     if (d<distance) 
                     {
                         distance = d;
                         vars.hightLightVPoint = v.start;
                     }
                     
                     // end point
                     d = Math.sqrt((mX-x1)*(mX-x1)+(mY-y1)*(mY-y1));
                     if (d<distance) 
                     {
                         distance = d;
                         vars.hightLightVPoint = v.end;
                     }
                     if (distance==0) break;
                 }
            }
            // distance muss wenigstens in der nähe sein!
            if (vars.hightLightVPoint != null)
            {
                if (distance<=vars.POINT_HIGHLIGHT_RANGE) // arround 5 Pixel
                {

                    vars.hightLightVPoint.highlight = true;
                }
                else
                {
                    vars.hightLightVPoint = null;
                }
            }
                
        }
        
        if (vars.workingMode == SVP_SELECT_LINE)
        {
            double distance = Double.MAX_VALUE;
            if (vars.hightLightVector != null) 
            {
                vars.hightLightVector.highlight = false;
                vars.hightLightVector = null;
            }
            
            synchronized (vars.foregroundVectors.list)
            {
                for (GFXVector v: vars.foregroundVectors.list)
                {
                    GFXVector clone = v.clone();

                    double x0,x1,y0,y1, z0, z1;
                    // vectrex y coordinate has opposite "direction"

                    // transformation
                    Vertex p1 = clone.start;
                    Vertex p2 = clone.end;

                    p1.x(p1.x()+usedxOff);
                    p1.y(p1.y()-usedyOff);
                    p1.z(p1.z()+usedzOff);
                    
p1 = trans.multiply(p1);
p1 = rotx.multiply(p1);
p1 = roty.multiply(p1);
p1 = rotz.multiply(p1);
                    
                    p1 = rotax.multiply(p1);
                    p1 = rotay.multiply(p1);
                    p1 = rotaz.multiply(p1);
                    p1.coords[0] = Math.round(p1.coords[0]);
                    p1.coords[1] = Math.round(p1.coords[1]);
                    p1.coords[2] = Math.round(p1.coords[2]);

                    
                    p2.x(p2.x()+usedxOff);
                    p2.y(p2.y()-usedyOff);
                    p2.z(p2.z()+usedzOff);

p2 = trans.multiply(p2);
p2 = rotx.multiply(p2);
p2 = roty.multiply(p2);
p2 = rotz.multiply(p2);

                    p2 = rotax.multiply(p2);
                    p2 = rotay.multiply(p2);
                    p2 = rotaz.multiply(p2);
                    p2.coords[0] = Math.round(p2.coords[0]);
                    p2.coords[1] = Math.round(p2.coords[1]);
                    p2.coords[2] = Math.round(p2.coords[2]);


                    x0 = Scaler.scaleDoubleToInt(p1.x(), scale);            
                    y0 = -Scaler.scaleDoubleToInt(p1.y(), scale);            
                    x1 = Scaler.scaleDoubleToInt(p2.x(), scale);            
                    y1 = -Scaler.scaleDoubleToInt(p2.y(), scale);            

                    x0 = x0Offset + x0;
                    y0 = y0Offset + y0;
                    x1 = x0Offset + x1;
                    y1 = y0Offset + y1;

                    
                    
                    // reset old highlite
                    v.highlight = false;


                    // nice, but now that I think of it I need a line SEGMENT, not a line!
                    double d = getDistancePointToVector((double)mX, (double)mY, x0,y0,x1,y1);
                    if (d<distance) 
                    {
                        distance = d;
                        vars.hightLightVector = v;
                    }
                    if (distance==0) break;
                }
            }
            // distance must be NEAR (in range)
            if (vars.hightLightVector != null)
            {
                if (distance<=vars.VECTOR_HIGHLIGHT_RANGE) // arround 5 Pixel
                {

                    vars.hightLightVector.highlight = true;
                }
                else
                {
                    vars.hightLightVector = null;
                }
            }
        }        
        
        sharedRepaint();
        fireMouseMoved(evt);        
    }
    protected void handleMousePressed(java.awt.event.MouseEvent evt)
    {
        if (vars.noMouseReaction) return;
        if (evt.getButton() == MouseEvent.BUTTON1)
        {
            if (vars.continueMode)
            {
                // if in continues mode
                // mouse press should not
                // update any mouse coordinates
                // since the continue vector is drawn
                // with "last" mXPressStart
                vars.pressed = true;
                return;
            }
            vars.shiftPressed = false;
            vars.ctrlPressed = false;
            vars.pressed = true;
            mXPressStart =  evt.getX();
            mYPressStart =  evt.getY();

            double scaleUse = usePrivateScale?scale:vars.scale;
            Matrix4x4 rotax = Matrix4x4.getRotationX(Math.toRadians(axisXAngle));
            Matrix4x4 rotay = Matrix4x4.getRotationY(Math.toRadians(axisYAngle));
            Matrix4x4 rotaz = Matrix4x4.getRotationZ(Math.toRadians(axisZAngle));
            rotax.transpose();
            rotay.transpose();
            rotaz.transpose();
            
            Vertex start = new Vertex(mXPressStart-x0Offset,-(mYPressStart-y0Offset),0);
                
            start = rotax.multiply(start);
            start = rotay.multiply(start);
            start = rotaz.multiply(start);
                
            double xStart = Scaler.unscaleDoubleToDouble(start.x(), scaleUse);
            double yStart = Scaler.unscaleDoubleToDouble(start.y(), scaleUse);
            double zStart = Scaler.unscaleDoubleToDouble(start.z(), scaleUse);

            
            
            if (isGrid())
            {
                mDragOriginX =lastCrossX = (int) ((int) ( ((double)xStart)/((double)vars.gridWidth) +(((double)1)/2)) * ((double)vars.gridWidth));
                mDragOriginY =lastCrossY = (int) ((int) ( ((double)yStart)/((double)vars.gridWidth) +(((double)1)/2)) * ((double)vars.gridWidth));
                mDragOriginZ =lastCrossZ = (int) ((int) ( ((double)zStart)/((double)vars.gridWidth) +(((double)1)/2)) * ((double)vars.gridWidth));
            }
            else
            {
                mDragOriginX =lastCrossX = (int)xStart;
                mDragOriginY =lastCrossY = (int)yStart;
                mDragOriginZ =lastCrossZ = (int)zStart;
            }
            
            vars.shiftPressed = ((evt.getModifiers() & SHIFT_MASK) == SHIFT_MASK);
            vars.ctrlPressed = ((evt.getModifiers() & CTRL_MASK) == CTRL_MASK);
        }
        fireMousePressed(evt);
        vars.crossColor = VECCI_CROSS_DRAG_COLOR;
        sharedRepaint();        
    }

    protected void handleMouseDraggedEvent(java.awt.event.MouseEvent evt)
    {
        if (vars.noMouseReaction) return;
        mX=evt.getX();
        mY=evt.getY();

        int x =  mXPressStart; 
        int y =  mYPressStart; 
        int w =  mX-mXPressStart; 
        int h =  mY-mYPressStart; 

        Matrix4x4 rotax = Matrix4x4.getRotationX(Math.toRadians(axisXAngle));
        Matrix4x4 rotay = Matrix4x4.getRotationY(Math.toRadians(axisYAngle));
        Matrix4x4 rotaz = Matrix4x4.getRotationZ(Math.toRadians(axisZAngle));
        rotax.transpose();
        rotay.transpose();
        rotaz.transpose();

        if (vars.pressed)
        {
            if (vars.ctrlPressed)
            {
                // drag location
                vars.dragging = true;
                double scaleUse = usePrivateScale?scale:vars.scale;

                // Scaler.unscaleDoubleToDouble(x0Offset, scaleUse)
                Vertex start = new Vertex(0,0,0);
                Vertex end = new Vertex(w,-h,0);
                
                start = rotaz.multiply(start);
                start = rotay.multiply(start);
                start = rotax.multiply(start);
                end = rotaz.multiply(end);
                end = rotay.multiply(end);
                end = rotax.multiply(end);
                
                
                double xStart = Scaler.unscaleDoubleToDouble(start.x(), scaleUse);
                double yStart = Scaler.unscaleDoubleToDouble(start.y(), scaleUse);
                double zStart = Scaler.unscaleDoubleToDouble(start.z(), scaleUse);
                double xEnd = Scaler.unscaleDoubleToDouble(end.x(), scaleUse);
                double yEnd = Scaler.unscaleDoubleToDouble(end.y(), scaleUse);
                double zEnd = Scaler.unscaleDoubleToDouble(end.z(), scaleUse);
                
                addXOffset((int)(xEnd-xStart));
                addYOffset((int)(-(yEnd-yStart)));
                addZOffset((int)(zEnd-zStart));

                
                
                
                
                
                
                mXPressStart = mX;
                mYPressStart = mY;

                sharedRepaint();
                fireMouseMoved(evt);
                return;
            }
        }
        
        // when vector for continuing is drawn, do't DRAG
        if (!vars.continueMode)
        {
            if (vars.pressed)  // than "dragged" by non MouseButton1
                vars.dragging = true;
            vars.crossColor = VECCI_CROSS_DRAG_COLOR;
        }
        
        if (vars.displayDragSelection) 
        {
            if ((vars.workingMode == SVP_SELECT_POINT) ||  (vars.workingMode == SVP_SELECT_LINE))
            {
                if ((vars.dragging) ||  (vars.pressed) )
                {
                    /*
                    int x =  mXPressStart; 
                    int y =  mYPressStart; 
                    int w =  mX-mXPressStart; 
                    int h =  mY-mYPressStart; 

                    lastCrossX
                    lastCrossY
                    
                    if (mX<mXPressStart)
                    {
                        x = mX;
                        w =  mXPressStart-mX; 
                    }
                    if (mY<mYPressStart)
                    {
                        y = mY;
                        h =  mYPressStart-mY; 
                    }
                    selectAllInArea(x,y,w,h);
                    */
                }
            }
        }
        
        sharedRepaint();
        if (vars.pressed)  // than "dragged" by non MouseButton1
            fireMouseMoved(evt);
    }
    
    protected void handleMouseDraggedEventNew(java.awt.event.MouseEvent evt)
    {
        if (vars.noMouseReaction) return;
        
        int usedxOff = usePrivateOffset?xOffset:vars.xOffset;
        int usedyOff = usePrivateOffset?yOffset:vars.yOffset;
        int usedzOff = usePrivateOffset?zOffset:vars.zOffset;

        Matrix4x4 rotax = Matrix4x4.getRotationX(Math.toRadians(axisXAngle));
        Matrix4x4 rotay = Matrix4x4.getRotationY(Math.toRadians(axisYAngle));
        Matrix4x4 rotaz = Matrix4x4.getRotationZ(Math.toRadians(axisZAngle));
        
        
        
        
        // transformation
        Vertex p1x = new Vertex(1,0,0);
        Vertex p1y = new Vertex(0,1,0);
        Vertex p1z = new Vertex(0,0,1);

        p1x.x(p1x.x()+usedxOff);
        p1x.y(p1x.y()-usedyOff);
        p1x.z(p1x.z()+usedzOff);
        p1x = rotax.multiply(p1x);
        p1x = rotay.multiply(p1x);
        p1x = rotaz.multiply(p1x);
        

        p1y.x(p1y.x()+usedxOff);
        p1y.y(p1y.y()-usedyOff);
        p1y.z(p1y.z()+usedzOff);
        p1y = rotax.multiply(p1y);
        p1y = rotay.multiply(p1y);
        p1y = rotaz.multiply(p1y);

        p1z.x(p1z.x()+usedxOff);
        p1z.y(p1z.y()-usedyOff);
        p1z.z(p1z.z()+usedzOff);
        p1z = rotax.multiply(p1z);
        p1z = rotay.multiply(p1z);
        p1z = rotaz.multiply(p1z);
        
        Vertex startDrag = new Vertex(Scaler.unscaleDoubleToInt(mXPressStart-x0Offset, scale), Scaler.unscaleDoubleToInt(mYPressStart-y0Offset, scale), 0);
        Vertex endDrag = new Vertex(Scaler.unscaleDoubleToInt(mX-x0Offset, scale), Scaler.unscaleDoubleToInt(mY-y0Offset, scale), 0);
        
        
            
        // point zero in screen coordinates
        
        
        mX=evt.getX();
        mY=evt.getY();

        int x =  mXPressStart; 
        int y =  mYPressStart; 
        int w =  mX-mXPressStart; 
        int h =  mY-mYPressStart; 

        Matrix4x4 rotaxI = Matrix4x4.getRotationX(Math.toRadians(axisXAngle));
        Matrix4x4 rotayI = Matrix4x4.getRotationY(Math.toRadians(axisYAngle));
        Matrix4x4 rotazI = Matrix4x4.getRotationZ(Math.toRadians(axisZAngle));
        rotaxI.transpose();
        rotayI.transpose();
        rotazI.transpose();

        if (vars.pressed)
        {
            if (vars.ctrlPressed)
            {
                // drag location
                vars.dragging = true;
                double scaleUse = usePrivateScale?scale:vars.scale;

                
//                Vertex start = new Vertex(p1y.x(),p1y.y(),p1y.z());
                Vertex start = new Vertex(0,0,0);
                Vertex end = new Vertex(Scaler.unscaleDoubleToDouble(w, scaleUse),Scaler.unscaleDoubleToDouble(h, scaleUse),0);
//                Vertex end = new Vertex(p1x.x(),p1x.y(),p1x.z());
                
                start = rotazI.multiply(start);
                start = rotayI.multiply(start);
                start = rotaxI.multiply(start);
                
                end.y(-end.y());
                
                end = rotazI.multiply(end);
                end = rotayI.multiply(end);
                end = rotaxI.multiply(end);
                
                
                
                addXOffset((int)(end.x()-start.x()));
                addYOffset((int)(-(end.y()-start.y())));
                addZOffset((int)(end.z()-start.z()));

                
                
                
                
                
                
                mXPressStart = mX;
                mYPressStart = mY;

                sharedRepaint();
                fireMouseMoved(evt);
                return;
            }
        }
        
        // when vector for continuing is drawn, do't DRAG
        if (!vars.continueMode)
        {
            if (vars.pressed)  // than "dragged" by non MouseButton1
                vars.dragging = true;
            vars.crossColor = VECCI_CROSS_DRAG_COLOR;
        }
        
        if (vars.displayDragSelection) 
        {
            if ((vars.workingMode == SVP_SELECT_POINT) ||  (vars.workingMode == SVP_SELECT_LINE))
            {
                if ((vars.dragging) ||  (vars.pressed) )
                {
                }
            }
        }
        
        sharedRepaint();
        if (vars.pressed)  // than "dragged" by non MouseButton1
            fireMouseMoved(evt);
    }    

    public boolean is3d()
    {
        return true;
    }
    public void fireMouseMoved(MouseEvent evt)
    {
        EditMouseEvent e = new EditMouseEvent();
        e.evt = evt;
        e.panel = this;
        e.mouseExited = mouseExited;
        e.dragging = vars.dragging;

        e.shiftPressed = vars.shiftPressed;
        e.ctrlPressed = vars.ctrlPressed;
        
        vars.pressed = true;
        if (vars.dragging)
        {
            e.dragOriginX = mDragOriginX;
            e.dragOriginY = mDragOriginY;
            e.dragOriginZ = mDragOriginZ;
            

            double scaleUse = usePrivateScale?scale:vars.scale;
            Matrix4x4 rotax = Matrix4x4.getRotationX(Math.toRadians(axisXAngle));
            Matrix4x4 rotay = Matrix4x4.getRotationY(Math.toRadians(axisYAngle));
            Matrix4x4 rotaz = Matrix4x4.getRotationZ(Math.toRadians(axisZAngle));
            rotax.transpose();
            rotay.transpose();
            rotaz.transpose();
            
            Vertex start = new Vertex(evt.getX()-x0Offset, -(evt.getY()-y0Offset),0);
                
            
            start = rotaz.multiply(start);
            start = rotay.multiply(start);
            start = rotax.multiply(start);
                
            double xStart = Scaler.unscaleDoubleToDouble(start.x(), scaleUse);
            double yStart = Scaler.unscaleDoubleToDouble(start.y(), scaleUse);
            double zStart = Scaler.unscaleDoubleToDouble(start.z(), scaleUse);
            
            
            if (isGrid())
            {
                lastCrossX = (int) ((int) ( ((double)xStart)/((double)vars.gridWidth) +(((double)1)/2)) * ((double)vars.gridWidth));
                lastCrossY = (int) ((int) ( ((double)yStart)/((double)vars.gridWidth) +(((double)1)/2)) * ((double)vars.gridWidth));
                lastCrossZ = (int) ((int) ( ((double)zStart)/((double)vars.gridWidth) +(((double)1)/2)) * ((double)vars.gridWidth));
            }
            else
            {
                lastCrossX = (int)xStart;
                lastCrossY = (int)yStart;
                lastCrossZ = (int)zStart;
            }
            
            
            
            
            e.dragNowX = lastCrossX;
            e.dragNowY = lastCrossY;
            e.dragNowZ = lastCrossZ;
            mDragOriginX= lastCrossX;
            mDragOriginY = lastCrossY;
            mDragOriginZ = lastCrossZ;
        }

        if ((!vars.dragging) && ( !vars.continueMode ))
        {
            mXPressStart = evt.getX();
            mYPressStart = evt.getY();

            // ensure the cross!
            mXPressStart = lastCrossX;
            mYPressStart = lastCrossY;
        }
        /*
        double scaleUse = usePrivateScale?scale:vars.scale;
        
        double translocation = (e.dragOriginX-e.dragNowX);
        if (vars.displayGrid)
            translocation = (translocation/vars.gridWidth)*vars.gridWidth;
        translocation = Scaler.scaleDoubleToDouble(translocation, scaleUse);
        
        
        
        */
        Vertex trans = new Vertex();
        
        
        
        if (moveXAllowed) trans.x(e.dragOriginX-e.dragNowX);
        if (moveYAllowed) trans.y(e.dragOriginY-e.dragNowY);
        if (moveZAllowed) trans.z(e.dragOriginZ-e.dragNowZ);

        e.translocationInVectrexPoint = trans;
        e.currentVectrexPoint =  convertToVectrex(getCurrentPoint());
                
        e.highlightedPoint = vars.hightLightVPoint;
        e.highlightedVector = vars.hightLightVector;
        for (int i=0; i<vars.mMovedListener.size(); i++)
        {
            vars.mMovedListener.elementAt(i).moved(e);
        }
    }
}
